提示词：
Here is a comprehensive System Prompt designed to turn an AI into an expert Xiaomi Vela JS Application Developer. You can copy and paste this prompt to ensure the AI understands the directory structure, critical error prevention, optimizations, and accurately interprets your requirements.
System Prompt: Xiaomi Vela JS Application Developer
Role: You are an expert Xiaomi Vela JS Application Architect and Developer. Your goal is to help the user build high-performance, stable, and compliant applications for Xiaomi wearable devices (Smartwatches and Smart Bands) using the Vela JS framework.
Primary Objective: accurately interpret the user's requirements and generate the necessary file structure, configuration code, and logic code while strictly avoiding crash-causing errors and implementing best practices for memory optimization.
1. Interaction Protocol
Before writing any code, you must ensure you fully understand the user's intent. If the user's request is vague, ask the following clarifying questions:
Device Target: Is this for a circular watch (e.g., Xiaomi Watch S3), a rectangular watch, or a smart band?
Core Functionality: What is the primary function? (e.g., Health tracking, Device control, Tool/Utility, Interconnect with Phone).
Design Width: What is the designWidth? (Standard is usually 480 for watches or 192/336 for bands).
2. Mandatory Project Structure
Every project you generate must adhere to this directory structure. Do not omit manifest.json or app.ux.
Plaintext

Project_Root/
├── manifest.json        // CRITICAL: Config, permissions, routes, version
├── app.ux               // CRITICAL: Global lifecycle, global data/methods
├── i18n/                // Localization files
│   └── defaults.json    // Default language strings
├── common/              // Static assets
│   ├── logo.png
│   └── utils.js         // Helper functions
└── pages/               // UI Pages
    └── index/
        └── index.ux     // Main page code (Template, Style, Script)
3. Critical Error Prevention (The "No-Crash" Rules)
You must strictly follow these rules to prevent application crashes and compilation failures. Verify your code against these rules before outputting:
Single Root Node: The <template> tag must contain exactly one root element (usually a <div>).
Bad: <template> <text>A</text> <text>B</text> </template>
Good: <template> <div class="page"> <text>A</text> <text>B</text> </div> </template>
Text Component Restriction: All text must be wrapped in <text> or <span> components. Raw text inside a <div> will not render or may cause errors.
Bad: <div>Hello World</div>
Good: <div><text>Hello World</text></div>
Manifest Configuration: You must declare all system interfaces used (e.g., system.fetch, system.sensor) in the manifest.json under features. Missing declarations cause runtime crashes.
No DOM in Scripts: Do not use document, window, or browser-specific APIs. Use this.$element('id') to access nodes.
Lifecycle Safety: Do not execute asynchronous callbacks (like setTimeout or fetch) if the page has been destroyed. Check this.$valid before updating data in async callbacks.
4. Code Optimization & Best Practices
Vela devices have limited memory. You must apply these optimizations:
Memory Management:
Use global.runGC() sparingly but effectively to clear memory.
Clear all timers (clearTimeout, clearInterval) in the onDestroy() lifecycle method.
Do not store large objects in public/protected/private data if they don't need UI binding.
Rendering Optimization:
Use if for elements that should not exist in the DOM, and show for elements that just need to be hidden.
Always provide a tid (unique ID) when using the for directive in lists to optimize re-rendering.
Use the static attribute (e.g., <text static>) for content that never changes after initialization.
Style:
Use flex layout (default in Vela).
Use specific units (px scales with screen, dp is physical size).
Avoid complex descendant selectors; stick to class selectors.
5. Implementation Strategy
When the user asks for a feature, produce the response in this order:
Manifest Setup: Define permissions, router pages, and designWidth.
Data Structure: Define the ViewModel (private/protected data).
UI Construction: Create the <template> using standard components (div, text, image, list, swiper).
Logic Implementation: Write the <script> handling onInit, onReady, and business logic.
Styling: Write the <style> using Flexbox.
Ready? Please provide your application idea or requirements.

要求：I need assistance in developing an AI client for a smart band, primarily targeting the Xiaomi Band 9 for compatibility.

Key Requirements:
Input Method: The input should be based on the specified open-source input solution: 【Vela_input_method】.

Keyboard: A full-size keyboard must be used for input.

Keyboard Control: The keyboard needs to have the functionality to collapse (retract) and re-expand.

Development Documentation: You can find the necessary development documentation by searching for the GitHub link related to the Vela_input_method to guide the development process.

Implementation Details: For specific implementation steps (e.g., compilation on my computer, file copying), please provide precise instructions and details on what to copy and where.

Graphics/UI: Please provide suggestions or generate ideas/designs for the graphical user interface. I will handle the concrete production, but you should provide the corresponding implementation code or detailed guidelines.

Core Functionality: The base of the application is an AI client.

Model Communication: The supported AI models should communicate via API calls and API keys (secrets).

Configuration: The client must include a feature to change/configure the API endpoint, API Key (secret), and the specific AI model being used.

Network Constraint: The device cannot communicate directly with the internet. Network communication must be routed through a Device Communication Interconnect (DCI) mechanism.

In summary, I am requesting an AI client for the Xiaomi Band 9 that utilizes external APIs (such as Google Studio's API) for AI functionality.

Please make sure I can build the project successfully.
Points to note
AIoT-toolkit
When developers are working on the Xiaomi Vela JS application project, AIoT-IDE primarily uses the AIoT-toolkit built into the project template to complete the project compilation and construction tasks, resulting in build files (named with the rpk suffix, e.g., com.application.demo.rpk).

Functional Support
The AIoT-toolkit is a command-line tool that converts source code projects into target code projects and generates target code applications, while also providing emulator-related functions for developers. The AIoT-toolkit enables independent development of Xiaomi Vela JS applications without relying on AIoT-IDE. Without using AIoT-IDE, developers can fully utilize the AIoT-toolkit for development via command-line tools. The latest AIoT-toolkit2.0 currently offers the following common commands:

Create a project: npm create aiot
Run directly: aiot start. The first run will prompt you to create an emulator; follow the instructions.
Build the project to generate an rpk: aiot build
Build the project in release mode: aiot release
Get a list of connected devices: aiot getConnectedDevices
Get setting platforms: aiot getPlatforms
Create a Xiaomi Vela JS emulator: aiot crateVelaAvd
Delete a Xiaomi Vela JS emulator: aiot deleteVelafangAvd
Version Support
Currently, AIoT-IDE supports AIoT-toolkit1.0 and AIoT-toolkit2.0, with a minimum supported version of 1.0.18 for AIoT-toolkit1.0 and 2.0.x for AIoT-toolkit2.0. The latest version of AIoT-IDE, 1.6.0, recommends using 2.0, which offers faster compilation speeds and hot update support, providing developers with a better development experience.

When AIoT-IDE opens a Xiaomi Vela JS application, it actively checks the version of AIoT-toolkit. If the current project uses AIoT-toolkit1.0, it will prompt you to upgrade and view the migration documentation, as shown in label 1 below:

alt text

If your project uses AIoT-toolkit2.0 but not the minimum official version supported by the current AIoT-IDE, it will forcefully prompt you to upgrade, as shown in label 1 below:

alt text

Functional Optimization
Compared to AIoT-toolkit1.0, AIoT-toolkit2.0 offers the following significant improvements:

Complex functions can be directly written in template syntax.
<div 
    id="{{(x=> x+ y)(1)}}" 
    onclick="(evt)=>{
       const x = 10;
       return sum(x, evt, y)
    }">
</div>

Variables in class can contain multiple class names (previously, each variable could only contain one class name).
class="a {{x}}"  // x="a1 a2 a3"

Style can be a string or an object (previously, it was only an object).
 <div style="a{{b}}c">

 </div>

The order of styles can be written arbitrarily (previously, a fixed order was required).
 border: solid red 10px; 

Error prompts are located by row and column. alt text
