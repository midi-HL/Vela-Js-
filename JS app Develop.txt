Quick Start

Project Structure
This chapter explains the role of each part in a Vela JS application project based on the project initialized in Environment Setup.

Directory Structure
A Vela JS application project consists of configuration files (manifest.json), template code (ux files), style code (css files), logic code (js files), and resource files (images, audio, etc.).

A typical project directory structure is as follows:

├── manifest.json
├── app.ux
├── pages
│   ├── index
|   |   └── index.ux
│   └── detail
|       └── detail.ux
├── i18n
|   ├── defaults.json
|   ├── zh-CN.json
|   └── en-US.json
└── common
    ├── style.css
    ├── utils.js
    └── logo.png

Configuration File
The manifest.json file in the project root directory is the configuration file for the project. Information such as application information, system interfaces used, and page routes need to be declared in this configuration file.

For detailed configuration field descriptions, refer to Project Configuration.

ux Template
A page usually consists of three parts: page structure, style, and logic interaction. These three parts can be placed in a single ux file or as separate files.

If placed in a single ux file, the ux file needs to include three tags: template, style, and script.

Example:

<template>
  <div class="page">
    <text class="title">Welcome to {{title}}</text>
    <input class="btn" type="button" value="Jump to detail page" onclick="routeDetail">
  </div>
</template>

<style>
  .btn {
    width: 400px;
    height: 60px;
    background-color: #09ba07;
    color: #ffffff;
  }
</style>

<script>
  import router from '@system.router'

  export default {
    // Page data object
    private: {
      title: 'Example Page'
    },
    // Callback after button click
    routeDetail() {
      router.push({
        uri: '/pages/detail'
      })
    }
  }
</script>

If the page structure, style, and logic interaction are separated into independent files, the following directory structure can be used:

├── ...
├── pages
│   ├── ...
│   └── detail
|       ├── detail.ux
|       ├── detail.css
|       └── detail.js
├── ...

Note

If separated into independent files (ux/css/js), the ux file cannot contain the template tag.

app.ux
app.ux is used to define the App's lifecycle, global data, or global methods.

For detailed usage methods, refer to app.ux.

common
The common folder is mainly used to store public resources such as images, audio, and public styles.

i18n
The i18n folder is used to store multilingual configuration files.


Write Page UI
In the previous section Project Structure, we introduced the roles of files and directories in a Vela JS application project. After gaining a certain understanding of the project structure, we will now implement a simple weather forecast app.

This chapter will implement the page UI of the app, with the main content being: the basic structure of the page, styling, data structure definition, and data rendering.

Restyling according to the UI design draft is a detailed and time-consuming task. To improve work efficiency, it is generally recommended to first conceive the overall implementation approach of the page (page structure, styling, and interactions, etc.), then write the page structure, followed by uniformly adding styling, and finally adding data rendering and interactions.

In this usage guide, to facilitate the demonstration of page structure, styling, and interaction development in Vela JS applications, the above development process is adopted. In actual development, developers can also choose a workflow that suits their own development habits.

TIP

This section contains a relatively large number of code snippets. If you are already familiar with HTML/CSS/JavaScript, you can choose to skip this section. However, we still recommend that you read the content of this chapter to understand some differences between Vela JS application development and traditional front-end development.

Functional Requirements
The weather forecast app we are going to implement consists of two pages: Real-time Weather and 3-Day Weather Forecast. The real-time weather interface displays the current weather conditions, mainly including information such as weather, temperature, humidity, and visibility. The 3-day weather forecast page is used to display the weather conditions for the next three days.

The final effect to be achieved is shown in the following figures:

Real-time Weather 7-Day Forecast

Preparation
This app uses the QWeather API to obtain weather data, and icons use the QWeather Icons.

The weather app in this usage guide is only for demonstrating Vela JS application development techniques. If you need to use related interfaces and resources in actual projects, please register and activate the interfaces on the QWeather developer platform. Detailed information can be viewed on the official website:

QWeather Developer Platform: https://dev.qweather.com/(opens new window)
QWeather Icons: https://icons.qweather.com/(opens new window)
Icon Download Address: https://github.com/qwd/WeatherIcon(opens new window)
Page Structure
In the Project Structure chapter, we introduced that a page (ux file) consists of three parts: template, style, and script. Next, we will write the template (template) code for these two pages respectively.

Very similar to HTML, Vela's page template is also composed of tags and attributes, and the syntax is mostly consistent with HTML. The difference is that Vela has its own set of built-in components, which are not exactly the same as those supported by HTML.

In the following code, we use the div, text, and image components. For detailed usage methods of components, you can refer to the Vela Official Documentation - Components.

Real-time Weather
The real-time weather page can be divided into three parts from top to bottom: header, body, and footer. The code is as follows.

<template>
  <div class="page">
    <!-- Header city information -->
    <div class="header"></div>
    <div class="body">
      <!-- Main weather information -->
      <div class="info"></div>
      <!-- Perceived temperature and other information -->
      <div class="more-info"></div>
    </div>
    <!-- Footer update time -->
    <div class="footer"></div>
  </div>
</template>

Warm Tip

The template can only have one root node.

The header information, including city, province, and country information, has a relatively simple structure. The code is as follows:

<!-- Header city information -->
<div class="header">
  <text class="city">Wuhan</text>
  <text class="province">Hubei/China</text>
</div>

Warm Tip

Text must be placed in the text component; otherwise, the text will not be displayed on the interface.

The weather information section is slightly more complex than the header. It can be generally divided into two columns, with the right column further divided into two rows. The code is as follows:

<!-- Main weather information -->
<div class="info">
  <image class="icon" src="/common/icons/101.png"></image>
  <div class="column center">
    <text class="temp">6°</text>
    <text class="weather">Clear to Cloudy</text>
  </div>
</div>

Next, we implement the module for perceived temperature and other information. It can be generally divided into three columns, with each column further divided into two rows. The code is as follows:

<!-- Perceived temperature and other information -->
<div class="more-info row">
  <div class="item column center">
    <text class="value">10°</text>
    <text class="label">Perceived Temperature</text>
  </div>
  <div class="item column center">
    <div><text class="value">67</text><text class="sub">%</text></div>
    <text class="label">Humidity</text>
  </div>
  <div class="item column center">
    <div><text class="value">5</text><text class="sub">km</text></div>
    <text class="label">Visibility</text>
  </div>
</div>
</div>

Finally, the footer update time module has a relatively simple structure. The code is as follows:

<!-- Footer update time -->
<div class="footer center">
  <text class="update-time">Data updated on 12-20 09:15</text>
</div>

3-Day Weather Forecast
The structure of this page is the same as that of the real-time weather page, also divided into three parts from top to bottom, and the content of the header and footer is the same, so it will not be repeated here.

Next, we mainly look at the implementation of the middle part, which mainly includes the 3-Day Weather Overview and the Weather List.

The weather overview is divided into two rows. The code is as follows:

<!-- Weather Overview -->
<div class="info">
  <text class="title">3-Day Forecast</text>
  <text class="summary">High 8° Low -6°</text>
</div>

The weather list is slightly more complex. First, it can be generally divided into three columns, with each column further divided into three rows. The code is as follows:

<!-- 3-Day Weather -->
<div class="list">
  <div class="item">
    <text class="date">Sunday</text>
    <image class="icon" src="/common/icons/301.png"></image>
    <text class="temp">-6°~8°</text>
  </div>
  <div class="item">
    <text class="date">Monday</text>
    <image class="icon" src="/common/icons/311.png"></image>
    <text class="temp">-9°~4°</text>
  </div>
  <div class="item">
    <text class="date">Tuesday</text>
    <image class="icon" src="/common/icons/100.png"></image>
    <text class="temp">-3°~6°</text>
  </div>
</div>

Page Styling
Vela supports commonly used CSS features, with a small amount of expansion and modification. It by default supports adaptation to different screen sizes. Detailed attribute support can be queried in the Attribute List.

Vela JS applications use the flex layout, which can conveniently implement commonly used layout styles. For technical details of the flex layout, you can refer to the MDN Documentation (opens new window).

Currently, only class selectors, ID selectors, grouping selectors (,), and tag selectors are supported. Descendant selectors, attribute selectors, universal selectors (*), sibling selectors (+), direct parent-child selectors (>), pseudo-classes, and inheritance are not supported.

So far, we have completed the coding of the page structure, but no styling has been set yet. Next, we will implement the styling of each module.

Common Styling
Before writing the styling code, we can first extract some basic common styling, such as arrangement methods, colors, and alignment methods.

In our project, we mainly use horizontal and vertical arrangements, centering, etc. In terms of colors, the main color is white, so we can set the default color of the text to white.

The extracted basic styling is as follows:

/* Common styling */
text {
  color: #ffffff;
}

.column {
  flex-direction: column;
}

.row {
  flex-direction: row;
}

.center {
  align-items: center;
  justify-content: center;
}

page
To solve the screen adaptation problem, all styles related to size (such as width and font-size) are scaled based on a reference width (default 480px) according to the actual screen width. For example, width:100px on a 960px width screen is actually 200px.

Our design draft is designed with a width of 480px, so the dimensions in the design draft can be directly used in the styling. For example, in the following figure, the overall width is 480, and the dimensions of the module for perceived temperature and other information are 335*100, so the CSS code is:

.info {
  width: 335px;
  height: 100px; 
}

Design Draft Dimensions

For the overall page, we first set the page background to black, the shape to circular, and the page width.

.page {
  padding: 40px;
  background-color: #000000;
  width: 480px;
  border-radius: 240px;
}

Note

If the reference width of the design draft is not 480, it can be configured in the manifest.json file through the config.designWidth field:

{
  // ...
  "config": {
    "designWidth": 360
  }
}

Header Information
The header information is arranged vertically and centered, using the previously extracted common styling: column and center. Then, add styling to the text to control the font size and color.

The modified template code is as follows:

<!-- Header city information -->
<div class="header column center">
  <text class="city">Wuhan</text>
  <text class="province">Hubei/China</text>
</div>

The CSS code is as follows:

/* Header styling */
.city {
  font-size: 40px;
}

.province {
  font-size: 18px;
  color: #757575;
}

Actual running result:
Header Information Running Result

Real-time Weather
Similar to the header information, first add the basic styling column, row, and center to achieve the basic layout. Then, write targeted CSS code for each text component to achieve styling such as text color and size.

The completed template code is as follows:

<div class="body column center">
  <!-- Main weather information -->
  <div class="info">
    <image class="icon" src="/common/icons/101.png"></image>
    <div class="column center">
      <text class="temp">6°</text>
      <text class="weather">Clear to Cloudy</text>
    </div>
  </div>
  <!-- Perceived temperature and other information -->
  <div class="more-info row">
    <div class="item column center">
      <text class="value">10°</text>
      <text class="label">Perceived Temperature</text>
    </div>
    <div class="item column center">
      <div><text class="value">67</text><text class="sub">%</text></div>
      <text class="label">Humidity</text>
    </div>
    <div class="item column center">
      <div><text class="value">5</text><text class="sub">km</text></div>
      <text class="label">Visibility</text>
    </div>
  </div>
</div>

For the module of perceived temperature and other information, first arrange it horizontally (flex-direction: row), and then set flex: 1 for each item to achieve the effect of equal width for each item.

Specifically, inside each item, just set the color and size of each text field respectively.

The CSS code is as follows:

/* Weather data styling */
.body {
  flex: 1;
}

.temp {
  font-size: 70px;
}

.icon {
  width: 170px;
  height: 170px;
  margin-right: 20px;
}

.weather {
  font-size: 24px;
}

/* More information styling */
.more-info {
  width: 335px;
  height: 100px;
  background-color: rgba(255, 255, 255, 0.21);
  border-radius: 15px;
}

.item {
  flex: 1;
}

.value {
  font-size: 30px;
}

.sub {
  font-size: 14px;
  margin-top: 10px;
}

.label {
  color: #757575;
  margin-top: 5px;
}

Actual running result:
Real-time Weather Running Result

3-Day Weather Forecast
The styling of the weather overview information module is relatively simple, just arrange it vertically.

Similar to the module of perceived temperature and other information, the 3-day weather list also uses horizontal arrangement. The difference is that each item has a background color and spacing between them, so fixed dimensions are set for each item, and then the spacing between each item is allocated (justify-content: space-between) according to the remaining space.

The modified template code is as follows:

<!-- 3-Day Weather -->
<div class="list row">
  <div class="item column center">
    <text class="date">Sunday</text>
    <image class="icon" src="/common/icons/301.png"></image>
    <text class="temp">-6°~8°</text>
  </div>
  <div class="item column center">
    <text class="date">Monday</text>
    <image class="icon" src="/common/icons/311.png"></image>
    <text class="temp">-9°~4°</text>
  </div>
  <div class="item column center">
    <text class="date">Tuesday</text>
    <image class="icon" src="/common/icons/100.png"></image>
    <text class="temp">-3°~6°</text>
  </div>
</div>

The CSS code is as follows:

/* Weather data styling */
.body {
  flex: 1;
}

.info {
  margin-bottom: 20px;
}

.title {
  font-size: 30px;
}

.summary {
  font-size: 24px;
  color: #757575;
}

/* 3-Day Weather */
.list {
  width: 380px;
  justify-content: space-between;
}

.item {
  width: 120px;
  height: 175px;
  background-color: rgba(255, 255, 255, 0.2);
  border-radius: 15px;
}

.date {
  font-size: 28px;
}

.icon {
  width: 90px;
  height: 90px;
}

.temp {
  font-size: 24px;
}

Actual running result:
Real-time Weather Running Result

Footer Information
The final template code for the footer information is as follows:

<!-- Footer update time -->
<div class="footer center">
  <text class="update-time">Data updated on 12-20 09:15</text>
</div>

The CSS code is as follows:

/* Footer styling */
.footer {
  margin-top: 20px;    
}

.update-time {
  color: #757575;
}

Actual running result:
Real-time Weather Running Result

Page Effect
After completing the page structure and styling, the actual running results in the simulator are as follows:

Real-time Weather Running Result 3-Day Weather Running Result

Page Data
We have implemented the rendering of page data, but currently, all the data is directly written into the template code and cannot be dynamically modified in the program.

If you need to dynamically modify the data displayed on the interface in the program, you need to store the data in the Page Data Object and then use the double curly brace syntax to reference the data, such as {{ name }}. Detailed usage methods can be referred to in the Template Syntax.

Data definition needs to be implemented through JavaScript scripts. Like HTML, JavaScript code needs to be placed in the script tag:

<script>
  export default {
    private: {
      city: 'Wuhan',
      province: 'Hubei',
      country: 'China',
      weather: {
        // Data observation time
        obsTime: "12-21 09:05",
        // Temperature
        temp: "13",
        // Perceived temperature
        feelsLike: "10",
        // Weather icon number
        icon: "101",
        // Weather description text
        text: "Cloudy",
        // Relative humidity
        humidity: "72",
        // Visibility, unit: km
        vis: "16"
      }
    }
  }
</script>

After defining the data, replace the previous template code. The replaced code is as follows:

<template>
  <div class="page column">
    <!-- Header city information -->
    <div class="header column center">
      <text class="city">{{city}}</text>
      <text class="province">{{province}}/{{country}}</text>
    </div>
    <div class="body column center">
      <!-- Main weather information -->
      <div class="info">
        <image class="icon" src="/common/icons/{{weather.icon}}.png"></image>
        <div class="column center">
          <text class="temp">{{weather.temp}}°</text>
          <text class="weather">{{weather.text}}</text>
        </div>
      </div>
      <!-- Perceived temperature and other information -->
      <div class="more-info row">
        <div class="item column center">
          <text class="value">{{weather.feelsLike}}°</text>
          <text class="label">Perceived Temperature</text>
        </div>
        <div class="item column center">
          <div><text class="value">{{weather.humidity}}</text><text class="sub">%</text></div>
          <text class="label">Humidity</text>
        </div>
        <div class="item column center">
          <div><text class="value">{{weather.vis}}</text><text class="sub">km</text></div>
          <text class="label">Visibility</text>
        </div>
      </div>
    </div>
    <!-- Footer update time -->
    <div class="footer center">
      <text class="update-time">Data updated on {{weather.obsTime}}</text>
    </div>
  </div>
</template>

List Rendering
In the 3-day weather forecast page, array storage is used for the weather data of the next 3 days. The for directive can be used for rendering (detailed usage methods of the for directive can be referred to in the List Rendering).

The data definition is as follows:

{
  list: [
    {
      "fxDate": "Sunday",
      "tempMax": "12",
      "tempMin": "-1",
      "iconDay": "101",
      "textDay": "Cloudy",
    },
    {
      "fxDate": "Monday",
      "tempMax": "13",
      "tempMin": "0",
      "iconDay": "100",
      "textDay": "Sunny"
    },
    {
      "fxDate": "Tuesday",
      "tempMax": "13",
      "tempMin": "0",
      "iconDay": "302",
      "textDay": "Sunny",
      "iconNight": "150",
      "textNight": "Sunny"
    }
  ]
}

The template code is as follows:

<!-- 3-Day Weather -->
<div class="list row">
  <div class="item column center" for="{{list}}">
    <text class="date">{{$item.fxDate}}</text>
    <image class="icon" src="/common/icons/{{$item.iconDay}}.png"></image>
    <text class="temp">{{$item.tempMin}}°~{{$item.tempMax}}°</text>
  </div>
</div>

List Rendering Result

Conditional Rendering
In actual projects, conditional judgments are often required to render different UIs based on different conditions. For conditional rendering, please refer to the Conditional Directives.


Adding Interaction
In the previous chapter, we have already written the structure and style of two pages, but there is no connection between the two pages. In this chapter, we will implement page jumps.

Registering Events
Page jumps are triggered by users and require adding corresponding events to specific elements on the page, such as click/touchstart. For more details about events, please refer to General Events.

In this weather forecast app, the interaction we use is swiping to switch pages:

On the real-time weather page, swipe up to enter the 3-day weather forecast page;
On the 3-day weather forecast page, swipe right to return to the real-time weather page.
We want the swipe action to perform the jump no matter where it occurs on the page, so we register the swipe event (swipe) on the root node.

The template code is as follows:

<template>
  <div class="page column" @swipe="toListPage">
    <!-- Other content of the page -->
  </div>
</template>

Note

@swipe="toListPage" can also be written as onswipe="toListPage". For details, please refer to Event Binding.

Page Jump
After registering the event, we need to define the toListPage() callback method in the JavaScript code. By judging the swipe direction, we decide whether to perform a page jump. Page jumps require the use of the @system.router module. Please declare it in manifest.json before using it:

{
  // ...
  "features": [
    { "name": "system.router" }
  ]
}

Note

For more details about router, please refer to Page Switching.

After declaring the module, you can import it in the JavaScript script and then use the API provided by router to jump between pages:

<script>
  import router from '@system.router'

  export default {
    // ...
    toListPage(eve) {
      if (eve.direction === 'up') {
        router.push({
          uri: '/pages/list'
        })
      }
    }
  }
</script>

Similarly, on the 3-day weather forecast page, use the same method to implement the page return logic. The corresponding code is:

<template>
  <div class="page column" @swipe="toHomePage">
    <!-- Other content of the page -->
  </div>
</template>

<script>
  import router from '@system.router'

  export default {
    // ...
    toHomePage(eve) {
      if (eve.direction === 'right') {
        router.back()
      }
    }
  }
</script>


Data Acquisition
In the previous chapters, we have implemented the UI of the weather forecast app and added basic interactions. However, the data displayed on the page is not real data. Next, we will request real data from the HeWeather API and render it.

Requesting API Data
Network requests require the use of the Data Request fetch module. Please declare it in the manifest.json file before using it.

The fetch module provides the fetch() method. For detailed usage, please refer to the Vela documentation.

Each page has its own lifecycle. You can send requests in the onReady method. The code is as follows:

<script>
  import router from '@system.router';
  import fetch from '@system.fetch';

  export default {
    private: {
      // ...
    },

    onReady() {
      let key = '<your key>';
      // location, using Wuhan's code here
      // For more location codes, refer to: https://github.com/qwd/LocationList
      fetch.fetch({
        url: `https://devapi.qweather.com/v7/weather/now?location=101010100&key=${key}`
      }).then(res => {
        const result = res.data;
        console.log('Returned data:', JSON.stringify(result.data, null, 2));
      }).catch(error => {
        console.log(`Data request failed:`, error);
      })
    },

    // ...
  }
</script>
Before using, please apply for a key on the HeWeather development platform and replace the key in the above code.

After adding the above code and replacing it with a valid key, run the app. You should see logs similar to the following in the console, indicating that the request was successful.

Returned data: {
  "code": "200",
  "updateTime": "2022-01-04T10:07+08:00",
  "fxLink": "http://hfx.link/2ax1",
  "now": {
    "obsTime": "2022-01-04T09:54+08:00",
    "temp": "-1",
    "feelsLike": "-4",
    "icon": "100",
    "text": "Sunny",
    "wind360": "45",
    "windDir": "Northeast",
    "windScale": "2",
    "windSpeed": "7",
    "humidity": "55",
    "precip": "0.0",
    "pressure": "1029",
    "vis": "15",
    "cloud": "10",
    "dew": "-17"
  },
  "refer": {
    "sources": [
      "QWeather",
      "NMC",
      "ECMWF"
    ],
    "license": [
      "no commercial use"
    ]
  }
}
Data Rendering
After requesting data from the backend, you need to display it on the page. To display the data, simply update the corresponding data in the page data object:

this.weather = result.data.now;
Here is the complete JavaScript code for the final page:

<script>
  import router from '@system.router';
  import fetch from '@system.fetch';

  export default {
    private: {
      city: 'Wuhan',
      province: 'Hubei',
      country: 'China',
      weather: {
        obsTime: "12-21 09:05",
        temp: "13",
        feelsLike: "10",
        icon: "101",
        text: "Cloudy",
        humidity: "72",
        vis: "16"
      }
    },

    onReady() {
      let key = '<your key>';
      // location, using Wuhan's code here
      // For more location codes, refer to: https://github.com/qwd/LocationList
      fetch.fetch({
        url: `https://devapi.qweather.com/v7/weather/now?location=101200101&key=${key}`
      }).then(res => {
        const result = res.data;
        console.log('Returned data:', JSON.stringify(result.data, null, 2));
        this.weather = result.data.now;
      }).catch(error => {
        console.log(`Data request failed:`, error);
      })
    },

    toListPage(eve) {
      console.log(eve);
      if (eve.direction === 'up') {
        router.push({
          uri: '/pages/list'
        })
      }
    }
  }
</script>
Page running result:

Page running result

The data request for the 3-day weather forecast interface is the same as the real-time weather page, so it will not be repeated here.

In real projects, you need to handle more page details, such as adding a loading state when the page requests data, formatting dates accordingly, etc.

To provide a good user experience, please strictly follow the design draft to write the page structure and styles, and handle various exceptions appropriately.



Build Parameters
The build tool offers various build capabilities that developers can configure based on project requirements. Please note that build parameters are only available in the build, server, and release commands.

How to Set Build Parameters
There are typically two ways to set build parameters, taking the extraction of a separate source-map file as an example:

Include build parameters in the command line
aiot build --devtool=source-map
Create a configuration file named quickapp.config.js in the project root directory and configure the cli property;
module.exports = {
  cli: {
    devtool: "source-map",
  },
};
View All Supported Build Parameters
 npx aiot build -h
Common Build Parameters
Parameter Name	Value Type	Description	Default
--devtool	string	The output format of the sourcemap. For parameter values and their meanings, refer to webpack/devtool(opens new window)
Example: aiot server --devtool=source-map	none
--enable-jsc	boolean	Whether to convert js files to jsc files to improve runtime performance
Example: aiot server --enable-jsc	false
--enable-protobuf	boolean	Whether to enable protobuf binary packaging to improve runtime performance
Example: aiot server --enable-protobuf	false
--enable-custom-component	boolean	Whether to support custom components
Example: aiot server --enable-custom-component	false


Basic Features
Project Structure
App Resources
An app contains: a manifest file describing project configuration information, an app.ux file for placing public resource scripts of the project, multiple ux files describing pages. A typical example is as follows:

App root directory:

├── manifest.json
├── app.ux
├── pages
│   ├── index
|   |   └── index.ux
│   └── detail
|       └── detail.ux
├── i18n
|   ├── defaults.json
|   ├── zh-CN.json
|   └── en-US.json
└── common
    ├── style.css
    ├── utils.js
    └── logo.png

ux Template
A page usually consists of three parts: page structure, style, and logical interaction. These three parts can be placed in one ux file or as separate files.

If placed in one ux file, the ux file needs to contain three tags: template, style, and script.

Example:

<template>
  <div class="page">
    <text class="title">Welcome to open {{title}}</text>
    <input class="btn" type="button" value="Jump to detail page" onclick="routeDetail">
  </div>
</template>

<style>
  .btn {
    width: 400px;
    height: 60px;
    background-color: #09ba07;
    color: #ffffff;
  }
</style>

<script>
  import router from '@system.router'

  export default {
    // Page data object
    private: {
      title: 'Example Page'
    },
    // Callback after button click
    routeDetail() {
      router.push({
        uri: '/pages/detail'
      })
    }
  }
</script>

If the page structure, style, and logical interaction are separated into independent files, the following directory structure can be used:

├── ...
├── pages
│   ├── ...
│   └── detail
|       ├── detail.ux
|       ├── detail.css
|       └── detail.js
├── ...

Note

If separated into independent files, after splitting the ux/css/js files, the ux file cannot contain the template tag.

File Storage
Files are stored by partition in the app platform. The following partitions are currently supported:

Cache, generally used for storing cached files, such as files downloaded through the fetch interface, which may be deleted by the system due to insufficient storage space;
Files, generally used for storing relatively small permanent files, which are managed by the app itself;
Mass, generally used for storing relatively large files, but this partition does not guarantee continuous availability;
Temp, represents temporary files mapped from external sources. For security reasons, temporary files are read-only and can only be accessed by calling specific APIs, such as the file.readText method. Additionally, access to temporary files is temporary, and they cannot be accessed after the app restarts. They need to be re-acquired using specific APIs.
Additionally, app resources are also treated as a special read-only partition.

URI
URIs are used to identify app resources and files. Components and interfaces access app resources and files through URIs.

Resource Type	URI	Read-only	Example	Description
App Resources	/path	Yes	/Common/header.png	-
Cache	internal://cache/path	No	internal://cache/fetch-123456.png	-
Files	internal://files/path	No	internal://files/image/demo.png	-
Mass	internal://mass/path	No	internal://mass/video/demo.mp4	-
Temp	internal://tmp/path	Yes	internal://tmp/xxxxx	Dynamically generated by the system
The allowed characters in a URI are 0-9a-zA-Z_-./%: (excluding quotes). The URI cannot contain .. and supports directory structures, with directories separated by slashes '/'.

An internal URI represents private app files. When specifying an internal URI, there is no need to specify the app identifier. The same internal URI will point to different files for different apps.

Resource and File Access Rules
App resource paths are divided into absolute paths and relative paths. A path starting with "/" indicates an absolute path, such as /Common/a.png. A path not starting with "/" is a relative path, such as a.png and ../Common/a.png.

App resource files are divided into code files and resource files. Code files refer to files containing code, such as .js/.css/.ux files, while other files are resource files, which are generally used only as data, such as images and videos.

In code files, when importing other code files, use relative paths, such as: ../Common/component.ux;
In code files, when referencing resource files (e.g., images, videos), generally use relative paths, such as: ./abc.png;
When a code file needs to be imported, if the importing file and the imported file are in the same directory, the imported file can use relative paths when referencing resource files. However, if they are not in the same directory, absolute paths must be used because the imported file will be copied to the importing file during compilation, and the directory will change after compilation. For example, if the a.css file is imported by b.ux, and a.css and b.ux are in the same directory, a.css can use a relative path when referencing resource files: abc.png. If they are not in the same directory, an absolute path must be used: /Common/abc.png. Similarly, when the a.ux file is imported by the b.ux file, if a.ux and b.ux are in the same directory, a.ux can use a relative path when referencing resource files: a.png. If they are not in the same directory, a.ux must use an absolute path when referencing resources: /Common/abc.png;
In CSS, consistent with front-end development, resource files are accessed using the url(PATH) method, such as: url(/Common/abc.png).


Project Configuration
The manifest.json file contains application descriptions, interface declarations, and page routing information.

manifest
Property	Type	Default Value	Required	Description
package	String	-	Yes	Application package name. Ensure it is different from the native application's package name. It is recommended to use the format com.company.module, e.g., com.example.demo.
name	String	-	Yes	Application name. Within 6 Chinese characters and consistent with the name saved in the app store. Used to display the application name on desktop icons, pop-ups, etc.
icon	String	-	Yes	Application icon. A 192x192 size is sufficient.
versionName	String	-	No	Application version name, e.g., "1.0".
versionCode	Integer	-	Yes	Application version number, incremented from 1. It is recommended to increment versionCode by 1 each time the package is re-uploaded.
minAPILevel	Integer	1	No	Minimum supported API standard version number. Compatibility check to avoid running on low-version platforms and causing incompatibility. If not filled, it will be treated as a beta version.
features	Array	-	No	Interface list. Most interfaces need to be declared here; otherwise, they cannot be called. See the documentation for each interface for details.
config	Object	-	Yes	System configuration information. See the description below.
router	Object	-	Yes	Routing information. See the description below.
display	Object	-	No	UI display-related configuration. See the description below.
deviceTypeList	Array<String>	watch	No	Optional values: watch, tv, car, phone. Currently, only watch is supported.
permissions	Array	-	No	Permission requests. Example: [{"name": "hapjs.permission.LOCATION"}]
config
Used to define system configurations and global data.

Property	Type	Default Value	Description
logLevel	String	log	Log printing level, divided into off, error, warn, info, log, debug.
designWidth	Integer	-	Page design reference width. Scales element sizes based on the actual device width.
background	Object	-	Background running configuration information. Use the features field to request interfaces that need to be used in the background (while still declaring them in the top-level features field). Requestable interfaces include:
system.audio
system.geolocation
system.request, etc.
See Background Running for detailed usage.
minAPILevel
The minimum supported API standard version number, indicating that the developer's rpk package can be compatible and run on devices that implement at least this version of the API standard. The default value is 1. When using features added in API standard version 1 or higher, ensure that minAPILevel is at least this version number to avoid errors when running on devices that implement lower API standard versions.

Example:

{
  "minAPILevel": 1
}
router
Used to define the composition of pages and related configuration information. If a page does not have routing information configured, it will be skipped during compilation and packaging.

Property	Type	Default Value	Required	Description
entry	String	-	Yes	Homepage name. When using the sub-package feature, it is recommended to define the homepage in the base package.
pages	Object	-	Yes	Page configuration list. The key value is the page name (corresponding to the page directory name, e.g., Hello corresponds to the 'Hello' directory), and the value is the detailed page configuration page. See the description below.
Example code:

"router": {
  "entry": "Demo",
  "pages": {
    "Demo": {
      "component": "index"
    }
  }
}
router.pages
Used to define routing information for a single page.

Property	Type	Default Value	Required	Description
component	String	-	Yes	The component name corresponding to the page, consistent with the ux file name, e.g., "hello" corresponds to "hello.ux".
path	String	/<page-name>	No	Page path, e.g., "/user". If not filled, it defaults to /<page-name>.
The path must be unique and cannot be the same as another page's path.
The path of the following page will be set to "/Index" due to its absence:
"Index": {"component": "index"}
launchMode	String	standard	No	Declares the page's launch mode. Supports two page launch modes: "singleTask" and "standard".
When set to "singleTask" mode, each time the target page is opened, the existing target page will be opened, and the onRefresh lifecycle function will be called, clearing other pages opened on this page. If this page has not been opened before, a new target page instance will be created.
When set to "standard" mode, a new target page will be opened each time (multiple identical pages will exist when the target page address is opened multiple times).
Example Code
{
  "package": "com.company.unit",
  "name": "appName",
  "icon": "/Common/icon.png",
  "versionName": "1.0",
  "versionCode": 1,
  "minPlatformVersion": 1000,
  "features": [{"name": "system.network"}],
  "router": {
    "entry": "Hello",
    "pages": {
      "Hello": {
        "component": "hello",
        "path": "/"
      }
    }
  }
}
display
Used to define UI display-related configurations.

If the following property values are defined under the display object, their scope of effect will be all pages of this JS application.

Property	Type	Default Value	Description
backgroundColor	String	#ffffff	Window background color.
Permission Descriptions
Permission Name	feature	api	Description	Permission Error Codes
hapjs.permission.LOCATION	system.geolocation	getLocation
subscribe
unsubscribe	Geolocation	400: Permission denied
402: Permission error (permission not declared)
hapjs.permission.DEVICE_INFO	system.device	getSerial
getDeviceId	Get device information	400: Permission denied
402: Permission error (permission not declared)

UX File
The APP and its pages are all written in files with the .ux suffix. These files consist of three parts: template, style, and script. A typical example of a page with the .ux suffix is shown below:

<template>
  <!-- Only one root node is allowed in the template -->
  <div class="page">
    <text class="title">Welcome to {{title}}</text>
    <!-- Click to navigate to the details page -->
    <input class="btn" type="button" value="Navigate to Details Page" onclick="routeDetail">
  </div>
</template>

<style>
  .page {
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }

  .title {
    font-size: 30px;
    text-align: center;
  }

  .btn {
    width: 400px;
    height: 60px;
    margin-top: 75px;
    border-radius: 43px;
    background-color: #09ba07;
    font-size: 30px;
    color: #ffffff;
  }
</style>

<script>
  import router from '@system.router'

  export default {
    // The data model for page-level components, affecting the override mechanism of incoming data: attributes defined within private are not allowed to be overridden
    private: {
      title: 'Example Page'
    },
    routeDetail () {
      // Navigate to a page within the app. For more details on router usage, refer to: Documentation -> API -> Page Routing
      router.push ({
        uri: '/DemoDetail'
      })
    }
  }
</script>
app.ux
After compilation, the current app.ux will include manifest configuration information (you can check the file content after running npm run build). Therefore, please do not delete the comment /**manifest**/.

You can import some common scripts in the <script> section and expose them on the current app object, as shown below. Then, you can access them in the ViewModel of the page .ux file via this.$app.$def.util.

<script>
  /**
   * Application-level configuration, shared by all pages
   */
  import util from './util'

  export default {
    showMenu: util.showMenu,
    createShortcut: util.createShortcut,
    util
  }
</script>


Template
A tag language similar to HTML that combines basic components and events to build the structure of a page.

Note

There can only be one root node in the template, such as div. Please do not have multiple root nodes under <template>, and do not use block as the root node.

Data Binding
<template>
  <text>{{message}}</text>
</template>

<script>
  export default {
    // The data model of the page-level component affects the override mechanism of the incoming data: properties defined within `private` are not allowed to be overridden.
    private: {
      message: 'Hello'
    }
  }
</script>
Event Binding
<template>
  <div>
    <!-- Normal format -->
    <text onclick="press"></text>
    <!-- Shorthand -->
    <text @click="press"></text>
  </div>
</template>

<script>
  export default {
    press(e) {
      this.title = 'Hello'
    }
  }
</script>
Supported syntax for event callbacks (where {{}} can be omitted):

fn: fn is the name of the event callback function (with corresponding function implementation in <script>);

fn(a,b): Function parameters such as a, b can be constants or data variables defined in <script> (no need to write this before them);

When the callback function is called, an evt parameter will be automatically added at the end of the parameter list. You can access the context data related to the callback event through the evt parameter (refer to the component callback event description for specific data content), such as the click position x, y of a click event.

List Rendering
<template>
  <div>
    <div for="{{list}}" tid="uniqueId">
      <text>{{$idx}}</text>
      <text>{{$item.uniqueId}}</text>
    </div>
  </div>
</template>

<script>
  export default {
    // The data model of the page-level component affects the override mechanism of the incoming data: properties defined within `private` are not allowed to be overridden.
    private: {
      list: [
        { uniqueId: 1 },
        { uniqueId: 2 }
      ]
    }
  }
</script>
The for directive renders a list based on the source data array. The supported syntax is as follows (where {{}} can be omitted):

for="{{list}}" list is the source data array, and the default array element name is $item;
for="{{value in list}}" value is a custom array element name, and the default array element index name is $idx;
for="{{(index, value) in list}}" index is a custom array element index name, and value is a custom array element name.
The tid attribute of the for directive is used to specify the unique ID of the array element. If not specified, the array index ($idx) is used as the unique ID by default. The purpose of the tid attribute is to reuse element nodes and optimize the redraw efficiency of the for loop.

In the example code, tid="uniqueId" means that the array element $item.uniqueId of the array list is used as the unique ID of the array element, and it must be ensured that the value of the uniqueId property is different for each array element.

When using the tid attribute, pay attention to the following:

The data attribute specified by the tid attribute must exist, otherwise it may cause runtime exceptions;
The data attribute specified by the tid attribute must be unique, otherwise it may cause performance issues;
The tid attribute currently does not support expressions.
Conditional Rendering
There are two types: if/elif/else and show. The difference is that when if is false, the component will be removed from the VDOM, while show is just invisible during rendering, and the component still exists in the VDOM;

if/elif/else nodes must be adjacent sibling nodes, otherwise they cannot pass compilation.

<template>
  <div>
    <text if="{{display}}">Hello-1</text>
    <text elif="{{display}}">Hello-2</text>
    <text else>Hello-3</text>
  </div>
</template>

<script>
  export default {
    // The data model of the page-level component affects the override mechanism of the incoming data: properties defined within `private` are not allowed to be overridden.
    private: {
      display: false
    }
  }
</script>
show is equivalent to visible=none, mainly used for declaration on native components;

<template>
  <text show="{{visible}}">Hello</text>
</template>

<script>
  export default {
    // The data model of the page-level component affects the override mechanism of the incoming data: properties defined within `private` are not allowed to be overridden.
    private: {
      visible: false
    }
  }
</script>
Logical Control Block
You can use <block> to achieve more flexible loop/conditional rendering. Note that <block> currently only supports the for and if/elif/else attributes. If no attributes are specified, <block> will be treated as a transparent node during construction, and its child nodes will be added to the parent node of <block>.

<template>
  <list>
    <block for="cities">
      <list-item type="city">
        <text>{{$item.name}}</text>
      </list-item>
      <list-item type="spot" for="$item.spots">
        <text>{{$item.address}}</text>
      </list-item>
    </block>
  </list>
</template>

<script>
  export default {
    // The data model of the page-level component affects the override mechanism of the incoming data: properties defined within `private` are not allowed to be overridden.
    private: {
      cities: [
        {
          name: 'beijing',
          spots: [
            { address: 'XXX' }
          ]
        },
        {
          name: 'shanghai',
          spots: [
            { address: 'XXX' },
            { address: 'XXX' }
          ]
        }
      ]
    }
  }
</script>


Props
Prop Writing
Prop attribute names are written in camelCase. When passing data externally, convert them to kebab-case. For example, propObject is converted to prop-object.

<!-- Child Component -->
<template>
  <div class="child-demo">
    <text>{{ propObject.name }}</text>
  </div>
</template>
<script>
  export default {
    props: ['propObject']
  }
</script>

<!-- Parent Component -->
<import name="comp" src="./comp"></import>
<template>
  <div class="parent-demo">
    <comp prop-object="{{obj}}"></comp>
  </div>
</template>
<script>
  export default {
    private: {
      obj: {
        name: 'child-demo'
      }
    }
  }
</script>

Attribute Default Values
When declaring props in a child component, you can set default values. If no data is passed when calling the child component, the default value will be automatically set.

To set default values, the props attribute must be written in Object form, not Array form.

Example:

<script>
  // Child Component
  export default {
    props: {
      prop1: {
        default: 'Hello' // Default value
      },
      prop2Object: {} // No default value
    },
    onInit() {
      console.info(`Data passed from parent:`, this.prop1, this.prop2Object)
    }
  }
</script>

Data Unidirectionality
Data transfer between parent and child components is unidirectional. When the parent component's prop data updates, the child component's data refreshes to the latest value. However, if the child component's prop value changes, it does not affect the parent component's value.

However, if the prop type is an array or object, changes in the child component will affect the parent component's value. This means you should not modify the prop value inside a child component, as it is a dangerous operation.

Three Common Methods for Handling Prop Values:
1. Using the prop value as an initial value and receiving it with data
<script>
  export default {
    props: ['say', 'propObject'],
    data: {
      count: null,
      obj: null
    },
    onInit() {
      console.info(`Data passed from parent:`, this.say, this.propObject)

      this.count = this.propObject.count // Assign a simple type from prop to data
      this.obj = JSON.parse(JSON.stringify(this.propObject)) // Deep clone the prop
    }
  }
</script>

2. Using $watch to monitor data changes
If monitoring a property in an object, use a dot-separated parameter, e.g., $watch(xxx.xxx.xxx, methodName). For details, see $watch.

<script>
  export default {
    props: ['propObject'],
    data: {
      propSay: ''
    },
    onInit() {
      // Monitor data changes
      this.$watch('propObject.name', 'watchPropsChange')
    },
    /**
     * Monitor data changes, process the data, and set the value to data
     * @param newV
     * @param oldV
     */
    watchPropsChange(newV, oldV) {
      console.info(`Data change monitored:`, newV, oldV)
      this.propSay = newV && newV.toUpperCase()
    }
  }
</script>

3. Using computed properties
For details, see Computed Properties.

<script>
  export default {
    props: [
      'say'
    ],
    computed: {
      sayText() {
        return this.say.toUpperCase()
      }
    }
  }
</script>

Attribute Validation
When declaring props in a child component, you can specify data type validation.

The supported types for type checking include [String, Number, Boolean, Function, Object, Array].

To validate types, the props attribute must be written in Object form, not Array form.

Example:

<script>
  // Child Component
  export default {
    props: {
      prop1: {
        default: 'Hello' // Default value
        type: String // Type validation
      },
      prop2Object: {} // No default value
    },
    onInit() {
      console.info(`Data passed from parent:`, this.prop1, this.prop2Object)
    }
  }
</script>


Event Binding
Format
<text onclick="press"></text>
can be abbreviated as:

<text @click="press"></text>
fn: fn is the name of the event callback function (with corresponding function implementation in <script>). In the above example, press is the event callback function.

Passing Parameters
Constants
<template>
  <div class="page">
    <text for="{{list}}" onclick="handle($idx,$item)">{{$item}}</text>
  </div>
</template>

<script>
  export default {
    private: {
      list:[1,2,3,4,5]
    },
    handle(idx,item,$evt) { // Clicking the first element
      console.log(idx) // 0
      console.log(item) // 1
      console.log($evt) // { pageX: 4, pageY: 246, clientX: 4, clientY: 246, offsetX: 4, offsetY: 246 }
    }
  }
</script>
Variables
Data variables defined in <script> for the page (no need to write this before them).

<template>
  <div class="page">
    <text for="{{list}}" onclick="handle(total,$item)"> {{$item}}</text>
  </div>
</template>

<script>
  export default {
    private: {
      list:[1,2,3,4,5],
      total:0
    },
    handle(total,num,$evt){
      console.log(total)
      console.log(num)
      console.log($evt)
    }
  }
</script>
WARNING

When the callback function is called, an evt parameter will be automatically added at the end of the parameter list. You can access the context data related to the callback event through the evt parameter.



Loop Directives
List Rendering
To implement list rendering, we use the for directive. The for directive is used to loop through and output an array of data.

TIP

The for directive renders a list based on the source data array. The supported syntax is as follows (where {{}} can be omitted):

for="{{list}}" list is the source data array, and the default array element name is $item;
for="{{value in list}}" value is a custom array element name, and the default array element index name is $idx;
for="{{(index, value) in list}}" index is a custom array element index name, and value is a custom array element name.
TIP

The tid attribute of the for directive is used to specify the unique ID of array elements. If not specified, the array index ($idx) is used as the unique ID by default. The purpose of the tid attribute is to enable element node reuse and optimize the redraw efficiency of the for loop.

Example:

<template>
  <div class="page">
    <!-- Method 1: Default $item represents the array element, $idx represents the array index -->
    <div class="row" for="{{list}}" tid="uniqueId">
      <text>{{$idx}}.{{$item.name}}</text>
    </div>
    <!-- Method 2: Custom element variable name -->
    <div class="row" for="value in list" tid="uniqueId">
      <text>{{$idx}}.{{value.name}}</text>
    </div>
    <!-- Method 3: Custom element and index variable names -->
    <div class="row" for="(personIndex, personItem) in list" tid="uniqueId">
      <text>{{personIndex}}.{{personItem.name}}</text>
    </div>
  </div>
</template>

<style>
  .page {
    flex-direction: column;
  }

  .row {
    width: 85%;
    margin-top: 10px;
    margin-bottom: 10px;
  }
</style>

<script>
  export default {
    private: {
      list: [
        { name: 'aa', uniqueId: 1 },
        { name: 'bb', uniqueId: 2 },
        { name: 'cc', uniqueId: 3 }
      ]
    },
    onInit() {
      console.info('Directive for')
    }
  }
</script>
In the example code, the structure of div.row will be generated multiple times based on the definition of the list data in the script when rendering the page.

tid="uniqueId" refers to a property name of the array element, which does not necessarily have to be called uniqueId. It is similar to React's key={item.uniqueId} or Vue's :key="item.uniqueId", used to optimize rendering speed.

When data is modified, DOM elements whose data has not changed will not be re-rendered; only DOM elements whose data has changed will be re-rendered. Therefore, we must ensure that the uniqueId property value is unique for each array element.

Note

The for directive can only loop through arrays, not objects.

The behavior of the for directive inside a block tag is different from its behavior in other tags. The block tag does not insert additional DOM nodes during rendering but instead loops through its internal DOM structure. Other tags will loop and generate themselves.

When the for directive and the if directive coexist on the same tag, the if directive takes precedence over the for directive. To help newcomers who haven't read the documentation quickly get started with the project, it is not recommended to have these two directives coexist on the same tag.

When custom variables represent the array index and array element of the for directive, the variable names cannot start with $ or _.

When using the tid attribute, note the following:

The data property specified by the tid attribute must exist; otherwise, it may cause runtime exceptions.
The data property specified by the tid attribute must be unique; otherwise, it may cause performance issues.
The tid attribute currently does not support expressions.


Conditional Directives
if Directive
The if conditional directive refers to the three related directives: if/elif/else, which are used to control whether components are added or removed.

The if/elif/else nodes must be adjacent sibling nodes.

<template>
  <div>
    <text if="{{display}}">Hello-1</text>
    <text elif="{{display}}">Hello-2</text>
    <text else>Hello-3</text>
  </div>
</template>

<script>
  export default {
    // The data model for page-level components, affecting the override mechanism of incoming data: properties defined in private are not allowed to be overridden
    private: {
      display: false
    }
  }
</script>
show Directive
The show directive refers to whether a component is displayed, controlling the visibility state of the component without removing it from the DOM structure.

show is equivalent to visible=none, mainly used for declaration on native components.

<template>
  <text show="{{visible}}">Hello</text>
</template>

<script>
  export default {
    // The data model for page-level components, affecting the override mechanism of incoming data: properties defined in private are not allowed to be overridden
    private: {
      visible: false
    }
  }
</script>
Differences Between if and show
When the value of the if/elif directive is false, the node is removed from the page. When the value is true, the component is dynamically inserted into the DOM structure.

When the value of the show directive is true, the node is visible. When the value is false, the component is invisible, but the node remains in the page's DOM structure.


Computed Properties
Basic Usage of Computed Properties
We often use expressions in templates, and using expressions properly can improve our development efficiency. However, putting too much logic in the template makes it heavy and difficult to maintain. For example:

<text> {{ message.split('').reverse().join('') }} </text>
In this case, the template is no longer simple declarative logic. If we use such expressions in many places, it might reduce the readability of the template, and reusing the same expression logic redundantly makes the code hard to maintain. To address this, we can use computed properties:

<template>
    <div>
      <text>Original message: "{{ message }}"</text>
      <text>Computed reversed message: "{{ reversedMessage }}"</text>
    </div>
</template>
<script>
    export default {
      data: {
        message: 'Hello'
      },
      computed: {
        // Getter function for the computed property
        reversedMessage() {
          // `this` points to the vm instance
          return this.message.split('').reverse().join('')
        }
      },
      onReady() {
        console.log(this.reversedMessage) // olleH
    
        this.message = 'Goodbye'
    
        console.log(this.reversedMessage) // eybdooG
      }
    }
</script>
Here, we declared a computed property reversedMessage. The function we provided will be used as the getter function for the property vm.reversedMessage, and the value of vm.reversedMessage always depends on the value of vm.message.

You can bind computed properties in the template just like binding regular properties. The component instance knows that vm.reversedMessage depends on vm.message, so when vm.message changes, all bindings that depend on vm.reversedMessage will also update.

Setting the setter Function for Computed Properties
Computed properties have only a getter by default, but you can also provide a setter when needed:

<script>
    export default {
      data: {
        firstName: 'Quick',
        lastName: 'App'
      },
      computed: {
        fullName: {
          get() {
            return `${this.firstName} ${this.lastName}`
          },
          set(value) {
            const names = value.split(' ')
            this.firstName = names[0]
            this.lastName = names[names.length - 1]
          }
        }
      },
      onReady() {
        console.log(this.fullName) // Quick App
        this.fullName = 'John Doe'
        console.log(this.firstName) // John
        console.log(this.lastName) // Doe
      }
    }
</script>


Components
Custom Components
When developing pages, developers must use Native components such as text and div, which are rendered by the Native layer of each platform. If a developer writes all UI parts in a single file's <template> for a complex page, the code's maintainability will be low, and modules may become unnecessarily coupled.

To better organize logic and code, a page can be split into multiple modules based on functionality, with each module responsible for one part of the functionality. The page then manages these modules, passing business and configuration data to achieve code separation. This is the significance of custom components.

A custom component is a component written by a developer that is used similarly to Native components and is rendered according to the component's <template>. At the same time, development is similar to that of a page, with a ViewModel managing data, events, and methods.

TIP

Since custom components have an independent ViewModel, there is a certain memory overhead. It is not recommended to use them on lightweight devices like watches and bracelets.

Example:

<template>
  <div class="tutorial-page">
    <text class="tutorial-title">Custom Component:</text>
    <text>{{ say }}</text>
    <text>{{ obj.name }}</text>
  </div>
</template>

<style lang="less">
  .tutorial-page {
    flex-direction: column;
    padding-top: 20px;

    .tutorial-title {
      font-weight: bold;
    }
  }
</style>

<script>
  // Child component
  export default {
    data: {
      say: 'hello',
      obj: {
        name: 'quickApp'
      }
    },
    onInit() {
      console.log('I am a child component')
    }
  }
</script>
In custom components, the data model can only use the data property, and the data type is Object.

Custom Component Lifecycle:
onInit: Indicates that the component's ViewModel data is ready and can start using the page's data.
onReady: Indicates that the component's ViewModel template has been compiled and DOM nodes can be accessed.
onDestroy: Called when the component is destroyed. Resources should be released, such as timers.
Importing Components
In Vela, components are imported using the <import> tag, as shown in the following code:

<import name="XXX" src="XXX"></import>
The src attribute in the <import> tag specifies the address of the custom component, and the name attribute specifies the tag name used to reference the component in the parent component.

Example:

<import name="comp-part1" src="./part1"></import>

<template>
  <div class="tutorial-page">
    <text class="tutorial-title">Import Component:</text>
    <comp-part1></comp-part1>
  </div>
</template>

<style lang="less">
  .tutorial-page {
    flex-direction: column;
    padding: 20px 10px;
  }
  .tutorial-title {
      font-weight: bold;
  }
</style>

<script>
  // Parent component
  export default {
    private: {},
    onInit() {
      console.log('Import component')
    }
  }
</script>
Parent-Child Component Communication
Parent Component Passes Data to Child Component via Props
The parent component passes data to the child component by declaring exposed property names in the child component's props attribute and then declaring the data to be passed on the component's reference tag. For details, see the Props section.

Example:

<!-- Child component -->
<template>
  <div class="child-demo">
    <text class="title">Child Component:</text>
    <text>{{ say }}</text>
    <text>{{ propObject.name }}</text>
  </div>
</template>
<script>
  export default {
    props: ['say', 'propObject'],
    onInit() {
      console.info(`External data:`, this.say, this.propObject)
    }
  }
</script>
<!-- Parent component -->
<import name="comp" src="./comp"></import>
<template>
  <div class="parent-demo">
    <comp say="{{say}}" prop-object="{{obj}}"></comp>
  </div>
</template>
<script>
  export default {
    private: {
      say: 'hello',
      obj: {
        name: 'child-demo'
      }
    }
  }
</script>
Child Component Communicates with Parent Component
The child component triggers a custom event bound to the node using $emit() to execute the parent component's method, as in the relationship between the parent component and Component 1.
The child component triggers a custom event using $dispatch(), and the parent component monitors the trigger using $on(), as in the relationship between the parent component and Component 2.
Example:

<!-- Parent component -->
<import name="comp1" src="./comp1.ux"></import>
<import name="comp2" src="./comp2.ux"></import>
<import name="comp3" src="./comp3.ux"></import>
<template>
  <div class="parent-demo">
    <text>I am the parent component count: {{count}}</text>
    <comp1 count="{{count}}" onemit-evt="emitEvt"></comp1>

    <text>I am the parent component num: {{num}}</text>
    <comp2 num="{{num}}"></comp2>

    <text>I am the parent component age: {{age}}</text>
    <input type="button" onclick="evtTypeEmit" value="Trigger $broadcast()"></input>
    <comp3></comp3>
  </div>
</template>

<script>
  export default {
    private: {
      count: 20,
      num: 20,
      age: 18
    },
    onInit() {
      this.$on('dispatchEvt', this.dispatchEvt)
    },
    emitEvt(evt) {
      this.count = evt.detail.count
    },
    dispatchEvt(evt) {
      this.num = evt.detail.num
    },
    evtTypeEmit() {
      this.$broadcast('broadevt', {
        age: 19
      })
    },
  }
</script>
<!-- comp1 -->
<template>
  <div class="child-demo">
    <text>I am child component one count: {{compCount}}</text>
    <input type="button" onclick='addHandler' value='add'></input>
  </div>
</template>
<script>
  export default {
    props: ['count'],
    data() {
      return {
        compCount: this.count
      }
    },
    addHandler() {
      this.compCount++
      this.$emit('emitEvt', {
        count: this.compCount
      })
    },
  }
</script>
<!-- comp2 -->
<template>
  <div class="child-demo">
    <text>I am child component two num: {{compNum}}</text>
    <input type="button" onclick='delHandler' value='del'></input>
  </div>
</template>
<script>
  export default {
    props: ['num'],
    data() {
      return {
        compNum: this.num
      }
    },
    delHandler() {
      this.compNum--
      this.$dispatch('dispatchEvt', {
        num: this.compNum
      })
    },
  }
</script>
<!-- comp3 -->
<template>
  <div class="child-demo">
    <text>I am child component three age: {{compAge}}</text>
  </div>
</template>
<script>
  export default {
    props: [],
    data() {
      return {
        compAge: null
      }
    },
    onInit() {
      this.$on('broadevt', this.broadevt)
    },
    broadevt(evt) {
      this.compAge = evt.detail.age
    }
  }
</script>
The framework provides developers with bidirectional event passing:

Downward passing: Triggered by the parent component and responded to by the child component. Use parentVm.$broadcast() for downward passing, such as broadevt.
Upward passing: Triggered by the child component and responded to by the parent component. Use childVm.$dispatch() for upward passing, such as dispatchEvt.
Tips:

When passing parameters during triggering, use evt.detail to retrieve the parameters.
After passing is complete, you can call evt.stop() to end the passing; otherwise, it will continue indefinitely.

Style
The style is used to describe the component style of the template and determine how the component should be displayed.

The style layout adopts the CSS Flexbox style, which expands and modifies CSS for some native components.

To solve the screen adaptation problem, all size-related styles (such as width and font-size) are based on the reference width (default 480px) and scaled according to the actual screen width. For example, width:100px is actually 200px on a 960px width screen.

File Import
Two ways to import external files are supported:

<!-- Import external file to replace internal style -->
<style src="./style.css"></style>

<!-- Merge external file -->
<style>
  @import './style.css';
  .a {
  }
</style>

Internal Template Style
The style and class attributes are supported to control the component style:

<!-- Inline style -->
<div style="color:red; margin: 10px;"/>
<!-- Class declaration -->
<div class="normal append"/>

Selectors
Supported selectors include:

Selector	Example	Description
.class	.intro	Select all components with class="intro"
#id	#firstname	Select the component with id="firstname"
tag	div	Select all div components
,	.a, .b	Select all components with class="a" and class="b"
<style>
  /* Single selector */
  text {
  }
  .class-abc {
  }
  #idAbc {
  }
  /* Multiple selectors with the same style */
  .font-text, .font-comma {
  }
</style>

Selector Priority
The priority calculation of the current style selector is consistent with the browser, which is a subset of browser CSS rendering (only supports: inline, id, class, tag).

Multiple CSS declarations can match the same element, such as div. The overall priority of CSS declarations applied to this element is: inline > #id > .class > tag. These four categories match multiple CSS declarations of the element, such as: <div id="sample" style="width: 200px;" class="class-div"></div>. The priority is compared based on the sum of the weight values of each selector. The priority weight values of selectors are as follows:

ID selector (e.g., #hello) has a weight value of 10000

Class selector (e.g., .example) has a weight value of 100

Type selector (e.g., h1) has a weight value of 1

The CSS priority calculation document can also be viewed in the MDN documentation (opens new window)for beginners.

Style Precompilation
Currently, JS applications support precompilation of less and sass. For specific tutorials, please refer to here.

<!-- Import external file to replace internal style -->
<style lang="less" src="./lessFile.less"></style>

<!-- Merge external file -->
<style lang="less">
  @import './lessFile.less';
  .less-font-text, .less-font-comma {
    font-size: 60px;
  }
</style>



Page Styling and Layout
Box Model
The JS application layout framework uses the border-box model. For specific performance and width/height/margin calculations, refer to the MDN documentation on box-sizing (opens new window). The content-box model and manual specification of the box-sizing property are not currently supported.



Width occupied by the layout:

Width = width (including padding-left + padding-right + border-left + border-right)

Height occupied by the layout:

Height = height (including padding-top + padding-bottom + border-top + border-bottom)

Length Units
The framework supports the following length units: px, %, dp.

px
Unlike traditional web pages, px is a unit relative to the project configuration base width. It has been adapted for mobile screens, similar in principle to rem.

Developers only need to determine the px value in the framework style based on the design draft.

First, define the project configuration base width, which is the value of config.designWidth in the project configuration file (<ProjectName>/src/manifest.json). The default value is 480 if not specified.

Then, the conversion formula between design draft 1px and framework style 1px is as follows:

Design draft 1px / Design draft base width = Framework style 1px / Project configuration base width

Example:

If the design draft width is 640px and element A has a width of 100px in the design draft, there are two implementation schemes:

Scheme 1:

Modify the project configuration base width: Set the project configuration base width to the design draft base width, then framework style 1px equals design draft 1px.

Set the project configuration base width in the project configuration file (<ProjectName>/src/manifest.json) by modifying config.designWidth:
{
  "config": {
    "designWidth": 640
  }
}

Set the framework style for element A:
width: 100px;

Scheme 2:

Do not modify the project configuration base width: If the current project's project configuration base width is 480, let the framework style of element A be xpx. From the conversion formula: 100 / 640 = x / 480.

Set the framework style for element A:
width: 75px;

Percentage %
The percentage calculation rules in JS applications are similar to CSS. Refer to the MDN documentation (opens new window).

dp3+
The dp unit stands for device independent pixels.

Calculation formula: dp value = physical resolution / device pixel ratio

Example: A device with a resolution of 480*480 and a device pixel ratio of 2 has a screen width of 480 pixels = 240dp.

Example code:

<style>
  .dp-box{
    width:360dp;
    height:360dp;
    background-color:green;
    margin-bottom:40px;
  }
</style>

Setting Positioning
The position property supports two values: relative and absolute, with relative as the default value. Refer to the MDN documentation (opens new window).

Setting Styles
Developers can use inline styles, tag selectors, class selectors, and id selectors to style components.

You can also use parallel selectors to set styles. Descendant selectors are not currently supported.

Detailed documentation can be found here.

Example:

<template>
  <div class="page">
    <text style="color: #FF0000;">Inline style</text>
    <text id="title">ID selector</text>
    <text class="title">Class selector</text>
    <text>Tag selector</text>
  </div>
</template>

<style>
  .page {
    flex-direction: column;
  }
  /* Tag selector */
  text {
    color: #0000FF;
  }
  /* Class selector (recommended) */
  .title {
    color: #00FF00;
  }
  /* ID selector */
  #title {
    color: #00A000;
  }
  /* Parallel selector */
  .title, #title {
    font-weight: bold;
  }
</style>

Common Styles
For common styles such as margin and padding, refer to here.

Flex Layout Example
The framework uses Flex layout. For more information on Flex layout, refer to the external documentation A Complete Guide to Flexbox (opens new window).

Support for Flex layout can also be found in the Common Styles section of the official documentation.

The div component is the most commonly used Flex container component with Flex layout characteristics. The text and span components are text container components. Other components cannot directly contain text content.

Example:

<template>
  <div class="page">
    <div class="item">
      <text>item1</text>
    </div>
    <div class="item">
      <text>item2</text>
    </div>
  </div>
</template>

<style>
  .page {
    /* Cross-axis centering */
    align-items: center;
    /* Vertical arrangement */
    flex-direction: column;
  }
  .item {
    /* Allow stretching when there is remaining space */
    /*flex-grow: 1;*/
    /* Do not allow compression when space is insufficient */
    flex-shrink: 0;
    /* Main axis centering */
    justify-content: center;
    width: 200px;
    height: 100px;
    margin: 10px;
    background-color: #FF0000;
  }
</style>

Dynamic Style Modification
There are multiple ways to dynamically modify styles, consistent with traditional front-end development habits, including but not limited to the following:

Modify class: Update the value of the variable used in the component's class attribute.
Modify inline style: Update a CSS value in the component's style attribute.
Modify bound object: Control the element's style through a bound object.
Example:

<template>
  <div style="flex-direction: column;">
    <!-- Modify class -->
    <text class="normal-text {{ className }}" onclick="changeClassName">Click to change text color</text>
    <!-- Modify inline style -->
    <text style="color: {{ textColor }}" onclick="changeInlineStyle">Click to change text color</text>
    <!-- Modify bound object -->
    <text style="{{ styleObj }}" onclick="changeStyleObj">Click to change text color</text>
  </div>
</template>

<style>
  .normal-text {
    font-weight: bold;
  }
  .text-blue {
    color: #0faeff;
  }
  .text-red {
    color: #f76160;
  }
</style>

<script>
  export default {
    private: {
      className: 'text-blue',
      textColor: '#0faeff',
      styleObj: {
        color: 'red'
      }
    },
    onInit () {
      console.info('Dynamic style modification')
    },
    changeClassName () {
      this.className = 'text-red'
    },
    changeInlineStyle () {
      this.textColor = '#f76160'
    },
    changeStyleObj () {
      this.styleObj = {
        color: 'yellow'
      }
    }
  }
</script>

Introducing Less/SCSS Precompilation
Less Section
For an introduction to less syntax, refer to the less Chinese official website (opens new window).

To use less, first install the corresponding libraries: less, less-loader:

npm i less less-loader

Refer to the documentation Style Syntax --> Style Precompilation. Then add the attribute lang="less" to the <style> tag.

Example:

<template>
  <div class="page">
    <text id="title">Less example!</text>
  </div>
</template>
<style lang="less">
  /* Import external less file */
  @import './style.less';
  /* Use less */
</style>

SCSS Section
For an introduction to scss syntax, refer to the scss Chinese official website (opens new window).

To use scss, execute the following command under the JS application project to install the corresponding libraries: node-sass, sass-loader:

npm i node-sass sass-loader

Refer to the documentation Style Syntax --> Style Precompilation. Then add the attribute lang="scss" to the <style> tag.

Example:

<template>
  <div class="page">
    <text id="title">Less example!</text>
  </div>
</template>

<style lang="scss">
  /* Import external scss file */
  @import './style.scss';
  /* Use scss */
</style>

Using PostCSS to Parse CSS
JS applications support using PostCSS to parse CSS. PostCSS can parse CSS using syntax similar to Less and Sass, supporting features such as variables, nesting, and defining functions.

Using PostCSS to parse CSS involves three steps:

Install the corresponding loader:
npm i postcss-loader precss@3.1.2 -D

Create a postcss.config.js file in the project root directory and add the following content:
module.exports = {
  plugins: [require('precss')]
}

Here, precss is a PostCSS plugin.

Add lang="postcss" to the corresponding style tag on the page, as follows:
<style lang="postcss">
  /* Use PostCSS */
  .page {
    justify-content: center;
    background-color: #00beaf;
  }
  
  #title {
    color: #FF0000;
  }
</style>

Now you can write the corresponding code in CSS.

Note

If you want to support more syntax formats, you can add more plugins in the postcss.config.js file. For PostCSS plugins, refer to the plugin address .



Media Queries 2+
With media queries, developers can adjust the styles of JS applications based on the values or presence of various device characteristics and parameters.

Media queries are part of responsive design. Similar to CSS, you can use the @media at-rule to conditionally apply part of a stylesheet based on the results of media queries; you can also use @import to conditionally apply an entire stylesheet.

Minimum aiot-toolkit version: 1.1.3

Syntax
Each media query statement consists of an optional media type and any number of media feature expressions. Multiple media query statements can be combined using various logical operators, and media query statements are case-insensitive.

There are two ways to perform media queries:

Introducing media queries using the @media method
@media [media type] [and|not|only] [(media feature)] {
  CSS-Code;
}

Examples
@media (max-width: 30) { ... } // Level 3 syntax.
@media (width <= 30) { ... } // Level 4 syntax, clearer and more concise than Level 3.
@media screen and (min-width: 400) and (max-width: 700) { ... } // Multi-condition syntax.
@media (400 <= width <= 700) { ... } // Multi-condition Level 4 syntax.
Introducing media queries using the @import method 3+
@import './css_file_name.css' [media type] [and|not|only] [(media feature) ];

Media Types
Media types describe the category of the device. Except when using the not or only logical operators, where the media type must be included, the media type is optional. The currently supported media types for JS applications are as follows:

Media Type	Description
screen	Primarily used for screens.
Media Features
Media feature expressions are entirely optional and are responsible for testing whether these features or characteristics are present and what their values are.

Each media feature expression must be enclosed in parentheses.

The currently supported media features for JS applications are as follows:

Type	Description	Units Required for Query	Supported Units
height3+	Defines the height of the visible area of the page on the output device	No	dp
min-height3+	Defines the minimum height of the visible area of the page on the output device	No	dp
max-height3+	Defines the maximum height of the visible area of the page on the output device	No	dp
width3+	Defines the width of the visible area of the page on the output device	No	dp
min-width3+	Defines the minimum width of the visible area of the page on the output device	No	dp
max-width3+	Defines the maximum width of the visible area of the page on the output device	No	dp
aspect-ratio3+	Defines the aspect ratio of the visible area of the page on the output device. The ratio value should be in the format of x/y, e.g., 1/2	No	None
min-aspect-ratio3+	Defines the minimum aspect ratio of the visible area of the page on the output device. The parameter requirements are the same as above	No	None
max-aspect-ratio3+	Defines the maximum aspect ratio of the visible area of the page on the output device. The parameter requirements are the same as above	No	None
device-type3+	The optional values for device-type are: watch, band, smartspeaker. The default value is watch	No	None
shape2+	Screen shape. Optional values: circle, rect, pill-shaped3+	No	None
Notes
In the media feature list, media features marked as "no units required for query," such as width and height, should not include length units in queries, and the length unit can only be dp.
dp value = physical resolution / device pixel ratio (DPR)

Example: A device with a resolution of 480*480 and a DPR of 2 has a screen width of 480 pixels = 240dp.

Reference data for various devices

Device Type	Device Model	Screen Shape	Screen Size	Resolution	PPI	DPR	Horizontal DP Value
Watch	Xiaomi Watch S1 Pro	Circle	1.47 inches	480x480	326	2.0	240
Watch	Xiaomi Watch H1	Circle	1.43 inches	466x466	326	2.0	233
Watch	Xiaomi Watch S3	Circle	1.43 inches	466x466	326	2.0	233
Band	Xiaomi Band 8 Pro	Rectangle	1.74 inches	336x480	336	2.1	168
Band	Xiaomi Band 9	Pill-shaped	1.62 inches	192x490	325	2.0	96
Example code:

// The following media query will take effect on Xiaomi Band 9, which has a resolution of 192*490 and a horizontal DP value of 96
@media (min-width: 80) and (max-width: 160) {
  .box {
    background-color: green;
  }
}

// The following media query will take effect on Xiaomi Band 8 Pro, which has a resolution of 336*480 and a horizontal DP value of 168
@media (min-width: 160) and (max-width: 200) {
  .box {
    background-color: yellow;
  }
}

// The following media query will take effect on Xiaomi Watch S3, which has a resolution of 466*466 and a horizontal DP value of 233
@media (min-width: 200) and (max-width: 300) {
  .box {
    background-color: red;
  }
}

Logical Operators 3+
Developers can use logical operators to combine multiple media feature query conditions and write complex media queries.

Type	Description
and	The and operator is used to combine multiple media features into a single media query. The query is true if each linked feature returns true.
not	The not operator is used to negate a media query. If the query does not return false, it returns true. If it appears in a comma-separated list, it only negates the specific query to which it applies. If the not operator is used, an explicit media type must be specified. For example: not screen and (min-width: 400) and (max-width: 700). Note: The not keyword cannot be used to negate a single feature expression; it acts on the entire media query.
only	The only operator is used to apply styles only when the entire query matches. Watch applications will ignore the only keyword when processing keywords starting with only. If the only operator is used, a media type must be specified. For example: only screen and (min-width: 400) and (max-width: 700).
, (comma)	The comma-separated effect is equivalent to the or logical operator. When using comma-separated media queries, if any of the media queries return true, the styles are valid. For example: (width >= 192), (height >= 490).
or	The or operator is used to combine multiple media feature comparison statements into a single media query statement. The query is true if any of the media feature comparison statements return true. For example: (min-width: 400) or (max-width: 700).
<=	Less than or equal to. For example: (400 <= width).
>=	Greater than or equal to. For example: (500 >= height).
<	Less than. For example: (400 < width).
>	Greater than. For example: (500 > height).
Example Code
Query for devices with a circular or pill-shaped screen

  .box {
    width: 100px;
    height: 100px;
    background-color: black;
  }

  @media (shape: circle) or (shape: pill-shaped) {
    .box {
      background-color: green;
    }
  }

Query for devices that are watches and have a circular screen

  .box {
    width: 100px;
    height: 100px;
    background-color: black;
  }

  @media (device-type: watch) and (shape: circle) {
    .box {
      background-color: green;
    }
  }

Support Details
Device Product	Description
Xiaomi S1 Pro Sports Health Watch	Not supported
Xiaomi Band 8 Pro	Not supported
Xiaomi Band 9 / 9 Pro	Supports 2+ features
Xiaomi Watch S3	Supports 2+ features
Redmi Watch 4	Not supported
Xiaomi Wrist ECG Blood Pressure Monitor	Not supported
Xiaomi Band 10	Supported
Xiaomi Watch S4	Supported
REDMI Watch 5	Supported


script
Logical code used in the ux file to define the behavior of a page, including data objects, lifecycle interfaces, custom methods, and general methods.

Syntax
Supports ES5 / ES6 syntax

Module Declaration
You can import functional modules using import and call module methods in your code (refer to the interface documentation for details):

import fetch from '@system.fetch'

Code Reference
It is recommended to use import to import JS code, for example:

import utils from '../common/utils.js'

Note

The JS application environment is not a Node.js environment, so do not import native Node.js modules such as import fs from 'fs'.

Page Data Object
You can define page-level data objects in the page file for binding in the template and manipulation in page methods. For example:

<template>
  <div>
    <text>{{a}}</text>
  </div>
</template>

<script>
  export default {
    // Page data object, affects the override mechanism of incoming data: properties defined in private cannot be overridden
    private: {
      a: 1
    }
  }
</script>

For more detailed information, refer to Page Data Object.

Lifecycle Interfaces
Both applications and pages have a predefined series of lifecycles. You can declare lifecycle hook functions in the script, which will be called when the application/page reaches a specific lifecycle stage. For example:

// This function will be executed when the application/page is initialized
onInit() {
  console.log('page initialized！')
}

For more detailed information, refer to Lifecycle.

Custom Methods
Developers can declare custom methods as needed in the application/page ux file, including utility methods, event callback methods, etc. For example:

onBtnClick(){
  console.log('button clicked!')
}

Global Objects and Methods
Properties and methods declared by developers in the application ux file (app.ux) can be accessed in any page via this.$app.$def. For more details, refer to Global Objects and Methods.

General Methods
The framework provides some predefined general methods that can be called by pages/components. For more details, refer to General Methods.



Global Attributes and Methods
Objects
Common Objects
Attribute	Type	Description
$app	Object	Application object
$page	Object	Page object
$valid	Boolean	Whether the page object is valid
Application Object
In a page, the global application object can be accessed via $app.

In the app.ux file, developers can define globally accessible data and methods, which can be accessed in the page via this.$app.$def, and directly via this in the app.ux file. For example, define the following in the app.ux file:

<script>
/**
 * Application-level configuration for all pages
 */
export default {
  data: {
    a: 1
  },
  func: function() {
    console.log(this.data.a)
    console.log(`function executed!`)
  }
}
</script>

In other pages, you can call them like this:

this.$app.$def.data
this.$app.$def.func()

The following built-in methods can be accessed via $app:

Attribute	Type	Description
exit	Function	Exit the JS application and end the application lifecycle. Usage: this.$app.exit()
Page Object
In a page, the current page object can be accessed via this.$page. The following attributes can be accessed on this object:

Attribute	Type	Description
name	String	Get the name of the current page route, consistent with the corresponding property name in router.pages in the manifest file
path	String	Get the path of the current page route, consistent with the corresponding path in router.pages in the manifest file
component	String	Get the component of the current page route, consistent with the corresponding component in router.pages in the manifest file
Methods
this.$canIUse3+
In a page, you can use this.$canIUse to query available capabilities, including interfaces and components.

Parameters:
Type	Description
String	The capability to query, see the format below
Return Value:
Type	Description
Boolean	Whether the queried capability is supported
Parameter Format
Querying Interfaces
// Query if a method under a feature is supported
`@${featureName}.${method}`
// Query if a feature is supported
`@${featureName}`

Example

if (this.$canIUse('@system.router.push')) {
  // Can use the method @system.router.push
}
if (this.$canIUse('@system.router')) {
  // Can use the @system.router interface
}

Querying Components
The type can be 'attr', 'style', or 'method', corresponding to the component's attributes, styles, and methods respectively.

// Query if an attribute, style, or method under a component is supported
`${componentName}.${type}.${name}`
// Query if a component is supported
`${componentName}`

Example

if (this.$canIUse('scroll')) {
  // Can use the scroll component
}
if (this.$canIUse('scroll.attr.scroll-x')) {
  // Can use the scroll-x attribute of the scroll component
}

this.$watch
Monitor data changes. Dynamically add properties/event bindings. The property must be defined in data, and the handler function must be defined in <script>. The event is triggered when the property value changes.
If monitoring a property in an object, use dots to separate parameters, e.g., $watch(xxx.xxx.xxx, methodName).

Parameters
Attribute	Type	Description
data	String	Property name, supports 'a.b.c' format, does not support array indices
handler	String	Event handler function name. The first parameter is the new property value, the second is the old property value
Code Example
<script>
  export default {
    props: ['propObject'],
    data {
      say: '',
      propSay: ''
    },
    onInit() {
      // Monitor data changes
      this.$watch('say', 'watchDataChange')
      this.$watch('propObject.name', 'watchPropsChange')
    },
    /**
     * Monitor data changes, you can process the data and set values to data
     * @param newV
     * @param oldV
     */
    watchPropsChange(newV, oldV) {
      console.info(`Monitoring data changes:`, newV, oldV)
      this.propSay = newV && newV.toUpperCase()
    },
    watchDataChange(newV, oldV) {
      console.info(`Monitoring data changes:`, newV, oldV)
    }
  }
</script>

this.$element
Get the DOM object of a component with the specified ID. If no ID is specified, return the root component DOM object.

Parameters
Type	Description
String	this.$element('idName') to get the DOM node
Code Example
<template>
  <div>
    <div id='xxx'></div>
  </div>
</template>

<script>
  export default {
    onReady() {
      const el = this.$element('xxx')
      console.log(`Output xxx node information: ${el}`)
    }
  }
</script>

this.$element('xxx') gets the div component instance object with ID xxx, and this.$element() gets the root component instance object in the template.

The id property assignment can be viewed in this document.

this.$nextTick
Execute a delayed callback after the next DOM update cycle. Using this method immediately after modifying data allows you to get the updated DOM.

Parameters
Type	Description
Function	The callback function that performs operations on the DOM
Code Example
<template>
  <div class="page">
    <text @click="onAddClick">Add Item</text>
    <div class="list" id="list">
      <div class="item" for="{{list}}">
        <text>{{ $item }}</text>
      </div>
    </div>
  </div>
</template>

<script>
  export default {
    private: {
      list: ["Item 1", "Item 2"]
    },
    onAddClick() {
      this.list.push(Math.random())
      // After updating data, the DOM does not change immediately.
      this.$element("list").getBoundingClientRect({
        success: (rect) => {
          console.log("getBoundingClientRect.height=", rect.height)
        }
      })
      this.$nextTick(() => {
        // After updating data, the DOM changes.
        this.$element("list").getBoundingClientRect({
          success: (rect) => {
            console.log("$nextTick getBoundingClientRect.height=", rect.height)
          }
        })
      })
    }
  }
</script>
<style>
  .page {
    padding-top: 20px;
    width: 100%;
    height: 100%;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
  }

  .list {
    width: 200px;
    flex-direction: column;
    align-items: center;
    border: 2px solid red;
  }
</style>

In addition to the above common methods, there are event methods such as this.$on, this.$off, this.$dispatch, this.$broadcast, and this.$emit for parent-child component communication. The method descriptions are as follows:

Method	Parameters	Description
this.$on	type: String Event name
handler: Function Event handler function	Add an event handler. Usage: this.$on('xxxx', this.fn), where fn is a function defined in <script>
this.$off	type: String Event name
handler: Function Event handler function	Remove an event handler. Usage: this.$off('xxxx', this.fn) or this.$off('xxx') to remove all handlers for the specified event
this.$dispatch	type: String Event name	Send an event notification to the parent component. Usage: this.$dispatch('xxx'). Normally, the event will bubble up. To stop bubbling, call evt.stop() in the event handler function
this.$broadcast	type: String Event name	Send an event notification to child components. Usage: this.$broadcast('xxx'). Normally, the event will propagate down. To stop propagation, call evt.stop() in the event handler function
this.$emit	type: String Event name
data: Object Event parameters	Trigger an event, and the corresponding handler function will be called. Usage: this.$emit('xxx') or this.$emit('xxx', {a:1}). The passed event parameters can be accessed in the event callback function via evt.detail, e.g., evt.detail.a
For examples of using event methods, refer to the documentation.


Page Data Object
Property	Type	Description
data	Object	Component-level data model. Property names must not start with $ or _. Do not use reserved words such as for, if, show, tid.
public	Object	Page-level component data model. It affects the override mechanism of incoming data: Properties defined within public can be overridden by incoming data. If an external incoming data property is not declared in public, it will not be added.
protected	Object	Page-level component data model. It affects the override mechanism of incoming data: Properties defined within protected can be overridden by data passed from internal page requests within the application, but not by data passed from external requests.
private	Object	Page-level component data model. It affects the override mechanism of incoming data: Properties defined within private cannot be overridden.
computed	Object	Computed properties. Property names must not start with $ or _. Do not use reserved words such as for, if, show, tid.
Helpful Tip

Note that public, protected, and private cannot be used simultaneously with data.




Lifecycle
Page lifecycle: onInit, onReady, onShow, onHide, onDestroy, onBackPress, onRefresh, onConfigurationChanged
Page states: displayed, hidden, destroyed
APP lifecycle: onCreate, onShow, onHide, onDestroy, onError
Lifecycle Diagram
Lifecycle Diagram

Page Lifecycle
Since pages are rendered via ViewModel, the page lifecycle refers to the lifecycle of the ViewModel, including common events: onInit, onReady, and onShow, which are triggered during page creation.

onInit()
Indicates that the ViewModel's data is ready and can be used in the page.

Example:

private: {
  // Text list for lifecycle
  lcList: []
},
onInit () {
  this.lcList.push('onInit')

  console.info(`Triggered: onInit`)
  // Execute: Get the lcList property of ViewModel: onInit
  console.info(`Execute: Get the lcList property of ViewModel: ${this.lcList}`)
  // $app info
  console.info(`Get: Data from manifest.json's config.data: ${this.$app.$data.name}`)
  console.info(`Get: Data from APP file: ${this.$app.$def.data1.name}`)
  console.info(`Execute: Method from APP file`, this.$app.$def.method1())
}
onReady()
Indicates that the ViewModel's template has been compiled and DOM nodes can now be accessed (e.g., this.$element(idxxx)).

Example:

onReady () {
  this.lcList.push('onReady')
  console.info(`Triggered: onReady`)
}
onShow(), onHide()
Multiple pages can run simultaneously in the APP, but only one page can be displayed at a time. This differs from pure front-end development, where opening a new page in the browser destroys the previous one. However, it is similar to SPA development, where the browser's global context is shared when switching pages.

Page switching generates new events: onHide() is called when a page is hidden, and onShow() is called when a page is redisplayed.

Example:

onShow () {
  this.lcList.push('onShow')
  console.info(`Triggered: onShow`)
},
onHide () {
  this.lcList.push('onHide')
  console.info(`Triggered: onHide`)
}
onDestroy()
Called when a page is destroyed. Possible reasons for destruction include: the user returns to the previous page, or the user opens too many pages, and the framework automatically destroys some pages to free up resources.

Therefore, resource cleanup operations should be performed when a page is destroyed, such as canceling interface subscription listeners (geolocation.unsubscribe()).

To check if a page is in a destroyed state, use the $valid property of the ViewModel: true indicates existence, false indicates destruction.

Example:

onDestroy () {
  console.info(`Triggered: onDestroy`)
  console.info(`Execute: Page is about to be destroyed. Destruction state: ${this.$valid}. Should cancel interface subscription listener: geolocation.unsubscribe()`) // true, about to be destroyed
  setTimeout(function () {
    // Page has been destroyed, will not execute
    console.info(`Execute: Page has been destroyed, will not execute`)
  }.bind(this), 0)
}
Note:

Asynchronous operations like setTimeout are bound to the current page, so they will not execute after the page is destroyed.
onBackPress()
Triggered when the user swipes right to return or clicks the physical back button.

If the event handler returns true at the end, it indicates that the system should not return and the developer should handle the business logic (and then manually call the API to return). Otherwise, if no data is returned or other data is returned, the system follows its default logic: return to the previous page.

Example:

onBackPress () {
  console.info(`Triggered: onBackPress`)
  // true: indicates custom handling; otherwise, defaults to returning to the previous page
  // return true
}
onRefresh(query)
Listens for page reopening.

When the page's launchMode in the manifest is set to 'singleTask', only one instance of the target page will exist. This function is triggered when the user opens the target page multiple times.
Triggered when the target page is opened with the 'clearTask' flag in the push parameters and the page instance already exists. The parameter in this callback is the data carried when reopening the page. See Page Launch Modes for details.
Example:

onRefresh(query) {
  // When launchMode is singleTask, parameters carried when reopening the page are not automatically updated to the page's this object.
  // Need to manually retrieve and update them from query here.
  console.log('Page refreshed!!!')
}
onConfigurationChanged(event)
Listens for changes in application configuration. Triggered when the application configuration changes, such as a change in system language.

Parameters

Parameter	Type	Description
event	Object	Event indicating a change in application configuration
event Parameters

Parameter	Type	Description
type	String	Reason type for the application configuration change. Supported type values are as follows:
Supported type values in event

Parameter	Description
locale	Application configuration changed due to language or region changes
Example:

onConfigurationChanged(evt) {
  console.log(`Triggered lifecycle onConfigurationChanged. Configuration type: ${evt.type}`)
}
APP Lifecycle
Five callback functions are provided for the APP lifecycle: onCreate(), onShow(), onHide(), onDestroy(), and onError(e).

Example:

export default {
  // Listen for application creation. Called when the application is created.
  onCreate() { 
    console.info('Application onCreate')
  },
  // Listen for application returning to the foreground. Called when the application returns to the foreground.
  onShow() { 
    console.info('Application onShow')
  },
  // Listen for application moving to the background. Called when the application moves to the background.
  onHide() { 
    console.info('Application onHide')
  },
  // Listen for application destruction. Called when the application is destroyed.
  onDestroy() { 
    console.info('Application onDestroy')
  },
  // Listen for application errors. Called when the application catches an exception. The parameter is an Error object.
  onError(e) {
    console.log('Application onError', e)
  },
  // Exposed to all pages. Accessed in pages via: this.$app.$def.method1()
  method1() {
    console.info('This is an APP method')
  },
  // Exposed to all pages. Accessed in pages via: this.$app.$def.data1
  data1: {
    name: 'This is data stored by the APP'
  }
}




Page Switching
Switching Pages and Passing Parameters via the Router Interface
Switching Pages
Before using the router interface, you need to import the module first.

You can switch pages using router.push(OBJECT). For details about the uri parameter format supported by this method, refer to Page Routing.

Example:

<template>
  <div class="page">
    <input class="btn" type="button" value="Jump to New Page" onclick="routePage"></input>
  </div>
</template>

<style>
  .page {
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
  .btn {
    width: 400px;
    height: 60px;
    margin-top: 70px;
    border-radius: 30px;
    background-color: #09ba07;
    font-size: 30px;
    color: #ffffff;
  }
</style>

<script>
  // Import module
  import router from '@system.router'

  export default {
    routePage () {
      // Jump to a page within the app; cannot return to the current page
      router.replace({
        uri: '/Pages/newPage'
      })
    }
  }
</script>

Passing Parameters
The params parameter of the router interface can be used to configure parameters to be passed during page jumps.

Example:

<template>
  <div class="page">
    <input class="btn" type="button" value="Jump with Parameters" onclick="routePageReplaceWithParams"></input>
  </div>
</template>

<style>
  .page {
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
  .btn {
    width: 400px;
    height: 60px;
    margin-top: 70px;
    border-radius: 30px;
    background-color: #09ba07;
    font-size: 30px;
    color: #ffffff;
  }
</style>

<script>
  // Import module
  import router from '@system.router'

  export default {
    private: {
      title: 'Hello, world!'
    },

    onInit () {
      console.info('Switch pages and pass parameters via the router interface')
    },

    routePageReplaceWithParams () {
      // Jump to a page within the app
      router.replace({
        uri: '/PageParams/receiveparams',
        params: { key: this.title }
      })
    }
  }
</script>

Receiving Parameters
Now that you know how to pass parameters between pages using the router interface, how do you receive them?

It's actually very simple: the method for receiving parameters passed by the router interface is consistent: declare the properties to be used in the protected attribute of the page's ViewModel.

Note

Properties defined in protected can be overwritten by data passed from internal page requests within the app but not by data passed from external requests.
If you want parameters to be overwriteable by data passed from external requests, declare the properties in the public attribute of the page's ViewModel.
Example:

<template>
  <div class="page">
    <text>page</text>
    <!-- Display parameters passed to the page in the template -->
    <text>{{key}}</text>
  </div>
</template>

<style>
  .page {
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
</style>

<script>
  export default {
    protected: {
      key: ''
    },
    onInit () {
      // Output parameters passed to the page in JavaScript
      console.info('key: ' + this.key)
    }
  }
</script>


Advanced Features
Framework Expansion Capabilities
Other expansion capabilities of the framework.

Multilingual Coverage
Background Running
HAP Link
Page Launch Modes
Multi-screen Adaptation


Multilingual Support
Vela's capabilities cover multiple countries and regions. After the framework supports multilingual capabilities, a single JS application product (a single RPK file) can simultaneously support switching between multiple language versions. Developers do not need to develop multiple source code projects in different languages, avoiding difficulties in project maintenance.

Using the system's default language, the method for developers to configure multilingual support is very simple, requiring only two steps: defining resources and referencing resources.

Defining Resource Files
Resource files are used to store business information definitions in multiple languages. Similar to other technology platforms (which use properties files or xml files), the JS application platform uses JSON files to save resource definitions.

Define an i18n folder under the project's src directory and place resource definition files for each language region inside it.

Resource File Naming, Lookup Rules, and Recommendations
File names can use the language and country information obtained from the current system, for example, file names can be defined as: zh-CN.json, zh.json.

If the developer's current product only plans to support one language but still wants to utilize multilingual capabilities, simply declare a file named defaults.json.

The matching priority for JSON file names stops at the first match found; otherwise, it continues to the next level.

Priority Matching Rules are as follows:

<language code>-<country code>

<language code>

defaults

The first file in the default i18n configuration

Naming Recommendations:

For precise matching of language + region for multilingual configuration, it is recommended to use <language code>-<country code>.json to name resource files.

For configurations that do not require matching regions, it is recommended to use <language code>.json to name resource files.

defaults.json can be used alone as a default option or in combination with the above two methods.

It is not recommended to use the system's final fallback default first file solution, as it may result in unexpected display outcomes.

Warm Tip

Refer to Supported Language List for <language code>-<country code>.

Configuration Syntax Supported by Resource Files
Basic Text Configuration
{
  "message": {
    "hello": "hello world"
  }
}

Array Configuration
Matching will serialize the data content into text output. This type of configuration does not support mixing with interpolation syntax.

{
  "message": {
    "array": ["a", 2, {"c": 3}]
  }
}

Named Interpolation Configuration
Supports the use of {} placeholders for named interpolation. During invocation, substitute placeholder content is passed through named parameters.

{
  "message": {
    "hello": "{msg} world"
  }
}

List Interpolation Configuration
Supports the use of {} placeholders for list interpolation. By configuring list index values, substitute placeholder content is passed through an alternative list during invocation.

{
  "message": {
    "hello": "{0} world"
  }
}

Singular/Plural Syntax Configuration
Supports the use of | placeholders for singular/plural syntax configuration. Different options are separated by placeholders.

{
  "message": {
    "car": "car | cars",
  }
}

Referencing Resources in Pages
Multilingual configuration is primarily implemented through the $t and $tc functions on the ViewModel instance. These methods can be used in <template> or <script>.

Simple Formatting Method
this.$t(path, opts)

Parameter Descriptions:

Parameter	Type	Required	Description
path	String	Yes	The resource path to retrieve multilingual configuration, with object values connected by dots, e.g., "message.hello"
opts	Array | Object	No	Configuration items for interpolation replacement, can be passed as an object or array, used in conjunction with configuration interpolation
If an object is passed, specify the named key configured for parameter passing
If an array is passed, the value is the index of the list interpolation configuration in the passed list
Usage Examples:

Example of retrieving values corresponding to Basic Text Configuration:

<template>
  <div>
    <!-- Display result: hello world -->
    <text>{{ $t('message.hello') }}</text>
  </div>
</template>

<script>
  export default {
    onInit () {
      // Simple formatting:
      console.log(this.$t('message.hello')) // hello world
    }
  }
</script>

Example of retrieving values corresponding to Array Configuration:

<template>
  <div>
    <!-- Directly display array, result: ["a", 2, {"c": 3}] -->
    <text>{{ $t('message.array') }}</text>
  </div>
</template>

<script>
  export default {
    onInit () {
      // Simple formatting:
      console.log(this.$t('message.array')) // ["a", 2, {"c": 3}]
    }
  }
</script>

Example of retrieving values corresponding to Named Interpolation Configuration:

<template>
  <div>
    <!-- Display result: hello world -->
    <text>{{ $t('message.hello', { msg: 'hello' }) }}</text>
  </div>
</template>

<script>
  export default {
    onInit () {
      // Simple formatting:
      console.log(this.$t('message.hello', { msg: 'hello' }))  // hello world
    }
  }
</script>

Example of retrieving values corresponding to List Interpolation Configuration:

<template>
  <div>
    <!-- Display result: hello world -->
    <text>{{ $t('message.hello', ['hello', 'hi']) }}</text>
  </div>
</template>

<script>
  export default {
    onInit () {
      // Simple formatting:
      console.log(this.$t('message.hello', ['hello', 'hi'])) // hello world
    }
  }
</script>

Singular/Plural Formatting Method
this.$tc(path, choice, opts)

Parameter Descriptions:

Parameter	Type	Required	Description
path	String	Yes	The resource path to retrieve multilingual configuration, with object values connected by dots, e.g., "message.hello"
choice	Number	No	Used to determine which option's value to use. If no specific value is passed, the default is singular. Can also be used for interpolation display when the third parameter is not passed
Special Value Descriptions:
Value must be an integer, error parameters will not display and return an empty string
Singular/plural determination ignores positive/negative signs
Two-segment format treats 0 as even
opts	Array | Object	No	Configuration items for interpolation replacement, can be passed as an object or array, used in conjunction with configuration interpolation
If an object is passed, specify the named key configured for parameter passing
If an array is passed, the value is the index of the list interpolation configuration in the passed list
Description of choice Singular/Plural Configuration:

Currently, singular/plural configurations in resource files support two writing styles and support mixing with interpolation syntax.

Two-segment configuration: singular|plural;

Three-segment configuration: empty value|singular|plural.

Configuration Examples:

{
  "message": {
    "car": "car | cars", // Two-segment configuration
    "apple": "no apples | one apple | {count} apples" // Three-segment configuration
  }
}

Usage Examples:

<template>
  <div>
    <!-- Two-segment singular/plural -->
    <!-- Display result: cars -->
    <text>{{ $tc('message.car', 0) }}</text>
    <!-- Display result: car -->
    <text>{{ $tc('message.car', 1) }}</text>
    <!-- Display result: cars -->
    <text>{{ $tc('message.car', 2) }}</text>

    <!-- Three-segment singular/plural -->
    <!-- Display result: no apples -->
    <text>{{ $tc('message.apple', 0) }}</text>
    <!-- Display result: one apple -->
    <text>{{ $tc('message.apple', 1) }}</text>
    <!-- Display result: 2 apples -->
    <text>{{ $tc('message.apple', 2) }}</text>
    <!-- Three-segment singular/plural mixed with interpolation usage -->
    <!-- Display result: 6 apples -->
    <text>{{ $tc('message.apple', 2, {count: 6}) }}</text>
  </div>
</template>

<script>
  export default {
    onInit () {
      // Two-segment singular/plural:
      console.log(this.$tc('message.car', 0)) // cars
      console.log(this.$tc('message.car', 1)) // car
      console.log(this.$tc('message.car', 2)) // cars

      // Three-segment singular/plural:
      console.log(this.$tc('message.apple', 0)) // no apples
      console.log(this.$tc('message.apple', 1)) // one apple
      console.log(this.$tc('message.apple', 2)) // 2 apples
      console.log(this.$tc('message.apple', 2, {count: 6})) // 6 apples
    }
  }
</script>

Retrieving System Language
The above capabilities are used for formatting resource content. In certain scenarios, developers may need to retrieve the current system's locale language and make changes to complete different logical processing. For example:

Different locales correspond to different page layouts;

Developers provide users with the ability to set a specific language.

The framework's system.configuration provides related functionality, refer to the documentation: Application Configuration configuration.

Callback After Changing Locale Language
When a user switches the locale language in system settings, the onConfigurationChanged callback is triggered, and the returned event.type value is locale.

For details, refer to the documentation.

Example code:

// Listen for language changes
onConfigurationChanged(event) {
  if (event && event.type && event.type === 'locale') {
    console.log('locale or language changed!')
  }
}


Background Running
To save system resources, applications usually stop running after switching to the background and restart when switching back to the foreground. However, some applications such as music and sports applications may need to continue running in the background. To meet such requirements, background running is supported. The working principle of the background running mode is as follows:

When an application switches to the background, the system checks whether the conditions for background running are met. If so, the application continues to run; otherwise, it stops. The conditions include:

The background running interface is declared in manifest.json.
At least one background running interface (declared in manifest.json) is currently running.
Practical suggestions:

Background running consumes a lot of system resources, so applications should use it cautiously based on their own needs. Applications that apply for background running will be reviewed during the launch review to determine whether their background running needs are reasonable.
Import the background running interface and perform background execution in app.ux instead of in pages to avoid the impact of page switching and destruction.
Configuration Method
Declare the required background running interface in manifest.json. The background running interfaces include:

Audio playback: system.audio
Upload and download: system.request
Geolocation: system.geolocation
{
  "package": "com.hybrid.demo.sample",
  //  ......

  "config": {
    "logLevel": "trace",
    "background": {
      "features":[
        "system.audio",
        "system.request"
      ]
    }
  }
  //  ......
}


hap link
An hap link refers to a URI starting with hap:// supported in the router module. For usage scenarios, refer to Page Routing.

Currently, supported hap links start with hap://app/ and support opening specified JS applications. The format is as follows:

hap://app/<package>/[path][?key=value]

Parameter description:

package: The application package name (required)
path: The path to the page within the application (optional, defaults to the homepage)
key-value: Parameters to be passed to the page (optional, multiple parameters can be included)


Page Launch Mode
Used to define the launch behavior of a page.

Static Declaration
In the manifest file, the launch mode field launchMode can be added to the page route information router.page to declare the launch mode of the page.

Page Launch Mode Parameters:
Property	Type	Default Value	Required	Description
launchMode	String	standard	No	Declares the launch mode of the page. Supports two page launch modes: "singleTask" and "standard".
When identified as the "singleTask" mode, each time the target page is opened, the existing target page will be opened and the onRefresh lifecycle function will be called back. Other pages opened on this page will be cleared. If this page has not been opened before, a new target page instance will be created.
When identified as the "standard" mode, a new target page will be opened each time (multiple identical pages will exist when the target page address is opened multiple times).
Example:
"router": {
    "entry": "PageA",
    "pages": {
      "PageA": {
        "launchMode": "singleTask",
        "component": "index"
      },
      "PageB": {
        "launchMode": "standard",
        "component": "index"
      },
      "PageC": {
        "launchMode": "singleTask",
        "component": "index"
      }
    }
  }
Behavior logic for opening pages:

If the pages are launched in the order of PageA -> PageB -> PageC -> PageB -> PageC -> PageA:

Open PageA. When it is opened for the first time, the page stack is empty. The page stack is PageA.
Open PageB. The launch mode of PageB is standard. A new PageB page instance is created on top of PageA and displayed. The page stack is PageA, PageB.
Open PageC. When it is opened for the first time, a new PageC page instance is created on top of PageB and displayed. The page stack is PageA, PageB, PageC.
Open PageB. The launch mode of PageB is standard. A new PageB page instance is created on top of PageC and displayed. The page stack is PageA, PageB, PageC, PageB.
Open PageC. The PageC page instance already exists. The page instances on top of PageC (PageB) are destroyed. The previously opened PageC page instance is returned to, and the onRefresh function of the page lifecycle is called back. The page stack is PageA, PageB, PageC.
Open PageA. The PageA page instance already exists. The page instances on top of PageA (PageB and PageC) are destroyed. The previously opened PageA page instance is returned to, and the onRefresh function of the page lifecycle is called back. The page stack is PageA.
Dynamic Declaration
There are two ways to dynamically declare. One is to carry the launch flag parameter in router.push, and the other is to carry the launch flag parameter in the link to open the page. The launch flag parameter can control the page opening behavior.

Page Launch Mode Parameters:
Parameter	Type	Required	Description
___PARAM_LAUNCH_FLAG___	String	No	The page parameter passed when jumping to a JS application page. When carrying clearTask, opening the target page will clear other pages outside this page. When there are multiple target pages, only the earliest opened target page will be retained, and the onRefresh lifecycle will be called back. If the target page does not exist, all pages will be cleared, and a new target page instance will be created.
Example:
router.push({
  uri: '/PageB',
  params: {
    ___PARAM_LAUNCH_FLAG___: 'clearTask'
  }
})
Behavior logic for opening pages:

If the page stack that has already been opened is PageA -> PageB -> PageC, and PageB is launched with the clearTask flag at this time:

The PageC page instance is destroyed.
The PageA page instance is destroyed.
The PageB page instance already exists. Return to this page instance and call back the onRefresh function of the page lifecycle.
If the page stack that has already been opened is PageA -> PageC, and PageB is launched with the clearTask flag at this time:

The PageC page instance is destroyed.
The PageA page instance is destroyed.
The PageB page instance does not exist. Create and display a new PageB page instance.


Multi-screen Adaptation
Why is Multi-screen Adaptation Necessary?
Xiaomi offers a wide range of wearable devices (smart bands, smartwatches) with varying screen shapes, sizes, and resolutions. To ensure proper display of applications across different screens, multi-screen adaptation is required. Developers are advised to consider multi-screen adaptation as much as possible when developing applications to enhance their versatility. This ensures that applications can be distributed to as many wearable devices as possible, helping developers expand their user base quickly. The following table provides detailed screen information for devices equipped with Vela OS. Please refer to it.

Device Type	Device Model	Screen Shape	Screen Size	Resolution	PPI	Screen Width (DP)	Aspect Ratio
Smartwatch	Xiaomi Watch S1 Pro	Round	1.47 inches	480x480	326	240	1
Smartwatch	Xiaomi Watch H1	Round	1.43 inches	466x466	326	233	1
Smartwatch	Xiaomi Watch S3	Round	1.43 inches	466x466	326	233	1
Smartwatch	Xiaomi Watch S4 sport	Round	1.43 inches	466x466	326	233	1
Smartwatch	Xiaomi Watch S4	Round	1.43 inches	466x466	326	233	1
Smartwatch	REDMI Watch 5	Rectangle	2.07 inches	432x514	324	216	0.8
Smart Band	Xiaomi Smart Band 8 Pro	Rectangle	1.74 inches	336x480	336	168	0.7
Smart Band	Xiaomi Smart Band 9	Capsule-shaped-track-screen	1.62 inches	192x490	325	96	0.4
Smart Band	Xiaomi Smart Band 9 Pro	Rectangle	1.74 inches	336x480	325	160	0.7
How to Perform Multi-screen Adaptation?
Multi-screen adaptation requires applications to be designed for multiple screens. The design drafts should include adaptation plans for different screens. For specific design methods, please refer to Multi-screen Design.

The framework provides a series of technical specifications to help developers complete multi-screen adaptation of applications according to the design drafts. Please refer to Multi-screen Specifications.

Our IDE also offers a multi-screen UI simulator to help developers quickly preview the application's effects on different screens and make appropriate adjustments. Please refer to Multi-screen UI Simulator.

We provide some code examples for multi-screen adaptation of common page elements, as well as whole-site cases for reference. Code Examples.

Adaptation Specifications
Vela OS supports a range of technical capabilities for adapting to various screens.

Responsive Layout
The container components provided by the system all follow the Flex layout rules by default. Using Flex layout enables responsive screen layouts.

For example, the following code can achieve an even distribution of multiple inline items.

<div>
  <text style="flex-grow: 1; background-color:aqua;">1</text>
  <text style="flex-grow: 1; background-color:yellow;">2</text>
  <text style="flex-grow: 1; background-color:red;">3</text>
</div>


For more details, refer to Flex Layout Examples.

Responsive Units
When writing UI styles, you can use the system's responsive length units, including:

px
%
px
In Vela applications, px does not represent the physical pixels of the screen but is a unit relative to the project's configured base width, similar in principle to rem.

Developers configure the designWidth field in the manifest file to set the design base width (design draft width), and then use this length unit in style descriptions. The numerical values are directly taken from the pixel values in the design draft, and the system will automatically scale the Vela application UI proportionally on different screens.

{
  "config": {
    "designWidth": 336
  }
}
<template>
  <div class="demo-page">
    <div class="container"></div>
  </div>
</template>

<style>
.demo-page {
  justify-content: center;
  align-items: center;
}
.container {
  width: 168px;
  height: 168px;
  background-color: aquamarine;
}
</style>
In the example above, if designWidth is configured as 336px, all px values will be calculated based on this base width. Assuming the actual screen width is 336 pixels, the actual width of the container element will also be 168 pixels; if the actual screen width is 192 pixels, the actual width of the container element will be 96 pixels.

336480 screen / 192490 screen


For more details, refer to Length Units.

Percentage (%)
% represents a percentage. Many style properties can take percentage values, often used to determine size based on the parent object.

For example, the following code can achieve multiple inline items occupying the parent container's width by percentage.

<div>
  <text style="width: 20%; background-color:aqua;">1</text>
  <text style="width: 40%; background-color:yellow;">2</text>
  <text style="width: 40%; background-color:red;">3</text>
</div>


For more details, refer to CSS Percentage Units (opens new window).

Fixed Length Units 3+
In some layout scenarios, fixed length units are required, and the system's supported dp length unit can meet this need.

The DP length unit represents device-independent pixels, also known as density-independent pixels. It can be considered as a point in the computer coordinate system, representing a logical pixel that can be used by the program. It is a unit that approximates physical size, with the calculation formula as follows:

DP value of screen width = screen resolution width / DPR
DP value of element width/height = physical pixel count of element width/height / DPR
DPR represents the device pixel ratio, which is the ratio of the device's physical pixels to logical pixels (DP), with the calculation formula as follows:

DPR = device PPI / 160
PPI (pixels per inch) represents the number of pixels per inch, characterizing the physical density of the screen. Therefore, DPR is also known as logical density. The logical density value (DPR) of the device screen can be obtained through the device interface.

For example, the following code can achieve elements maintaining approximate physical sizes on screens of different sizes, thus displaying more elements on larger screens.

<template>
  <div class="container">
    <div class="text-box">
      <text style="background-color: aquamarine;">
        A
      </text>
      <text style="background-color: #ff0000;">
        B
      </text>
      <text style="background-color: #00ff00;">
        C
      </text>
      <text style="background-color: #0000ff;">
        D
      </text>
    </div>
  </div>
</template>

<style>
  .container {
    justify-content: center;
    align-items: center;
  }
  .text-box {
    justify-content: center;
    flex-wrap: wrap;
  }
  text {
    width:116dp;
    height: 30dp;
    font-size: 15dp;
    text-align: center;
  }
</style>
466466 screen / 192490 screen


Media Queries
Media queries, introduced in CSS3, are used to apply different styles to web pages based on different screen sizes and device types.

In Vela JS applications, similar media query specifications can be used to write styles for different screens and devices. For detailed information, refer to Media Queries.

For example, the following code can apply different styles based on the screen shape.

Note: The designWidth in the following example code is 466.

<template>
  <div class="container">
    <text>10:30</text>
    <text>My To-Do</text>
  </div>
</template>

<style>
  /* When the screen is circular */
  @media screen and (shape: circle) {
    .container {
      padding-left: 80px;
      padding-right: 80px;
      padding-top: 40px;
      flex-direction: row;
      align-items: flex-start;
      justify-content: space-between;
    }
    text {
      font-size: 40px;
    }
  }
  /* When the screen is pill-shaped */
  @media screen and (shape: pill-shaped) {
    .container {
      padding-top: 50px;
      flex-direction: column;
      align-items: center;
    }
    text {
      margin-top: 10px;
    }
  }
</style>
466466 screen / 192490 screen


Obtaining Screen Information
In Vela JS applications, screen information, including screen shape and resolution, can be obtained through the device feature interface. Based on the obtained results, corresponding style adaptations can be made.

For example, the following code can determine the type of the progress component (whether it is arc-shaped) based on the screen shape.

<template>
  <div class="container">
    <progress percent="80" type="{{progressType}}"></progress>
  </div>
</template>

<script>
  import device from '@system.device'

  export default {
    data: {
      progressType: "horizontal"
    },
    onInit() {
      const that = this
      device.getInfo({
        success: function(ret) {
          that.progressType = ret.screenShape === "circle" ? "arc" : "horizontal"
        }
      })
    }
  }
</script>

<style>
  .container {
    padding: 20px;
  }
</style>
Circular screen / Rectangular screen


For detailed information, refer to Device Information (device).



Code Examples
Page Layout and Element Adaptation
Some common cross-screen adaptation examples in development.

Adaptive Container Size
Using percentages or flex styles instead of fixed container sizes with px can provide better compatibility across multiple screens. For example, in scenarios with long scrolling lists, the example is as follows:

<template>
  <div class="demo-page">
    <text class="title">Long List</text>
    <list class="list">
      <list-item class="item" type="custom" for="{{listData}}">
        <text>{{$item.name}}</text>
      </list-item>
    </list>
  </div>
</template>

<script>
  export default {
    private: {
      listData: [
        {
          name: 'TEST1 TEST1 TEST1'
        }, {
          name: 'TEST2 TEST2 TEST2'
        }, {
          name: 'TEST3 TEST3 TEST3'
        }, {
          name: 'TEST4 TEST4 TEST4'
        }, {
          name: 'TEST5 TEST5 TEST5'
        }, {
          name: 'TEST6 TEST6 TEST6'
        }, {
          name: 'TEST7 TEST7 TEST7'
        }, {
          name: 'TEST8 TEST8 TEST8'
        }, {
          name: 'TEST9 TEST9 TEST9'
        }, {
          name: 'TEST10 TEST10 TEST10'
        }
      ]
    }
  }
</script>

<style>
.demo-page {
  flex-direction: column;
  align-items: center;
  background-color: #fff;
}

.title {
  margin-top: 50px;
  padding: 20px 0;
  font-size: 32px;
}
.list {
  flex: 1;
  width: 340px;
  margin-bottom: 5px;
  align-items: center;
}
.item {
  width: 100%;
  height: 100px;
  margin-bottom: 20px;
  border-radius: 20px;
  background-color: #ccc;
  text-align: center;
}

text {
  width: 100%;
  font-size: 30px;
  text-align: center;
  color: #000;
}
</style>
Effect display:

Circular screen / Rectangular screen / Capsule screen


Single-Page Three-Row Layout
In watch and bracelet scenarios, a three-row layout for a single page is a commonly used design approach. The page structure is generally divided into a top title bar, a bottom button interaction area, and a middle main content area. It is recommended to use a fixed height for the top and bottom, with the main part adapting its height.

Code example:

<template>
  <div class="demo-page">
    <div class="header">
      <text>header</text>
    </div>
    <div class="content">
      <text>content</text>
    </div>
    <div class="footer">
      <text>footer</text>
    </div>
  </div>
</template>

<script>
  export default {}
</script>

<style>
.demo-page {
  width: 466px;
  height: 466px;
  flex-direction: column;
}

.header {
  width: 100%;
  height: 100px;
  background-color: red;
}

.content {
  flex: 1;
  background-color: yellow;
}

.footer {
  width: 100%;
  height: 100px;
  background-color: blue;
}

text {
  width: 100%;
  font-size: 30px;
  color: black;
  text-align: center;
}

</style>
Effect display:

Circular screen / Rectangular screen / Capsule screen


Automatic px Scaling Calculation
The px length unit will be converted based on the configured project reference width, with decimal places rounded during the process. Therefore, in scenarios requiring precise calculations, the error value (usually ±1px) introduced by the conversion needs to be considered.

For example, in the following example, the error was not considered when calculating the row width, leading to rendering issues on certain devices:


Code example:

<template>
  <div class="demo-page">
    <div class="item" for="nums">
      <text>{{$item}}</text>
    </div>
  </div>
</template>

<script>
  export default {
    private: {
      nums: [1, 2, 3, 4]
    }
  }
</script>

<style>
.demo-page {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
}

.item {
  width: 110px;
  height: 110px;
  margin: 2px;
  background-color: #ccc;
}

text {
  color: #000;
  font-size: 30px;
}

</style>
Effect display:

Circular screen / Rectangular screen / Capsule screen


Full-Screen Background Image
Using a full-screen background image requires considering whether the image will display well on screens of different sizes. If there are interactive or strictly positioned elements in the background image, it is recommended to handle them as separate elements from the background image.

Effect display:

Circular screen / Rectangular screen / Capsule screen


Page Title Bar
The page title is usually located at the top of the page. On devices with different screen shapes, the aesthetics and completeness of the content display need to be considered. Typically, on devices with edge clipping like circular and capsule screens, the title bar uses a multi-line design to ensure the displayed content length does not exceed the screen. On rectangular screens, a single-row left-right layout is used for a more spacious overall design.

Code example:

<template>
  <div class="demo-page">
    <div class="title">
      <text class="title-text">{{text1}}</text>
      <text class="title-text">{{text2}}</text>
    </div>
  </div>
</template>

<script>
  export default {
    private: {
      text1: '09:28',
      text2: '文案'
    }
  }
</script>

<style>
.demo-page {
  justify-content: center;
  background-color: #5c5c5c;
}

.title {
  width: 90%;
}

.title-text {
  font-size: 36px;
  color: #fff;
}

@media (shape: circle){
  .title {
    flex-direction: column;
    align-items: center;
  }
}

@media (shape: rect) {
  .title {
    margin-top: 10px;
    justify-content: space-between;
    align-items: flex-start;
    flex-direction: row-reverse;
  }
  .title-text {
    font-size: 46px;
  }
}

@media (shape: pill-shaped) {
  .title {
    flex-direction: column;
    align-items: center;
  }
  .title-text {
    font-size: 72px;
  }
}
</style>
Effect display:

Circular screen / Rectangular screen / Capsule screen


Cross-Screen Application Project Examples
To-Do List Application
Circular screen / Rectangular screen / Capsule screen


Calculator
Circular screen / Rectangular screen



Conditional Compilation
Conditional compilation based on device features is a technique that determines which code should be included in an application during the compilation process based on characteristics such as device type and screen shape. This feature is suitable for cross-device application development, where different devices may require different code logic and interface layouts. Currently, the file types that support conditional compilation are: ux, js.

Process
Install conditional-compilation-webpack-plugin
npm install conditional-compilation-webpack-plugin -D

Install cross-env
npm install cross-env -D

Add a quickapp.config.js file in the project root directory and refer to the following configuration
const ConditionalCompilationWebpackPlugin = require("conditional-compilation-webpack-plugin")

module.exports = {
  plugins: [new ConditionalCompilationWebpackPlugin()]
}

Add scripts in package.json according to device features
"scripts": {
  "build:circle": "cross-env DEVICE_TYPE=WATCH SHAPE=CIRCLE aiot build --enable-custom-component",
  "build:rect": "cross-env DEVICE_TYPE=WATCH SHAPE=RECT aiot build --enable-custom-component"
}

Use conditional compilation in code, refer to the following code
<template>
  <div class="home-page">
    <!-- if true: process.env.DEVICE_TYPE === 'WATCH' && process.env.SHAPE === 'CIRCLE' -->
    <input class="btn bg-red" type="button" value="handleSet" @click="handleSet" />
    <!-- endif -->
    <!-- if true: process.env.DEVICE_TYPE === 'WATCH' && process.env.SHAPE === 'RECT' -->
    <input class="btn bg-blue" type="button" value="handleSet" @click="handleSet" />
    <!-- endif -->
  </div>
</template>

<script>
  export default {
    handleSet() {
      // if true: process.env.DEVICE_TYPE === 'WATCH' && process.env.SHAPE === 'CIRCLE'
      console.log('handleSet shape = circle')
      // endif
      // if true: process.env.DEVICE_TYPE === 'WATCH' && process.env.SHAPE === 'RECT'
      console.log('handleSet shape = rect')
      // endif
    }
  };
</script>

<style>
  .home-page {
    align-items: flex-start;
    justify-content: flex-start;
    padding: 60px;
    position: relative;
  }

  .btn {
    height: 60px;
    width: 360px;
    text-align: center;
    border-radius: 5px;
    margin-bottom: 30px;
    color: #ffffff;
    font-size: 30px;
    background-color: #0faeff;
  }

/* if true: process.env.DEVICE_TYPE === 'WATCH' && process.env.SHAPE === 'CIRCLE' */
  .bg-red {
    background-color: red;
  }
/* endif */
/* if true: process.env.DEVICE_TYPE === 'WATCH' && process.env.SHAPE === 'RECT' */
  .bg-blue {
    background-color: blue;
  }
/* endif */
</style>

Execute the configured compilation command
npm run build:circle
or
npm run build:rect



Dynamic Component
TIP

In this section, you will learn how to use dynamic components to reduce the amount of template code and improve code readability.

When multiple components are introduced on a page and need to be dynamically switched, it is highly recommended to use directives such as if on the template for logical judgment and change the view structure in most cases.

Example:

<import src="./part1.ux" name="part1"></import>
<import src="./part2.ux" name="part2"></import>
<import src="./part3.ux" name="part3"></import>
<template>
  <div>
    <part1 if="{{status === 1}}"></part1>
    <part2 elif="{{status === 2}}"></part2>
    <part3 else></part3>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        status: 1
      }
    }
  }
</script>
However, when there are many components, the amount of template code will become large, which is not conducive to maintenance. At this time, you can use dynamic components to reduce the amount of template code. This can be achieved by adding a special is attribute to the <component> element. The value of is represents the component name, and you can switch components by simply modifying the is attribute.

Example:

<import src="./part1.ux" name="part1"></import>
<import src="./part2.ux" name="part2"></import>
<import src="./part3.ux" name="part3"></import>
<import src="./part4.ux" name="part4"></import>
<import src="./part5.ux" name="part5"></import>
<import src="./part6.ux" name="part6"></import>

<template>
  <div>
    <component is="{{'part' + status}}"></component>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        status: 1
      }
    }
  }
</script>


Developer Materials
Developer materials refer to the various resources and tools provided by the Quick App Platform for developers. Currently, they include extended components, and in the future, will offer more support such as page templates, functional interfaces, development tools, etc. Every developer is welcome to contact us at vela-appframework@xiaomi.com to share your needs or contribute your material resources, jointly promoting technological progress and innovation, and building a more prosperous Quick App ecosystem.

Extended components are essentially custom components written by developers. If other developers want to use extended components, they only need to copy the component folder from the project address into their own project directory and import it into the page for use via the <import> method. Meanwhile, extended components provide developers with rich property configurations and callback events.

This design approach of extended components ensures the page's management capabilities over components while preventing unnecessary coupling between the page and components. It helps developers better organize logic and code, enhancing the maintainability of the project.


Extension Components
input-method
Overview
An input method component that adapts to different screen shapes and supports two mainstream keyboard layouts: full-keyboard mode and T9 mode for both Chinese and English input.

Example Previews
Full-Keyboard Mode
Circular Screen


Rectangular Screen


Pill-Shaped Screen


T9 Mode
Circular Screen


Project Address
GitHub
Vela 三⽅输⼊法组件
Vela_input_method
三⽅输⼊法组件

手动安装
下载项目代码
git clone https://github.com/NEORUAA/Vela_input_method.git
拷贝代码
把项目中的 components 文件夹拷贝到要使用组件的项目 src 目录下。然后就可以按照自定义组件的使用方式来使用本组件了。

组件名称
input-method

概述
输⼊法功能

⼦组件
不⽀持

属性
名称	类型	默认值	必填	描述
hide	boolean	true	是	是否显⽰键盘（开发者可以通过切换属性值隐藏或者唤醒键盘）
keyboardtype	string	"QWERTY"	否	键盘布局，"QWERTY" 表⽰全键，"T9" 表⽰九键。默认为 "QWERTY"（当 screentype 为 "pill-shaped" 时，仅全键盘可用）
maxlength	number	5	否	默认展⽰的拼⾳候选词数量， maxlength > 0 时有效；点击展开查看所有候选词
vibratemode	string	""	否	振动模式，""表⽰输⼊时不振动，"long" 表⽰⻓振动，"short" 表⽰短振动。默认为 ""
screentype	string	"circle"	否	设备屏幕类型，"rect" 表示方形屏布局（对应 designWidth ≥ 336），"circle" 表示圆形屏布局（对应 designWidth 为 480），"pill-shaped" 表示胶囊形屏布局（对应 designWidth ≥ 192）
事件
名称	参数	描述
complete	{ detail: { content: string } }	键盘输出字符时触发（当切换为中⽂输⼊法时候，当选中拼⾳对应⽂字时触发；当切换为英⽂输⼊法时，与 keyDown 触发条件⼀致）
delete	-	键盘点击删除按钮触发
keyDown	{ detail: { content: string } }	键盘按钮按下时触发
visibilityChange	{ detail: { visible: boolean } }	键盘显示或隐藏时触发，visible 表⽰显示状态
⽰例代码
<import name="input-method" src="../../components/InputMethod/InputMethod.ux"></import>
<template>
  <div class="page" style="flex-direction: column;">
    <text class="text" @click="changeState">
      {{textValue}}_
    </text>
    <input-method
      hide="{{hide}}"
      keyboardtype="{{keyboardtype}}"
      maxlength="5"
      vibratemode="{{vibratemode}}"
      screentype="{{screentype}}"
      @visibility-change="onVisibilityChange"
      @key-down="onKeyDown"
      @delete="onDelete"
      @complete="onComplete"
    ></input-method>
  </div>
</template>

<script>
export default {
  private: {
    textValue: "",
    hide: false,
    keyboardtype: "QWERTY", //QWERTY, T9
    vibratemode: "short",
    screentype: "circle", //pill-shaped, rect, circle
  },
  onVisibilityChange(evt) {
    console.log("显示状态变更:"+JSON.stringify(evt));
  },
  onKeyDown(evt) {
    // this.textValue += evt.detail.content;
    console.log("按下按键:"+JSON.stringify(evt));
  },
  onDelete() {
    this.textValue = this.textValue.slice(0, -1);
    console.log("删除字符");
  },
  changeState() {
    this.hide = !this.hide;
  },
  onComplete(evt) {
    this.textValue += evt.detail.content;
    console.log("返回字符:"+JSON.stringify(evt));
  },
};

</script>

<style>
.page{
  width:480px;
  height:480px;
}

.text{
  position:absolute;
  left:0;
  top:60px;
  width:100%;
  height:80px;
  text-align:center;
  color:white;
  background-color: red;
}
</style>


Design Guidelines
Notes on VELA device design.

Multi-Screen Design

Xiaomi Smart Wearable Devices
Currently, Xiaomi wearable devices equipped with the Vela system are primarily smartwatches and smart bands. The watch screens are circular or rectangular, while the band screens are mainly rectangular and capsule-shaped.

Data reference for released Vela wearable devices:

Device Type	Device Model	Screen Shape	Screen Size	Resolution	PPI	DPR
Watch	Xiaomi Watch S1 Pro	Circular	1.47 inches	480x480	326	2.0
Watch	Xiaomi Watch H1	Circular	1.43 inches	466x466	326	2.0
Watch	Xiaomi Watch S3	Circular	1.43 inches	466x466	326	2.0
Watch	Xiaomi Watch S4 sport	Circular	1.43 inches	466x466	326	2.0
Watch	Xiaomi Watch S4	Circular	1.43 inches	466x466	326	2.0
Watch	REDMI Watch 5	Rectangular	2.07 inches	432x514	324	2.0
Band	Xiaomi Smart Band 8 Pro	Rectangular	1.74 inches	336x480	336	2.1
Band	Xiaomi Smart Band 9	Capsule-shaped (track-style)	1.62 inches	192x490	325	2
Band	Xiaomi Smart Band 9 Pro	Rectangular	1.74 inches	336x480	336	2.1
Design Recommendations
When integrating products, design decisions can be made based on the application scenarios and the adaptable product forms. If the product scenario allows for good interaction across various screen forms such as smart bands and watches, it is recommended to create three types of design drafts to accommodate the interaction schemes for capsule-shaped, circular, and rectangular screens.

Data reference for different screen shapes:

Screen Shape	Circular Screen	Rectangular Screen	Capsule Screen
Aspect Ratio Range	W/H=1	0.5<=W/H<1	0.3<W/H<0.5
Recommended Aspect Ratio	1	0.7	0.39
Recommended Resolution	466x466	336x480	192x490
It is recommended to design three sets of UI interactions to adapt to the three main screen types. If the designs for circular and rectangular screens can be reused, one set can be designed for circular and rectangular screens, and another set for capsule screens.

Safe Area Adaptation for Curved Screens
For circular and capsule-shaped screens, the curved screen edges can cause some display issues. When designing the UI, it is necessary to consider the safe area of the screen and design the main functions within the safe area.

For example, when displaying text or content lists, it is important to consider the completeness and interactivity of the display at the edges.

The gray areas in the illustration represent the safe areas for circular and capsule screens, respectively.


Best Practices
This section primarily introduces some application development norms and best practices on how to reduce application latency and memory usage. It helps developers develop more concise, high-performance, and highly scalable applications.

Memory Optimization
Due to the limited memory of sports watches, third-party applications are required to have a relatively low memory footprint. Based on previous issues encountered, here is a checklist of considerations for third-party application development to help developers minimize the application's memory usage and meet the acceptance criteria for watch applications.

Code Considerations
For data unrelated to the UI that does not need to be bound, do not declare it in the viewModel's data to reduce observers or data proxies.
<template>
  <div>
    <text>{{name}}</text>     
  </div>
</template>

<script>
  const someObj = { a: 1 } // Recommended
  export default {
    protected: {
      name: 'aaa',
      someObj: { // Not recommended
        a: 1
      }
    }
  }
</script>

When updating page objects, try to update them in place instead of reassigning them to avoid allocating new memory space.
export default {
  protected: {
    list: [{
      name: 'aa',
      age: 22
    }]
  },
  
  onClick() {
    // Not recommended
    this.list = [{
      name: 'bb',
      age: 21
    }]
    // Recommended
    this.list[0].name = 'bb',
    this.list[0].age = 21
  }
}

Do not cache properties and methods declared in the page to the global scope.
When the page is destroyed, properties and methods related to the page object are dereferenced to clean up memory. If they are referenced globally, the memory they occupy cannot be cleaned up, and calling these cached properties and methods elsewhere may cause errors.

export default {
  protected: {
    list: [{
      name: 'aa',
      age: 22
    }]
  },
  
  onShow() {
    this.$app.$def.somearray.push(this.foo) // Not recommended
  }，
  
  foo() {
    this.list.push({
      name: 'bb',
      age: 21
    })
  }
}

Clear unfinished timers when the page is destroyed.
export default {
  protected: {
    timer: null
  }
  
  onShow() {
    this.timer = setTimeout(()=>{}, 1000000)
  }
  
  onDestroy() {
    if(this.timer){
      clearTimeout(this.timer)
    }
  }
}

Release file data promptly after use.
let foo = await storage.getItem('key')
let bar = await file.readText('path')

let fooObj = JSON.parse(foo)
let barObj = JSON.parse(bar)

// Release promptly after use
foo = null
bar = null

fooObj = null
barObj = null

Call the runGC method.
By calling the runGC method on the global global object, perform garbage collection in a timely manner to avoid memory leaks. Do not call it frequently to prevent page stuttering.

global.runGC()

static property.
The template supports the static property. If the bound variable will not change later, adding the static marker helps the framework reduce dynamic nodes, thereby reducing memory usage and the time taken to delete objects when the page is destroyed.

<template>
  <div>
    <text static >{{name}}</text>
    <image static src="/assets/icon/a.png"/>   
  </div>
</template>

<script>
  export default {
    protected: {
      name: 'aaa'
    }
  }
</script>

Additionally, the .static modifier is supported on the template to mark a static attribute of a node. This is applicable when the attribute value of a node is assigned only once during initialization and does not change afterward. Usage syntax: attr.static="{{ attrValue }}"

Note

The if / for static attributes of nodes can only be modified using the .static modifier.
The static attribute of nodes has higher priority than .static. For nodes declared with the static attribute, there is no need to additionally declare the static modifier attr.static for a specific attribute.
<template>
  <div>
    <div if.static="{{ bool }}">
      <text style="{{ styl }}" someattr="{{ some }}" class="{{ cls }}" static>{{name}}</text>

      <input style="{{ styl }}" name="{{ some }}" class="{{ cls }}" value="{{ name }}" static />
    </div>

    <text
      if.static="{{ bool }}"
      style.static="{{ styl }}"
      someattr.static="{{ some }}"
      class.static="{{ cls }}"
      value.static
    >{{name}}</text>

    <input
      if.static="{{ bool }}"
      style.static="{{ styl }}"
      someattr.static="{{ some }}"
      class.static="{{ cls }}"
      value.static="{{name}}"
    />
  </div>
</template>

<script>
  export default {
    private: {
      name: 'aaa',
      bool: true,
      cls: 'basic-text',
      some: 'someattr',
      styl: {
        backgroundColor: '#d1d1d1'
      }
    }
  }
</script>

The block component is a logical block node. If the static attribute is added, it indicates that all nodes contained within the block have static data bindings, and the bound data is calculated only once and does not change afterward. This is suitable for binding enumerated values or immutable list data, effectively reducing memory usage.

<template>
  <!-- Data within the block is calculated and rendered only once -->
  <block static>
    <text class="{{cls}}">Title: {{title}}</text>
    <text>Conditional rendering</text>
    <list>
      <list-item for="{{list}}" type="item">
        <text>{{$item}}</text>
      </list-item>
    </list>
  </block>
</template>
<script>
  export default {
    private: {
      title: 'I am title 1',
      cls: 'txt-cls',
      display: true,
      list: ['a', 'b', 'c']
    }
  }
</script>

Reduce Package Size
Reduce unnecessary third-party dependencies and choose lightweight alternatives.
For third-party dependencies in package.json, remove unused dependencies and replace necessary large dependencies with lightweight alternatives.

Use global methods.
Hang common methods, constants, and object instances on the global object to avoid importing them in pages. Access them directly from global when needed.

// global.js
import foo from './foo'
import bar from './bar'

global.foo = foo
global.bar = bar

// app.ux
import './global'


// pages/xxx/index.js
const {foo, bar} = global

export default {
    // Call foo and bar
    //......
}

Taking QQ Music as an example, the following is a comparison of optimization effects before and after:

Before Optimization	Replace with Lightweight Dependencies	Use Global Methods
Lines of Code	21965	13156	6807
Maximum Memory	4842844	3295928	1872528
Use low-resolution images while ensuring image quality.
Large images consume more memory when loaded. Resize large images to smaller dimensions and then compress them (https://tinypng.com (opens new window)) to reduce their size.

Remove unused CSS and JS.
Delete or comment out unused styles in CSS and unused variables and functions in JS to streamline the code.

Minimize the number of pages.
Implement the application with the fewest pages possible without affecting business requirements to reduce code size and simplify application logic.


Common Business Optimization
List and Long Copy Optimization
Description

Optimization methods for long lists and long copy (e.g., lengthy privacy agreements, user agreements) during display

List

When rendering a list initially, if the content exceeds 10 items, it is recommended to use pagination or trigger new data requests upon reaching the bottom. Avoid rendering a large amount of data initially, as it can cause page rendering lag.

Long Copy

Long copy typically involves displaying a large amount of text on small device screens, such as "User Agreement," "Privacy Agreement," "Minor Protection Agreement," etc.

It is usually recommended to display the agreement link via a QR code. Scanning the code to view on a mobile device is a common design practice.
If the product requires full rendering at once, it may cause page rendering lag and affect the initial user experience. Here, chunked rendering of the copy is recommended. Below is a code example:
<!-- Area for rendering the copy, with handleScroll scroll listener bound -->
<template>
  <scroll id="scroll" scroll-y="true" class="scroll" onscroll="handleScroll">
    <div id="content" class="connent">
      <block if="{{currentKey >= 0}}">
        <text class="header-1">{{contentArray[0]}}</text>
      </block>
        <block if="{{currentKey >= 1}}">
        <text class="header-1">{{contentArray[1]}}</text>
      </block>
        <block if="{{currentKey >= 2}}">
        <text class="header-1">{{contentArray[2]}}</text>
      </block>
    </div>
  </scroll>
</template>
<!-- Save the copy content as an array and record the sequence number of the currently rendered copy -->
<script>
export default {
  data:{
    contentArray:[
      {
        content:'Copy one..........'
      },
      {
        content:'Copy two..........'
      },
      {
        content:'Copy three..........'
      }
    ],
    // Current sequence number of the rendered copy
    currentKey:0,
    // Current total height
    currentTHEight:0,
  }
  // Assign initial value to current total height onReady
  onReady(){
    this.$element('content').getBoundingClientRect({
      success: (data) => {
        const { height } = data;
        this.currentTHEight = height
      }
    })
  }
  // Real-time judgment of scroll height vs. total height; load next copy if near bottom, and reassign total height
  handleScroll(e) {
    if(currentTHEight - e.scrollY <40){
        this.currentKey = currentKey + 1
    }
    this.$element('content').getBoundingClientRect({
      success: (data) => {
        const { height } = data;
        this.currentTHEight = height
      }
    })
  }
}

</script>

Swiper Multi-Image Optimization
Description

When using the swiper carousel, if there are many images, avoid rendering multiple images simultaneously. Ensure only images within and around the visible area are rendered.

Suppose an album has 200 images to display, creating 200 sub-components in the swiper is not performance-friendly. Therefore, consider displaying only 3 sub-components in the swiper and dynamically updating the images in the sub-components during swiping to achieve lazy loading in the Swiper. The main process for right-swipe lazy loading is as follows:

Right-Swipe Lazy Loading Process Assume an array of 5 images data=[0,1,2,3,4] needs to be displayed in a swiper with 3 sub-components.

When the user clicks the first image, the swiper data is data[0], data[1], data[2]
When swiping from the first to the second image, the swiper array remains data[0], data[1], data[2]
When swiping from the second to the third image, modify the first component's data in the swiper to the next data of the third image data[3], and set the loop property of the swiper to true. At this point, the swiper data is data[3], data[1], data[2];
When swiping from data[3] to data[4], note that data[4] is the last data. If the last data is not in the last component of the swiper, reset all data in the swiper to data[len-3], data[len-2], data[len-1] to ensure the last image is in the last component of the swiper, and set loop to false to prevent swiping from the last to the first image.
alt text Swiper Lazy Loading Example
Specific Implementation Idea
Monitor the swiper's swiping via the @change event in the code. The logic for judging left and right swipes is as follows:

// Judge right swipe
if (
  (!(this.currentIndex === 0 && index === length - 1) && index > this.currentIndex) ||
  (index === 0 && this.currentIndex === length - 1)
) {
}else{
}

The logic for right swiping is as follows:

// Update data index
this.dataIndex = this.dataIndex + 1
// Update next right swipe index
const updateIndex = this.dataIndex + 1
if (updateIndex < this.bigThumbnailInfo.length) {
  // Update next right swipe to the next image
  updateItem = this.bigThumbnailInfo[updateIndex]
  // If swiping from the first image
  if (this.currentIndex === 0) {
    // Before swiping, it's the first image; update the last in swiper after right swipe
    this.data[length - 1] = updateItem
    resIndex = length - 1
  } else {
    // console.info("Right swipe: update left")
    this.data[this.currentIndex - 1] = updateItem
    resIndex = this.currentIndex - 1
  }
}

The logic for left swiping is as follows:

// Update data index
this.dataIndex = this.dataIndex - 1
// Update next right swipe index
const updateIndex = this.dataIndex - 1
// Update next left swipe to the previous image
updateItem = this.bigThumbnailInfo[updateIndex]
if (this.currentIndex === length - 1) {
  // Before swiping, it's the last image; update the first in swiper after left swipe
  this.data[0] = updateItem
  resIndex = 0
} else {
  this.data[this.currentIndex + 1] = updateItem
  resIndex = this.currentIndex + 1
}

Judge if the current image is the last one:

this.data = [
  this.bigThumbnailInfo[len - 3],
  this.bigThumbnailInfo[len - 2],
  this.bigThumbnailInfo[len - 1]
]
indexTemp = 2
this.swiperIndex = this.currentIndex
this.isloop = false

Judge if the upcoming image is the first one:

this.data = [
  this.bigThumbnailInfo[0],
  this.bigThumbnailInfo[1],
  this.bigThumbnailInfo[2]
]
indexTemp = 0
this.swiperIndex = this.currentIndex
this.isloop = false

If it's neither the first nor the last image, set the swiper's loop to true:

this.isloop = true

Device Frame Rate Optimization Suggestions
When there are background images or images, minimize the use of border-radius and use images with rounded corners instead.
Ensure the image size matches the size of the div or image component to avoid scaling.
Reduce modifications to dynamic styles.
Minimize the nesting level of tags.
Reduce reflows and repaints.
Other Optimization Suggestions
Add try-catch blocks to catch exceptions.
For scenarios with slow data requests, consider adding a loading indicator.



Startup Latency Optimization
Avoid setTimeout Delay
When performing page redirects from the logo page, avoid adding setTimeout delays for the redirect unless absolutely necessary. If you need to wait for asynchronous results, such as determining the next page to redirect to after retrieving data from storage, it is recommended to encapsulate the asynchronous method as synchronous using await, and execute the redirect immediately after the results are returned. Taking storage as an example:

// ❌ Not Recommended
onInit(){
  this.checkifHome()
  setTimeout(() => {
    if(!this.ifHome){
      router.push({uri:'pages/home'})
    }
  },1000)
}
checkifHome(){
  const that = this 
  storage.get({
    key: 'ifHome',
    success: function(data) {
      that.ifHome = data
    },
    fail: function(data, code) {
      console.log(`handling fail, code = ${code}`)
    }
  })
}

// ✅ Recommended Approach 1
onInit(){
  storage.get({
    key: 'ifHome',
    success: function(data) {
      if(!data){
        router.push({uri:'pages/home'})
      }
    },
    fail: function(data, code) {
      console.log(`handling fail, code = ${code}`)
    }
  })
}

// ✅ Recommended Approach 2
async onInit(){
  const ifHome = await checkifHome()
  if(!ifHome){
    router.push({uri:'pages/home'})
  }
}
checkifHome(){
  return new Promise((resolve, reject) => {
    storage.get({
      key: 'ifHome',
      success: function(data) {
        resolve(data) 
      },
      fail: function(data, code) {
        console.log(`handling fail, code = ${code}`)
        reject(code)
      }
    })
  })
}

// ✅ Recommended Approach 3
// You can encapsulate a unified promise.js for reuse with other asynchronous interfaces
export function promisify(fn) {
  if (typeof fn !== 'function') {
    throw Error('[promisify] the type of `fn` should be function');
  }

  return (opts={}) => {
    let { success, fail, complete, ...args } = opts;

    if (typeof success === 'function' || typeof fail === 'function' || typeof complete === 'function') {
      console.warn('[promisify] [WARN] The `success`, `fail` and `complete` callback will be ignored');
    }

    return new Promise((resolve, reject) => {
      try {
        fn({
          ...args,
          success: data => resolve(data),
          fail: (data, code) => {
            let err = new Error(data);
            err.code = code;
            reject(err);
          }
        });
      } catch (error) {
        reject(error)
      }
    })
  }
}

// Unified encapsulation of storage methods
import storage from '@system.storage';
import {promisify} from './promise';

const _get = promisify(storage.get);
const _set = promisify(storage.set);
const _clear = promisify(storage.clear);
const _delete = promisify(storage.delete);
export default {
  getItem(key) {
    return _get({key});
  },

  setItem(key, value) {
    return _set({key, value});
  },

  deleteItem(key) {
    return _delete({key});
  },

  clear() {
    return _clear();
  },
}

// logo.ux
async onInit(){
   const ifHome = await storage.getItem('ifHome')
  if(!ifHome){
     router.push({uri:'pages/home'})
  }
}

Homepage Data Caching
If the homepage data needs to be displayed again upon second entry, consider adding caching when the application (or homepage) exits. The next time you enter, read the cache from the logo page and store the data globally. The homepage page can read it directly during onInit and simultaneously initiate an asynchronous request to update it;

Avoid HTTP Requests on Logo Page
It is recommended not to introduce HTTP requests on the logo page; try to perform them on the homepage to prevent page redirects from being blocked in weak or no network conditions;

UI First
For applications like music apps, it is suggested to have a default state of not playing upon entering the app. The UI can be displayed first, and if song information is successfully retrieved, it can be shown immediately without waiting for the audio resource to load completely;

Use Static Data for Privacy Page Information
Use static data in the code for the privacy page instead of dynamic fetching. For long text that needs to be displayed, it can be viewed via QR code scanning. The QR code can directly link to a local H5 page and should not be fetched via an API;

Minimize Console Logging
Minimize console logging, especially long logs, as they significantly impact performance. Avoid very long (>10 lines) console logs and minimize printing JSON objects. If logging is necessary during debugging, use console.debug and configure quickapp.config.js (as shown below) to filter out console.debug logs when building the release package;

const TerserPlugin = require("terser-webpack-plugin")
const webpack = require("webpack")

module.exports = {
  postHook: (config) => {
    if (config.mode === "production") {
      config.optimization.minimize = true
      config.optimization.minimizer = [
        new TerserPlugin({
          terserOptions: {
            compress: {
              pure_funcs: ["console.debug"]
            }
          }
        })
      ]
    }
  }
}

Image Caching/Cropping
For large (>100kb) dynamic images, it is recommended to add a loading page during the first load, download and cache them locally, and then load them via internal://files/XXX.png for subsequent uses (Important: Generally, it is not recommended to introduce large online images unless necessary. The dimensions of introduced large images should not exceed the screen size, and the size should not exceed 200kb. Try to use local images instead of online images, or support resize cropping for online images).

// login.ux
export function downloadFile(url) { // Download image
  return new Promise((resolve, reject) => {
    if(!url){
      resolve('')
    }
    request.download({
      url,
      success: function (ret) {
        const token = ret.token
        request.onDownloadComplete({
          token: token,
          success: function (ret) {
            console.info(`### request.download ### ret`,ret)
            resolve(ret.uri)
          },
          fail: function (msg, code) {
            console.info(`### request.onDownloadComplete ### ${code}: ${msg}`)
            resolve(null)
          }
        })
      }
    })
  })
}
const formUrl = 'http://XXX.cdn.homeBg.png'
downloadFile(formUrl).then(url => {
  global.homeBgUrl = url; // url => 'internal://files/homeBg.png'
})
 
// home.ux
<image class="w-466 h-466" src="{{bgImage}}" alt="../../common/images/homeBg.png"></image>
//....
  computed:{
    bgImage() {
      const img =  global.homeBgUrl || 'http://XXX.cdn.homeBg.png'
      return img
    }
  }
//....
 
 // logo page
 global.homeBgUrl = await storage.getItem('homeBgUrl')
 
 // Clean up images promptly based on condition changes
 logoOut(){
   file.delete({
    uri:global.homeBgUrl,
    success: function(data) {
      console.info(`###delFile sucess ${data}`)
      resolve(true)
    },
    fail: function(data, code) {
      resolve(false)
      console.log(`###delFile fail, code = ${code}`)
    }
  })
}

Use diagnosis Method for Connection Status Before Communication in Communication Apps
When using interconnect for communication between the watch app and the phone app, abandon the previous polling method of calling getApkStatus and switch to the new API diagnosis.

data: {
   status: '',
   connectNum: 3,
   conn: null
},
onInit() {
   this.conn = interconnect.instance();
   this.connectStatus();
}, 

// ❌ Not Recommended
connectStatus() {
  let status = this.conn.getApkStatus();
  if (status === 'CONNECTED' || this.connectNum === 0){
    this.status = status;
    // do something
  } else if (this.connectNum > 0) {
    this.connectNum --;
    setTimeout(() => {
      this.connectStatus()
    },500)
  }
}

// ✅ Recommended
connectStatus() {
  this.conn.diagnosis({
    success: (data) => {
      console.log(`handling success, status= ${data.status}`)
      // do something
    },
    fail: (data,code) => {
      console.log(`handling fail, code = ${code}`)
      // do something
    }
  })
}  

Use interconnect to Transfer Multiple Data Items
When transferring multiple data items from the watch app to the phone app, if the number of items is not large, it is recommended to send them all at once without adding delays.

// ❌ Not Recommended
sendMsg(list) {
  for (let x in list) { 
    setTimeout(() => {
      this.conn.send({
        data: list[x],
        success: ()=>{ },
        fail: (data: {data, code})=> { }
      })
    },x*500) 
  }
}

// ✅ Recommended
sendMsg(list) {
  for (let x in list) {            
    this.conn.send({
      data: list[x],
      success: ()=>{ },
      fail: (data: {data, code})=> { }
    })
  }
}


APILevel
APILevel is used to identify the collection of interface standards provided by the current framework. By default, all interfaces in the documentation belong to APILevel 1. If certain interfaces belong to other versions, they will be marked accordingly.

APILevel2
Framework
Added media query to support the media feature - shape
Components
Added the barcode component
Added the qrcode component
Added the image-animator component
Added the scroll component
Added the getBoundingClientRect general method
Added the swipestart and swipeend events to the swiper component
APIs
Added the return values deviceType and APILevel to getInfo() of @system.device


APILevel3
Framework
Added common style: box-shadow
Added global method: $canIUse
Components
Added edge adsorption style for the scroll component
Interface
Added interface: @system.uploadtask
Added canIUse method for @system.app
Added return value for @system.device getInfo(): screenDensity, screenShape added pill-shaped screen
Style
Expanded media query to support new features and logical operations
Added dp unit


APILevel4
Components
New interface: @system.event


Precautions
Exception Scenarios in the Watch
Network exceptions, prompt when there is no network
Data exceptions (no data is obtained, or the backend interface returns an error)
JS code error handling
Prevent duplicate clicks on buttons (especially pay attention to operations that send requests after clicking)
After the screen is turned off, the onShow lifecycle function will be triggered again when the screen is turned on again. If there is a fetch request in this lifecycle function, the request will be initiated again when the screen is turned on, so use it with caution.
Code Specifications
The code in the app.ux file must be written within <script></script>, otherwise the code will not execute!
In *.ux files, the template node can only have one root node
CSS properties related to angles must include units, such as total-angle: 360deg
In list-item, use conditional judgments like if/else/show cautiously to ensure all list-item structures are consistent
For the src attribute of image, do not use variable concatenation (e.g., src="/common/{{type}}"), otherwise the compiler will display a warning during packaging. It is recommended to use the variable directly, like src="{{imgPath}}"
Common Optimizations
Reduce the number of network requests and concurrency
Consider local caching for interfaces with low real-time data requirements (also consider data size for caching)
Control the number of local files and avoid directly traversing files to get all file sizes
Use low-resolution network images whenever possible
Use pagination for lists, with about 20 items per page being optimal
Do not store network request data directly in memory; only store the fields that are needed
Use third-party dependencies cautiously and prefer lightweight ones
Consider placing common code in the global scope to avoid multiple imports
Add a loading state to prevent multiple network requests from being initiated due to frequent button clicks


Component
Components are divided into predefined components and custom components.

Predefined components are components that are predefined by the framework and whose rendering and logic are implemented by the framework. For example, when developing a page, developers must use components such as text and div, which are rendered by the platform's Native layer.

If developers are developing a complex page and write all UI parts in the <template> of a single file, the maintainability of the code will be very low, and unnecessary coupling relationships between modules may easily arise. To better organize logic and code, the page can be divided into multiple modules according to functionality, with each module responsible for a specific functional part. Finally, the page incorporates and manages these modules, passing business and configuration data to achieve code separation. This is the significance of custom components.

Custom components are components written by developers. They are used similarly to Native components and are ultimately rendered according to the component's <template>. At the same time, they are developed similarly to pages, with a ViewModel that manages data, events, and methods.

In this light, a page can also be seen as a special type of custom component that can be used without being imported and serves the entire page.

This chapter mainly provides a detailed introduction to the usage of predefined Native components, including their supported styles, properties, and events.


General Component Description
This section introduces the styles, properties, and events common to all components.


General Style
General styles are styles that can be supported by all components.

These styles are consistent with the usage of CSS property styles. Developers can write them in inline styles or <style> tags to customize component styles.

For information on setting component styles, refer to this document.

Sample Code
<template>
  <div class="page">
    <div class="box-normal" style="background-color:#f76160"></div>
    <div class="box-normal"></div>
  </div>
</template>

<style>
  .page {
    padding: 30px;
    background-color: white;
  }

  .box-normal {
    background-color: #09ba07;
    width: 100px;
    height: 100px;
    border-radius: 8px;
    margin-right: 10px;
  }
</style>



Property List
Note: All general styles are optional.

Name	Type	Default Value	Description
width	<length> | <percentage>	-	Uses the width required by the component's own content when not set
height	<length> | <percentage>	-	Uses the height required by the component's own content when not set
min-width	auto | <length> | <percentage>	auto	Specifies the minimum width of an element. This property cannot be negative. The default value auto is the default minimum width for flexible elements. The same applies below.
min-height	auto | <length> | <percentage>	auto	Specifies the minimum height of an element
max-width	none | <length> | <percentage>	none	Specifies the maximum width of an element. This property cannot be negative. The default value none indicates no restriction. The same applies below.
max-height	none | <length> | <percentage>	none	Specifies the maximum height of an element
padding	<length>	0	Shorthand property that sets all padding properties in one declaration. This property can have 1 to 4 values. For details, refer to the MDN (opens new window)documentation.
padding-[left|top|right|bottom]	<length>	0	Sets the padding in a specific direction for an element. The padding area refers to the space between an element's content and its boundary. This property cannot be negative.
margin	<length>	0	Shorthand property that sets all margin properties in one declaration. This property can have 1 to 4 values. For details, refer to the MDN (opens new window)documentation.
margin-[left|top|right|bottom]	<length>	0	Sets the margin in a specific direction for an element. This property cannot be negative.
border	-	0	Shorthand property that sets all border properties in one declaration. You can set the properties width, style, and color in sequence. Properties not set will use default values.
border-style	solid	solid	Currently supports only 1 value, setting the style for all borders of an element
border-width	<length>	0	Sets the width of all borders for an element
border-color	<color>	black	Sets the color of all borders for an element. For color value input, refer to Color Configuration
border-radius	<length> | <percentage>	0	The border-radius property allows you to set rounded corners for an element's outer border. When setting, you need to set border-width and border-color simultaneously. The radius's magnitude will not exceed half of the shorter side of the rectangle.
background-color	<color>	-	For color value input, refer to Color Configuration
color	<color>	-	For color value input, refer to Color Configuration
background-image	<uri>	-	Supports local and network image resources; when using the internal:// protocol, upgrade aiot-toolkit to version 1.1.2 or higher
background-size	contain | cover | auto | <length> | <percentage>	auto auto	Sets the background image size. For details, see Background Image Styles
background-repeat	repeat | repeat-x | repeat-y | no-repeat	repeat	[Currently unsupported] Sets whether and how background images are repeated. For details, see Background Image Styles
background-position	<length> |<percentage>| left | right | top | bottom | center	0px 0px	Sets the position where the background image is drawn within the container. Supports 1-4 parameters. For details, see Background Image Styles
box-shadow 3+	<length> <length> <color> |
<length> <length> <length> <color> |
<length> <length> <length> <length> <color>
-	Sets the shadow effect for an element. This property can set values including the X-axis offset, Y-axis offset, blur radius, spread radius, and color of the shadow.
Example:
box-shadow: 60px -16px teal, values correspond to: x-axis offset, y-axis offset, shadow color;
box-shadow: 10px 5px 5px black, values correspond to: x-axis offset, y-axis offset, shadow blur radius, shadow color;
box-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2), values correspond to: x-axis offset, y-axis offset, shadow blur radius, shadow spread radius, shadow color
opacity	<number>	1	The opacity property specifies the transparency of an element
display	flex | none	flex	JS applications only support flex layout; setting the current element's display to none will prevent it from being rendered on JS application pages
visibility	visible | hidden	visible	The visibility property controls the display or hiding of an element without changing the document's layout
flex	<number>	-	Takes effect when the parent container is <div> or <list-item>
flex-grow	<number>	0	Takes effect when the parent container is <div> or <list-item>
flex-shrink	<number>	1	Takes effect when the parent container is <div> or <list-item>
flex-basis	<number>	-1	Takes effect when the parent container is <div> or <list-item>
flex-direction	<string>	row	Defaults to horizontal row. Takes effect when the parent container is <div> or <list-item>
align-items	<string>	flex-start	align-items defines how flex items can be aligned along the cross axis of the flex container's current row. flex-start (default): The flex item's outer margin edge at the cross axis start aligns with the row's edge at the cross axis start. flex-end: The flex item's outer margin edge at the cross axis end aligns with the row's edge at the cross axis end. center: The flex item's margin box is centered along the cross axis of the row. baseline: Flex items are aligned according to their baselines. stretch: Flex items are stretched to fill the entire flex container. This value causes the item's margin box dimensions to be as close as possible to the row's dimensions while respecting the constraints of the min/max-width/height properties.
justify-content	<string>	flex-start	justify-content defines how flex items are aligned along the main axis. flex-start (default): Flex items are aligned to the start of a row. flex-end: Flex items are aligned to the end of a row. center: Flex items are aligned to the center of a row. space-between: Flex items are evenly distributed in a row. The first flex item is at the start of the row, and the last flex item is at the end of the row. space-around: Flex items are evenly distributed in a row, with equal space around them.
position	absolute | relative	relative	Supports relative and absolute property values, with a default value of relative; does not take effect when the parent container is <list> or <swiper>
[left|top|right|bottom]	<length>	-	Generally used in conjunction with absolute layout. Supports the unit px and does not currently support percentages.


Color Configuration
Vela JS applications support rgb() and rgba() color value settings.

Developers can refer to the MDN documentation (opens new window)for more information on color values.

Color Value Format Examples
'#f0f' (#rgb)
'#ff00ff' (#rrggbb)
'rgb(255, 0, 255)'
'rgba(255, 255, 255, 1.0)'
'#f0ff' (#rgba)
'#ff00ff00' (#rrggbbaa)
Transparency
rgba(0,0,0,0) also has another shorthand version:

'transparent'
Color Names
You can also use the following color configurations:

 aliceblue (#f0f8ff)
 antiquewhite (#faebd7)
 aqua (#00ffff)
 aquamarine (#7fffd4)
 azure (#f0ffff)
 beige (#f5f5dc)
 bisque (#ffe4c4)
 black (#000000)
 blanchedalmond (#ffebcd)
 blue (#0000ff)
 blueviolet (#8a2be2)
 brown (#a52a2a)
 burlywood (#deb887)
 cadetblue (#5f9ea0)
 chartreuse (#7fff00)
 chocolate (#d2691e)
 coral (#ff7f50)
 cornflowerblue (#6495ed)
 cornsilk (#fff8dc)
 crimson (#dc143c)
 cyan (#00ffff)
 darkblue (#00008b)
 darkcyan (#008b8b)
 darkgoldenrod (#b8860b)
 darkgray (#a9a9a9)
 darkgreen (#006400)
 darkgrey (#a9a9a9)
 darkkhaki (#bdb76b)
 darkmagenta (#8b008b)
 darkolivegreen (#556b2f)
 darkorange (#ff8c00)
 darkorchid (#9932cc)
 darkred (#8b0000)
 darksalmon (#e9967a)
 darkseagreen (#8fbc8f)
 darkslateblue (#483d8b)
 darkslategrey (#2f4f4f)
 darkturquoise (#00ced1)
 darkviolet (#9400d3)
 deeppink (#ff1493)
 deepskyblue (#00bfff)
 dimgray (#696969)
 dimgrey (#696969)
 dodgerblue (#1e90ff)
 firebrick (#b22222)
 floralwhite (#fffaf0)
 forestgreen (#228b22)
 fuchsia (#ff00ff)
 gainsboro (#dcdcdc)
 ghostwhite (#f8f8ff)
 gold (#ffd700)
 goldenrod (#daa520)
 gray (#808080)
 green (#008000)
 greenyellow (#adff2f)
 grey (#808080)
 honeydew (#f0fff0)
 hotpink (#ff69b4)
 indianred (#cd5c5c)
 indigo (#4b0082)
 ivory (#fffff0)
 khaki (#f0e68c)
 lavender (#e6e6fa)
 lavenderblush (#fff0f5)
 lawngreen (#7cfc00)
 lemonchiffon (#fffacd)
 lightblue (#add8e6)
 lightcoral (#f08080)
 lightcyan (#e0ffff)
 lightgoldenrodyellow (#fafad2)
 lightgray (#d3d3d3)
 lightgreen (#90ee90)
 lightgrey (#d3d3d3)
 lightpink (#ffb6c1)
 lightsalmon (#ffa07a)
 lightseagreen (#20b2aa)
 lightskyblue (#87cefa)
 lightslategrey (#778899)
 lightsteelblue (#b0c4de)
 lightyellow (#ffffe0)
 lime (#00ff00)
 limegreen (#32cd32)
 linen (#faf0e6)
 magenta (#ff00ff)
 maroon (#800000)
 mediumaquamarine (#66cdaa)
 mediumblue (#0000cd)
 mediumorchid (#ba55d3)
 mediumpurple (#9370db)
 mediumseagreen (#3cb371)
 mediumslateblue (#7b68ee)
 mediumspringgreen (#00fa9a)
 mediumturquoise (#48d1cc)
 mediumvioletred (#c71585)
 midnightblue (#191970)
 mintcream (#f5fffa)
 mistyrose (#ffe4e1)
 moccasin (#ffe4b5)
 navajowhite (#ffdead)
 navy (#000080)
 oldlace (#fdf5e6)
 olive (#808000)
 olivedrab (#6b8e23)
 orange (#ffa500)
 orangered (#ff4500)
 orchid (#da70d6)
 palegoldenrod (#eee8aa)
 palegreen (#98fb98)
 paleturquoise (#afeeee)
 palevioletred (#db7093)
 papayawhip (#ffefd5)
 peachpuff (#ffdab9)
 peru (#cd853f)
 pink (#ffc0cb)
 plum (#dda0dd)
 powderblue (#b0e0e6)
 purple (#800080)
 rebeccapurple (#663399)
 red (#ff0000)
 rosybrown (#bc8f8f)
 royalblue (#4169e1)
 saddlebrown (#8b4513)
 salmon (#fa8072)
 sandybrown (#f4a460)
 seagreen (#2e8b57)
 seashell (#fff5ee)
 sienna (#a0522d)
 silver (#c0c0c0)
 skyblue (#87ceeb)
 slateblue (#6a5acd)
 slategray (#708090)
 snow (#fffafa)
 springgreen (#00ff7f)
 steelblue (#4682b4)
 tan (#d2b48c)
 teal (#008080)
 thistle (#d8bfd8)
 tomato (#ff6347)
 turquoise (#40e0d0)
 violet (#ee82ee)
 wheat (#f5deb3)
 white (#ffffff)
 whitesmoke (#f5f5f5)
 yellow (#ffff00)
 yellowgreen (#9acd32)


Animation Styles
The Vela JS application supports developers in creating animations by providing animation style properties for the transform, transform-origin, animation, and transition classes, with parameter formats aligned with CSS for easier developer adaptation.

For transform, refer to this documentation (opens new window).

For transform-origin, refer to this documentation (opens new window).

For animation, refer to this documentation (opens new window).

For transition, refer to this documentation (opens new window).

Animation Style List
Name	Type	Default Value	Description
transform	<string>	-	See transform operations below
transform-origin	<string>	-	See transform-origin operations below
animation-name	<string>	-	Corresponds to the name of @keyframes, see @keyframes properties below
animation-delay	<time>	0	Currently supported units: [s(seconds) | ms(milliseconds)]
animation-duration	<time>	0	Currently supported units: [s(seconds) | ms(milliseconds)]
animation-iteration-count	<integer> | infinite	1	Defines the number of animation plays, can be set to infinite for unlimited plays
animation-timing-function	linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>) | step-start | step-end | steps(number_of_steps[, step-direction]?)	ease	-
transition-property	<string>	all	Specifies the generic style property name for executing the transition effect, see details
transition-duration	<time>	0s	Specifies the execution time of the transition
transition-timing-function	linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>) | step-start | step-end | steps(number_of_steps[, step-direction]?)	ease	Specifies the timing function for transition execution. The parameter interpretation is the same as for animation
transition-delay	<time>	0s	Specifies the time when the transition starts executing, i.e., how long after changing the element's property value the transition effect begins
Note:

animation-timing-function types:
cubic-bezier(<number>, <number>, <number>, <number>) | step-start | step-end | steps(number_of_steps[, step-direction]?) where:

steps(number_of_steps, step-direction)

Name	Type	Default Value
Required
Description
number_of_steps	<integer>	-	Yes	Positive integer representing equal interval steps
step-direction	jump-start | jump-end | jump-none | jump-both | start | end	end	No	Keyword indicating left-continuous or right-continuous function
cubic-bezier(x1, y1, x2, y2):
Parameters x1, y1, x2, y2 are <number> type values representing the horizontal and vertical coordinates of points P1 and P2 in the currently defined cubic Bezier curve. x1 and x2 must be within the [0, 1] range; otherwise, the current value is invalid.

Transform Operations
Apply 2D transformations to elements. This property allows us to rotate, scale, and move elements.

Supported style property list:

Name	Type
translate	<length> | <percent>
translateX	<length> | <percent>
translateY	<length> | <percent>
scale	<number>
scaleX	<number>
scaleY	<number>
rotate	<deg>
Transform-Origin Operations
Change the origin point of an element's deformation, currently supporting changes to the element's X and Y axes.

Note:

This property must be used with the transform property first.
Example code:

/* Using % values */
div {
  transform: rotate(30deg); 
  transform-origin: 20% 40%;
}
/* Using px values */
div {
  transform: rotate(30deg); 
  transform-origin: 100px 100px;
}

Animation-Name Property
Specifies a series of animations to be adopted. Each property value name represents a keyframe sequence defined by the @keyframes property. This property supports applying single or multiple animations (1070+) in components. When applying multiple animations, they start simultaneously.

Example code:

/* Single animation */
animation-name: Color;
animation-name: translate;
animation-name: rotate;

/* Multiple animations 1070+ */
animation-name: Color, Opacity;
animation-name: Width, translate, rotate;

@keyframes Property
Name	Type	Default Value
Description
background-color	<color>	-	-
background-position	<length> |<percentage>| left | right | top | bottom | center	0px 0px	Describes the position where the background image is drawn in the container, supports 1-4 parameters, see Background Image Styles for details
opacity	<number>	-	-
width/height	<length>	-	Percentage not currently supported
transform	<string>	-	Allows rotating, scaling, and moving elements
Note:

Currently does not support omitting the starting value (0%) or ending value (100%); both must be explicitly specified.

Transition Animation
Transition animation is another way to implement animations. Transition animations can define transition effects for elements when switching between different states, such as state changes implemented through JavaScript.

Transition Usage Example
There are four style properties: transition-property, transition-duration, transition-timing-function, and transition-delay, written directly in the style. Example usage:

<template>
  <div class="page">
    <div class="div {{otherClass}}"></div>
  </div>
</template>

<script>
  export default {
    data: {
      otherClass: ""
    },
    onShow() {
      const that = this
      setTimeout(() => {
        that.otherClass = "new-width"
      }, 1000);
    }
  };
</script>

<style>
.page {
  padding: 60px;
  align-items: center;
}
.div {
  width: 100px;
  height: 200px;
  background-color: red;
  transition-property: width;
  transition-duration: 2000ms;
  transition-timing-function: ease-in;
  transition-delay: 500ms;
}
.new-width {
  width: 300px;
}
</style>

The four style properties above can be abbreviated into one, indicating that after triggering a width change in the div, it will change to the new width value in an accelerated manner over 0.5s, with the transition animation lasting 2s:

.div {
  transition: width 2000ms ease-in 500ms;
}

Generic Style Properties Supported by transition-property
The list of generic style properties supported by transition-property in JS applications:

Style Name	Remarks
width	√
height	√
opacity	√
visibility	√
color	Not currently supported
transform-origin	Not currently supported
transform	Not currently supported
padding	Not currently supported
padding-[left|top|right|bottom]	Not currently supported
margin	Not currently supported
margin-[left|top|right|bottom]	Not currently supported
border	Not currently supported
border-[left|top|right|bottom]	Not currently supported
border-width	√
border-[left|top|right|bottom]-width	Not currently supported
border-color	√
border-[left|top|right|bottom]-color	Not currently supported
border-radius	Not currently supported
border-[top|bottom]-[left|right]-radius	Not currently supported
background	Not currently supported
background-color	√
background-size	Not currently supported
background-position	√
flex	Not currently supported
flex-grow	Not currently supported
flex-shrink	Not currently supported
flex-basis	Not currently supported
[left|top|right|bottom]	Not currently supported



Background Image Style
When adding an image as a background for a page component, developers can adjust the size, repetition mode, and placement of the image background.

background-size Property
This property defines the size of the background image.

The number of parameters can be one or two.

The list of valid parameters is as follows:

Parameter	Description
contain	Scales the background image proportionally to fit entirely within the container, possibly leaving some empty space in the container (only as a single parameter).
cover	Scales the background image proportionally to cover the entire container, possibly making parts of the background image invisible (only as a single parameter).
auto	Indicates that the original dimensions of the image remain unchanged. Note that the original dimensions are in physical resolution, consistent with the resolution unit of mobile phone screens, not the 1px length in JS applications.
<length>	Describes the specific dimensions of the image, in units of px or dp. Floating-point calculations are not supported, and floating-point values will be floored.
<percent>	Describes the percentage of the image's dimensions relative to the corresponding dimensions of the container. Floating-point calculations are not supported, and floating-point values will be floored.
When there are two parameters, the first parameter is interpreted as the width along the horizontal axis, and the second parameter is interpreted as the height along the vertical axis. If there is only one parameter, auto is supplemented as the second parameter, and then parsed according to the rules for two parameters.

Invalid parameters are uniformly interpreted as the default value auto, i.e., the original image dimensions.

Example

<template>
  <div class="page">
    <text>Image size 128 * 128</text>
    <text>Background container 300 * 200</text>
    <image src= "../../common/logo.png">
    <div class="imgBg"></div>
  </div>
</template>
<style>
  .page {
    flex-direction: column;
    align-items: center;
    background-color: #000;
  }
  text {
    color: #fff;
    font-size: 24px;
  }
  .imgBg {
    width: 300px;
    height: 200px;
    margin-top: 20px;
    border: 2px solid yellowgreen;
    background-color: yellowgreen;
    background-image: url('../../common/logo.png');
    background-size: 300px 200px;
    background-repeat: no-repeat; // Not yet supported, recommended to include in case support is added later to prevent style display anomalies
  }
</style>
Effect


background-repeat Property (Not yet implemented)
This property defines how the background image is repeated within the component. The background image can be repeated along the horizontal axis, vertical axis, both axes, or not repeated.

The number of parameters is one.

The list of valid parameters is as follows:

Parameter	Description
repeat	Repeats the image both horizontally and vertically.
repeat-x	Repeats the image only horizontally.
repeat-y	Repeats the image only vertically.
no-repeat	Does not repeat the image.
Invalid parameters are interpreted as the default value, i.e., repeat.

Example

<div class="container">
  <div class="img"></div>
</div>

<style>
  .container {
    width: 365px;
    height: 365px;
    background-color: #c7c7c7;
  }
  .img {
    width: 100%;
    height: 100%;
    background-image: url('../common/logo.png');
    /* Proportionally scales the background image to half the width of the component */
    background-size: 50%;
    /* Repeats the image both horizontally and vertically */
    background-repeat: repeat;
    /* Centers the background image within the component */
    background-position: center;
  }
</style>
.img {
  width: 100%;
  height: 100%;
  background-image: url('../common/logo.png');
  /* Proportionally scales the background image to a width of 100px */
  background-size: 100px;
  /* Does not repeat the background image */
  background-repeat: no-repeat;
  /* Positions the background image 20px from the left edge of the component and at a 3:7 ratio from the top and bottom edges */
  background-position: left 20px top 30%;
}
background-position Property
This property defines the position of the background image within the component.

It can be defined using 1-4 values. If two non-keyword values are used, the first value represents the horizontal position, and the second value represents the vertical position. If only one value is specified, the second value defaults to center. If three or four values are used, the length percentage values are offsets from the preceding keyword values.

Syntax with one value:

The value can be:

The keyword center, used to center the background image.
One of the keywords top, left, bottom, right, used to specify which boundary to place the background image against. The other dimension is set to 50%, so the background image is centered in that dimension.
<length> or <percentage>, specifying the x-coordinate relative to the left boundary. The y-coordinate is set to 50%, centering the background image along the y-axis.
Syntax with two values:

One defines the x-coordinate, and the other defines the y-coordinate. Each value can be:

One of the keywords top, left, bottom, right. If left or right is given here, this value defines the x-axis position, and the other value defines the y-axis position. If top or bottom is given here, this value defines the y-axis position, and the other value defines the x-axis position.
<length> or <percentage>. If the other value is left or right, this value defines the y relative to the top boundary. If the other value is top or bottom, this value defines the x relative to the left boundary. If both values are <length> or <percentage> values, the first defines X, and the second defines Y.
Note: If one value is top or bottom, the other value cannot be top or bottom. If one value is left or right, the other value cannot be left or right. That is, for example, top top and left right are invalid.

Ordering: When pairing keywords, the position does not matter; writing top left or left top produces the same effect. When pairing <length> or <percentage> with a keyword, the order is important; the value defining X is placed first, followed by the value defining Y. right 20px and 20px right have different effects; the former is valid, but the latter is not. left 20% or 20% bottom are valid because the X and Y values are clearly defined and in the correct position.

Default values are left top or 0% 0%.

Syntax with three values:

Two values are keyword values, and the third is an offset from the preceding values:

The first value is one of the keywords top, left, bottom, right, or center. If set to left or right, X is defined. If set to top or bottom, Y is defined, and the other keyword value defines X.
<length> or <percentage>, if the second value, is an offset from the first value. If the third value, is an offset from the second value.
A single length or percentage value is an offset from its preceding keyword value. A combination of one keyword with two <length> or <percentage> values is invalid.
Syntax with four values:

The first and third values are keyword values defining X and Y. The second and fourth values are offsets from the preceding X and Y keyword values:

The first and third values are one of the keyword values top, left, bottom, right. If set to left or right, X is defined. If set to top or bottom, Y is defined, and the other keyword value defines X.
The second and fourth values are <length> or <percentage>. The second value is an offset from the first keyword. The fourth value is an offset from the second keyword.
Invalid parameters are all interpreted as the default value (0px, 0px), i.e., the image is displayed in the top-left corner of the component.

Example

<template>
  <div class="page">
    <text>Image size 128 * 128</text>
    <text>Background container 300 * 200</text>
    <image src= "../../common/logo.png">
    <div class="imgBg"></div>
  </div>
</template>
<style>
  .page {
    flex-direction: column;
    align-items: center;
    background-color: #000;
  }
  text {
    color: #fff;
    font-size: 24px;
  }
  .imgBg {
    width: 300px;
    height: 200px;
    margin-top: 20px;
    border: 2px solid yellowgreen;
    background-color: yellowgreen;
    background-image: url('../../common/logo.png');
    background-size: cover;
    background-position: right bottom;
    background-repeat: no-repeat; // Not yet supported, recommended to include in case support is added later to prevent style display anomalies
  }
</style>
Effect


Support Details
Device Product	Description
Xiaomi S1 Pro Sports Health Watch	Not supported
Xiaomi Band 8 Pro	Not supported
Xiaomi Band 9 / 9 Pro	Not supported
Xiaomi Watch S3	Not supported
Redmi Watch 4	Not supported
Xiaomi Wrist ECG Blood Pressure Monitor	Not supported
Xiaomi Band 10	Supported
Xiaomi Watch S4	Supported
REDMI Watch 5	Supported

Common Attributes
Common attributes are those supported by all components.

Developers can use common attributes on all component tags.

Sample Code
<template>
  <div>
      <text id="text1" class="text-normal">line 1</text>
      <text id="text2" class="text-normal red">line 2</text>
  </div>
</template>

Common Attributes
Name	Type	Default Value	Description
id	<string>	-	Unique ID
style	<string>	-	Style declaration
class	<string>	-	Reference to a style sheet
Rendering Attributes
Name	Type	Default Value	Description
for	<array>	-	Expands the current tag cyclically based on a data list
if	<boolean>	-	Adds or removes the current tag based on a data boolean value
show	<boolean>	-	Shows or hides the current tag based on a data boolean value, which is equivalent to controlling { display: flex | none }
For details about how rendering attributes work, see template.

Note

Attributes and styles cannot be mixed. Do not set styles in the attribute field.

data Attributes
Bind data attributes to components and then obtain them through dataset during runtime for further judgment.

Example:

<template>
  <div>
    <div id="elNode1" data-person-name="Jack"></div>
  </div>
</template>

<script>
  export default {
    onReady () {
      const el = this.$element('elNode1')
      const elData = el.dataset.personName
      console.info(`Output data attribute: ${elData}`)
    }
  }
</script>


Common Events
Common events are the event callbacks supported by all components.

Developers can register callback events on component tags using on{eventName} (e.g., onclick) or @{eventName} (e.g., @click).

For more detailed explanations, refer to the Event Binding documentation.

Example Code
<template>
  <div>
      <text onclick="clickFunction1">line 1</text>
      <text @click="clickFunction2">line 2</text>
  </div>
</template>
List of Common Events
Name	Parameters	Description	Bubbling
touchstart	TouchEvent	Triggered when a finger first touches the component	Supported
touchmove	TouchEvent	Triggered when a finger moves after touching the component	Supported
touchend	TouchEvent	Triggered when a finger ends the touch action	Supported
click	MouseEvent	Triggered when the component is clicked	Supported
longpress	MouseEvent	Triggered when the component is long-pressed	Supported
swipe	{ direction: <"left" | "right" | "up" | "down"> }	Triggered after a quick swipe on the component (not triggered when there is a scrollbar in the swipe direction)
Parameter description:
left: swipe left;
right: swipe right;
up: swipe up;
down: swipe down;	Not Supported
Event Objects
1. TouchEvent Type Description:
Property	Type	Description
touches	TouchList	Touch event, an array of touch point information currently on the screen
changedTouches	TouchList	Touch event, an array of changed touch point information. The data format of changedTouches is the same as touches, representing the changed touch points, such as from none to present (touchstart), position change (touchmove), from present to none (touchend),
For example, when the user's finger leaves the screen, there is no data in the touches array, while changedtouches will save the data before leaving
Where, TouchList is a collection of Touch objects.

2. Touch Type Description
Property	Type	Description
identifier	number	The identifier of the touch point. For multi-point simultaneous touch, it is [0,1,2,3,...], representing the first finger, second finger...
During a touch action (from finger press to finger release), this identifier remains unchanged and can be used to determine if it is the same touch process
clientX	number	The X-axis coordinate from the left edge of the visible area, excluding any scroll offset
clientY	number	The Y-axis coordinate from the top edge of the visible area, excluding any scroll offset and the height of the status bar and titlebar
pageX	number	The X-axis coordinate from the left edge of the visible area, including any scroll offset
pageY	number	The Y-axis coordinate from the top edge of the visible area, including any scroll offset. (Excluding the height of the status bar and titlebar)
offsetX	number	The distance from the left edge of the event trigger object along the X-axis
offsetY	number	The distance from the top edge of the event trigger object along the Y-axis
3. MouseEvent Type Description
Property	Type	Description
clientX	number	The X-axis coordinate from the left edge of the visible area, excluding any scroll offset
clientY	number	The Y-axis coordinate from the top edge of the visible area, excluding any scroll offset and the height of the status bar and titlebar
pageX	number	The X-axis coordinate from the left edge of the visible area, including any scroll offset
pageY	number	The Y-axis coordinate from the top edge of the visible area, including any scroll offset. (Excluding the height of the status bar and titlebar)
offsetX	number	The distance from the left edge of the event trigger object along the X-axis
offsetY	number	The distance from the top edge of the event trigger object along the Y-axis
Example
Below, click and touchmove events are bound to a div, and the events are printed when triggered.

<template>
  <div class="root-page">
    <div class="touch-region" onclick="click" ontouchmove="move"></div>
  </div>
</template>

<style>
  .root-page {
    flex-direction: column;
    align-items: center;
  }

  .touch-region {
    width: 80%;
    height: 20%;
    background-color: #444444;
  }

</style>

<script>
  export default {
    private: {},
    click(event) {
      console.log("click event fired")
    },
    move(event) {
      console.log("move event touches:" + JSON.stringify(event.touches))
      console.log("move event changedTouches:" + JSON.stringify(event.changedTouches))
    }
  }

</script>
The printed results are as follows, for the click event:

move event touches:[
  {
    "offsetX": 296,
    "identifier": 0,
    "offsetY": 113.48148345947266,
    "clientY": 113.48148345947266,
    "clientX": 360,
    "pageY": 113.48148345947266,
    "pageX": 360
  }
]
move event changedTouches:[
  {
    "offsetX": 296,
    "identifier": 0,
    "offsetY": 113.48148345947266,
    "clientY": 113.48148345947266,
    "clientX": 360,
    "pageY": 113.48148345947266,
    "pageX": 360
  }
]
click event fired



Common Methods
Common methods are methods that can be called by all components. After a component marks the id attribute with an id, the developer can obtain the dom node via this.$element('idName') and then call the common methods.

The dom object obtained through this.$element provides two APIs for calling:

getBoundingClientRect(Object object)2+
Returns the size of the element and its position relative to the viewport. It must be called after the onShow lifecycle of the page.

Parameters
Object object

Property	Type	Default Value	Required	Description
success	function		No	Callback function for successful API calls
fail	function		No	Callback function for failed API calls
complete	function		No	Callback function for completed API calls (executed for both success and failure)
Description of object.success callback function parameters
Object rect

Property	Type	Description
left	number	Left boundary coordinate of the element
right	number	Right boundary coordinate of the element
top	number	Top boundary coordinate of the element
bottom	number	Bottom boundary coordinate of the element
width	number	Width of the element
height	number	Height of the element
Code Example
<template>
  <div>
    <div id="box1" class="box-normal"></div>
    <div id="box2" class="box-normal"></div>
  </div>
</template>
<script>
  export default {
    onShow(){
      this.$element('box1').getBoundingClientRect({
        success: function(data) {
          const { top, bottom, left, right, width, height } = data;
          console.log(data);
        },
        fail: (errorData, errorCode) => {
          console.log(`Error reason: ${JSON.stringify(errorData)}, Error code: ${errorCode}`)
        },
        complete: function() {
          console.info('complete')
        }
      })
    }
  }
</script>
focus(Object object)
A method to make a component gain or lose focus.

Parameters
Property	Type	Default Value	Required	Description
focus	boolean	true	No	Makes the component gain or lose focus. Focusing can trigger the focus pseudo-class effect (the focus pseudo-class style is not yet supported)
Code Example
<script>
  // Focus effect
  this.$element('box1').focus();
  // Focus effect
  this.$element('box2').focus({focus:true});
  // Blur effect
  this.$element('box3').focus({focus:false});
</script>

Container Component
In general, it refers to components that can contain child components.

div
list
list-item
scroll
stack
swiper



div
Overview
Basic container used as the root node of the page structure or to group content.

Child Components
Supported

Attributes
Supports general attributes

Style
Supports general style

Events
Supports general events

Example Code
<template>
  <div class="page">
    <div style="flex-direction: row;">
      <text class="item color-1">1</text>
      <text class="item color-2">2</text>
      <text class="item color-3">3</text>
    </div>
  </div>
</template>
<style>
  .page {
    margin: 20px;
    flex-direction: column;
    background-color: white;
  }

  .item {
    height: 100px;
    width: 100px;
    text-align: center;
    margin-right: 10px;
  }
  
  .color-1 {
    background-color: #09ba07;
  }
  
  .color-2 {
    background-color: #f76160;
  }
  
  .color-3 {
    background-color: #0faeff;
  }
</style>


list
Overview
A list view container that contains a series of list items with the same structure and presents similar data in a continuous, multiline format.

Child Components
Only supports <list-item>

Attributes
Supports universal attributes

Name	Type	Default Value	Required	Description
bounces	<boolean>	false	No	Whether to bounce at the boundary
Styles
Supports universal styles

You need to explicitly set the height when using it.

Events
Supports universal events

Name	Parameters	Description
scroll	{scrollX: <number>, scrollY: <number>, scrollState: <stateValue>}	List scrolling;
Description of stateValue values:
0: List stops scrolling
1: List is scrolling via user gesture
2: List is scrolling, user has released hand
scrollbottom	-	List scrolls to the bottom
scrolltop	-	List scrolls to the top
scrollend	-	List scrolling ends
scrolltouchup	-	Finger lifts during list scrolling
Example Code
<template>
  <div class="page">
    <list class="list" bounces="true" 
      onscroll="onScroll" 
      onscrolltop="onScrollTop" 
      onscrollbottom="onScrollBottom"
      onscrolltouchup="onScrollTouchup">
      <list-item for="{{productList}}" class="item" type="item">
        <text>{{$item.name}}: {{$item.price}}</text>
      </list-item>
    </list>
  </div>
</template>

<script>
  export default {
    private: {
      productList: [
        { name: 'Clothes', price: '100' },
        { name: 'Pants', price: '200' },
        { name: 'Shoes', price: '300' },
        { name: 'Hat', price: '60' },
        { name: 'Umbrella', price: '300' },
        { name: 'Backpack', price: '60' },
        { name: 'Book', price: '30' }
      ],
    },
    onScroll(e) {
      console.log('### list onScroll evt: ', e)
    },
    onScrollTop(e) {
      console.log('### list onScrollTop evt: ', e)
    },
    onScrollBottom(e) {
      console.log('### list onScrollBottom evt: ', e)
    },
    onScrollTouchup(e) {
      console.log('### list onScrollTouchup evt: ', e)
    }
  }
</script>

<style>
  .page {
    justify-content: center;
    align-items: center;
    background-color: #000;
  }

  .list {
    width: 300px;
    height: 200px;
    border: 1px solid #fff;
  }

  text {
   color: #fff;
  }
  .item {
    height: 40px;
    width: 100%;
    align-items: center;
    justify-content: center;
    border: 1px solid #fff;
  }
</style>
Effect Display


Methods
Name	Parameters	Description
scrollTo	Object	Scrolls the list to the specified item position
scrollBy	Object	Scrolls the list content by a certain distance
Parameter description for scrollTo:

Name	Type	Default Value	Required	Description
index	number	0	No	Target item position for list scrolling
behavior	smooth / instant / auto	auto	No	Whether to scroll smoothly. Supported parameters: smooth (smooth scrolling), instant (instant scrolling). The default value is auto, which has the same effect as instant
Parameter description for scrollBy:

Name	Type	Default Value	Required	Description
left	number	0	No	Horizontal scrolling distance from the current position, in px. A positive value scrolls left, and a negative value scrolls right. Does not take effect when flex-direction is column or column-reverse
top	number	0	No	Vertical scrolling distance from the current position, in px. A positive value scrolls up, and a negative value scrolls down. Does not take effect when flex-direction is row or row-reverse
behavior	smooth / instant / auto	auto	No	Whether to scroll smoothly. Supported parameters: smooth (smooth scrolling), instant (instant scrolling). The default value is auto, which has the same effect as instant


list-item
Overview
The subcomponent of <list>, used to display specific items in a list. It fills the width of the list component by default.

Subcomponents
Supported

Attributes
Common attributes are supported.

Name	Type	Default Value	Required	Description
type	<string>	-	Yes	The type of list-item, defined as a custom string, such as 'loadMore'. List-items with the same type must have identical DOM structures. Therefore, use if and for with caution inside list-items, as they may cause DOM structure inconsistencies for list-items of the same type, leading to errors.
Styles
Common styles are supported.

To achieve component reuse and optimize performance, explicitly specify the width and height.

Events
Common events are supported.

Example Code
<template>
  <div class="page">
    <list class="list">
      <list-item for="{{productList}}" class="item" type="list-item">
        <text>{{$item.name}}: {{$item.price}}</text>
      </list-item>
    </list>
  </div>
</template>

<script>
  export default {
    data: {
      productList: [
        { name: 'Clothes', price: '100' },
        { name: 'Pants', price: '200' }
      ],
    }
  }
</script>

<style>
  .page {
    padding: 30px;
    background-color: white;
  }

  .list {
    width: 100%;
    height: 100%;
  }

  .item {
    height: 40px;
  }
</style>
Display Effect


scroll2+
Overview
Scroll view container. A vertical or horizontal scroll container. Vertical scrolling requires a fixed height, and horizontal scrolling requires a fixed width.

Child Components
Supported. Nested child scroll components are also supported.

Attributes
Supports Common Attributes

Name	Type	Default	Required	Description
scroll-x	<boolean>	false	No	Whether to allow horizontal scrolling
scroll-y	<boolean>	false	No	Whether to allow vertical scrolling
scroll-top	<number> | <string>		No	Sets the vertical scroll bar position, the distance from the top of the content to the top of the scroll. If there is a scroll snap effect, it will scroll first and then snap.
scroll-bottom	<number> | <string>		No	Sets the vertical scroll bar position, the distance from the bottom of the content to the bottom of the scroll. If there is a scroll snap effect, it will scroll first and then snap. If both scroll-top and scroll-bottom are set, scroll-top takes precedence.
scroll-left	<number> | <string>		No	Sets the horizontal scroll bar position, the distance from the left side of the content to the left side of the scroll. If there is a scroll snap effect, it will scroll first and then snap.
scroll-right	<number> | <string>		No	Sets the horizontal scroll bar position, the distance from the right side of the content to the right side of the scroll. If there is a scroll snap effect, it will scroll first and then snap. If both scroll-left and scroll-right are set, scroll-left takes precedence.
bounces	<boolean>	false	No	Whether to enable boundary rebound
Styles
Supports Common Styles

Name	Type	Default	Description
scroll-snap-type3+	-	none	Used in conjunction with scroll-snap-align, applied to the scroll component, indicating the scroll snap type. The first parameter is x or y, indicating horizontal or vertical scrolling; the second parameter is mandatory, proximity, or cross. mandatory: snaps to the nearest anchor; proximity: snaps only when the distance to the snap anchor is less than 30% of the container height; cross: snaps only when the child component's boundary that can be snapped appears in the scroll viewport. Default is proximity
Minimum aiot-toolkit version: 1.1.4
scroll-snap-align3+	none | start | center | end | edge	none	Used in conjunction with scroll-snap-type, applied to the scroll child component, indicating the alignment form between the child component and the scroll. none: no alignment, default value; start: aligns the component with the start edge of the scroll; center: aligns the component with the center of the scroll; end: aligns the component with the end edge of the scroll; edge: in the scrolling direction, aligns the component with the start or end edge of the scroll
Minimum aiot-toolkit version: 1.1.4
scroll-snap-stop3+	normal | always	normal	When set to always, cannot skip elements during snapping
Minimum aiot-toolkit version: 1.1.4
Example Code
scroll-snap-type & scroll-snap-align
<template>
  <div class="page">
    <div class="scroll-container">
      <scroll class="box" scroll-x="true" style="scroll-snap-type: x proximity;">
        <text class="scroll-item color-1">A</text>
        <text class="scroll-item color-2">B</text>
        <text class="scroll-item color-1" style="scroll-snap-align: start;">C</text>
        <text class="scroll-item color-2">D</text>
        <text class="scroll-item color-1" style="scroll-snap-align: center;">E</text>
        <text class="scroll-item color-2">F</text>
        <text class="scroll-item color-1" style="scroll-snap-align: end;">G</text>
        <text class="scroll-item color-2">H</text>
      </scroll>
    </div>
  </div>
</template>

<script>
  export default {}
</script>

<style>
  .page {
    padding: 60px;
    flex-direction: column;
  }

  .scroll-container {
    width: 100%;
  }

  .box {
    margin-bottom: 30px;
    height: 100px;
    width: 200px;
  }

  .scroll-item {
    width: 80%;
    height: 100px;
    text-align: center;
  }

  .color-1 {
    background-color: cadetblue;
  }

  .color-2 {
    background-color: orangered;
  }
</style>


scroll-snap-stop
<template>
  <div class="page">
    <div class="scroll-container">
      <scroll class="box" scroll-x="true" style="scroll-snap-type: x cross;scroll-snap-stop:always;">
        <text class="scroll-item color-1">A</text>
        <text class="scroll-item color-2" style="scroll-snap-align: center;">B</text>
        <text class="scroll-item color-1" style="scroll-snap-align: center;">C</text>
        <text class="scroll-item color-2" style="scroll-snap-align: center;">D</text>
        <text class="scroll-item color-1" style="scroll-snap-align: center;">E</text>
        <text class="scroll-item color-2" style="scroll-snap-align: center;">F</text>
        <text class="scroll-item color-1">G</text>
      </scroll>
    </div>
  </div>
</template>

<script>
  export default {}
</script>

<style>
  .page {
    padding: 60px;
    flex-direction: column;
  }

  .scroll-container {
    width: 100%;
  }

  .box {
    margin-bottom: 30px;
    height: 100px;
    width: 200px;
  }

  .scroll-item {
    width: 80%;
    height: 100px;
    text-align: center;
  }

  .color-1 {
    background-color: cadetblue;
  }

  .color-2 {
    background-color: orangered;
  }
</style>


Events
Name	Parameters	Description
scrolltop	-	Triggered when scrolling to the top
scrollbottom	-	Triggered when scrolling to the bottom
scroll	{ scrollX, scrollY }	Triggered when scrolling, scrollX represents the horizontal distance scrolled; scrollY represents the vertical distance scrolled
Methods
Name	Parameters	Return Value	Description
getScrollRect	None	<object>	Gets the dimensions of the scrollable content
scrollTo	Object	None	Scrolls the scroll component window to a specific coordinate position
scrollBy	Object	None	Scrolls the scroll component window by a certain distance
scrollTo Method Object Parameters
Name	Type	Default	Required	Description
left	number	-	No	The horizontal coordinate value of the scroll component. If not provided, no horizontal scrolling occurs. Negative values are treated as 0. Values beyond the scroll range are treated as the scroll boundary.
top	number	-	No	The vertical coordinate value of the scroll component. If not provided, no vertical scrolling occurs. Negative values are treated as 0. Values beyond the scroll range are treated as the scroll boundary.
behavior	smooth / instant / auto	auto	No	The scrolling behavior. smooth-smooth scrolling, instant-instant scrolling, auto-same as instant
scrollBy Method Object Parameters
Name	Type	Default	Required	Description
left	number	-	No	The horizontal offset of the scroll component. Can be negative. Values beyond the scroll range are treated as the scroll boundary.
top	number	-	No	The vertical offset of the scroll component. Can be negative. Values beyond the scroll range are treated as the scroll boundary.
behavior	smooth / instant / auto	auto	No	The scrolling behavior. smooth-smooth scrolling, instant-instant scrolling, auto-same as instant
Return Value (Asynchronous)
Property	Type	Description
width	<number>	The width of the scrollable content, including border and padding
height	<number>	The height of the scrollable content, including border and padding
Example Code
<template>
  <div class="page">
      <scroll id="scrollId" scroll-y="true" onscrolltop="handleScrollTop">
          <div class="item">
             <text>Beijing</text>
          </div>
          <div class="item">
             <text>Shanghai</text>
          </div>
          <div class="item">
             <text>Guangzhou</text>
          </div>
          <div class="item">
             <text>Shenzhen</text>
          </div>
       </scroll>
  </div>
</template>

<script>
  export default {
    onShow() {
      this.$element('scrollId').getScrollRect({
        success({ width, height }) {
          console.log('Width', width);
          console.log('Height', height);  
        }
      })

      // this.scrollTo()
      // this.scrollBy()
    },
    handleScrollTop() {
      console.info('Scrolled to top.')
    },
    scrollTo() {
      this.$element('scrollId').scrollTo({
        top: 1000,
        left: 0,
        behavior: 'smooth'
      })
    },
    scrollBy() {
      this.$element('scrollId').scrollBy({
        top: 1000,
        left: 0,
        behavior: 'smooth'
      })
    }
  }
</script>
<style>
  .page {
    justify-content: center;
    align-items: center;
  }

  #scrollId {
    width: 50%;
    height: 100px;
    flex-direction: column;
    background-color: yellowgreen;
  }

  .item {
    width: 100%;
    height: 50px;
    justify-content: center;
  }
</style>


stack
Overview
A basic container that stacks its direct child components in a layered manner, with each subsequent child component covering the previous one.

Child Components
Supported

Properties
Supports general properties

Styles
Supports general styles

Events
Supports general events

Example Code
<template>
  <div class="page">
    <stack class="stack">
      <div class="box box1"></div>
      <div class="box box2"></div>
      <div class="box box3"></div>
      <div class="box box4"></div>
    </stack>
  </div>
</template>

<style>
  .page {
    padding: 30px;
    background-color: white;
  }

  .box {
    border-radius: 8px;
    width: 100px;
    height: 100px;
  }

  .box1 {
    width: 200px;
    height: 200px;
    background-color: #3f56ea;
  }

  .box2 {
    left: 20px;
    top: 20px;
    background-color: #00bfc9;
  }

  .box3 {
    left: 50px;
    top: 50px;
    background-color: #47cc47;
  }

  .box4 {
    left: 80px;
    top: 80px;
    background-color: #FF6A00;
  }
</style>



stack
Overview
A basic container that stacks its direct child components in a layered manner, with each subsequent child component covering the previous one.

Child Components
Supported

Properties
Supports general properties

Styles
Supports general styles

Events
Supports general events

Example Code
<template>
  <div class="page">
    <stack class="stack">
      <div class="box box1"></div>
      <div class="box box2"></div>
      <div class="box box3"></div>
      <div class="box box4"></div>
    </stack>
  </div>
</template>

<style>
  .page {
    padding: 30px;
    background-color: white;
  }

  .box {
    border-radius: 8px;
    width: 100px;
    height: 100px;
  }

  .box1 {
    width: 200px;
    height: 200px;
    background-color: #3f56ea;
  }

  .box2 {
    left: 20px;
    top: 20px;
    background-color: #00bfc9;
  }

  .box3 {
    left: 50px;
    top: 50px;
    background-color: #47cc47;
  }

  .box4 {
    left: 80px;
    top: 80px;
    background-color: #FF6A00;
  }
</style>



stack
Overview
A basic container that stacks its direct child components in a layered manner, with each subsequent child component covering the previous one.

Child Components
Supported

Properties
Supports general properties

Styles
Supports general styles

Events
Supports general events

Example Code
<template>
  <div class="page">
    <stack class="stack">
      <div class="box box1"></div>
      <div class="box box2"></div>
      <div class="box box3"></div>
      <div class="box box4"></div>
    </stack>
  </div>
</template>

<style>
  .page {
    padding: 30px;
    background-color: white;
  }

  .box {
    border-radius: 8px;
    width: 100px;
    height: 100px;
  }

  .box1 {
    width: 200px;
    height: 200px;
    background-color: #3f56ea;
  }

  .box2 {
    left: 20px;
    top: 20px;
    background-color: #00bfc9;
  }

  .box3 {
    left: 50px;
    top: 50px;
    background-color: #47cc47;
  }

  .box4 {
    left: 80px;
    top: 80px;
    background-color: #FF6A00;
  }
</style>


swiper
Overview
Slider view container.

Child Components
Supported.

Attributes
Supports Universal Attributes.

Name	Type	Default	Required	Description
index	<number>	0	No	Index of the currently displayed child component
autoplay	<boolean>	false	No	Whether to automatically play after rendering
interval	<number>	3000ms	No	Time interval for autoplay, in milliseconds
indicator	<boolean>	true	No	Whether to enable the indicator, default true
loop	<boolean>	true	No	Whether to enable loop mode
duration	<number>	-	No	Slide animation duration (duration is dynamically calculated based on finger speed by default)
vertical	<boolean>	false	No	Whether the slide direction is vertical, and the indicator is also vertical when it is
previousmargin	<string>	0px	No	Front margin, can be used to expose a small part of the previous item, supports units: px and %
nextmargin	<string>	0px	No	Rear margin, can be used to expose a small part of the next item, supports units: px and %
enableswipe	<boolean>	true	No	Whether to support gesture swiping on the swiper
Note: The sum of previousmargin and nextmargin should not exceed 1/2 of the entire swiper size, and any excess will be truncated.

Styles
Supports Universal Styles.

Name	Type	Default	Required	Description
indicator-color	<color>	rgba(0, 0, 0, 0.5)	No	Indicator fill color
indicator-selected-color	<color>	#33b4ff or rgb(51, 180, 255)	No	Indicator color when selected
indicator-size	<length>	20px	No	Diameter size of the indicator component
indicator-[top|left|right|bottom]	<length> | <percentage>	-	No	Position of the indicator relative to the swiper
Events
Supports Universal Events.

Name	Parameters	Description
change	{index:currentIndex}	Triggered when the index of the currently displayed component changes
swipestart2+	{index:currentIndex}	Triggered when the child component switching animation starts (if the switching is caused by finger dragging, it refers to the time point when the finger starts pressing and dragging)
swipeend2+	{index:currentIndex}	Triggered when the child component switching animation ends
Methods
Name	Parameters	Description
swipeTo	{index: number(specified position)}	Scroll the swiper to the specified index position
Example Code
<template>
  <div class="page">
    <swiper class="swiper">
      <text class="item item-1">A</text>
      <text class="item item-2">B</text>
      <text class="item item-3">C</text>
      <text class="item item-4">D</text>
    </swiper>
    
  </div>
</template>

<style>
  .page {
    padding: 30px;
    background-color: white;
  }

  .swiper {
    width: 300px;
    height: 160px;
    indicator-size: 10px;
  }

  .item {
    text-align: center;
    color: white;
    font-size: 30px;
  }

  .item-1 {
    background-color: #3f56ea;
  }

  .item-2 {
    background-color: #00bfc9;
  }

  .item-3 {
    background-color: #47cc47;
  }

  .item-4 {
    background-color: #FF6A00;
  }
</style>




Basic Components
Components on a page, such as text and images.

text
span
a
image
image-animator
progress
marquee
chart
qrcode
barcode



text
Overview
The text content is written in the label content area, supporting escape characters "\".

Child Components
Only <span> is supported.

Attributes
General attributes are supported.

Styles
General styles are supported.

Name	Type	Default Value	Required	Description
lines	<number>	-1	No	Number of text lines, -1 means unlimited lines.
color	<color>	rgba(0, 0, 0, 0.54)	No	Text color.
font-size	<length>	30px	No	Text size.
font-style	normal | italic	normal	No	
font-weight	normal | bold | <number>	normal	No	The current platform only supports two effects: normal and bold. When the value is a number, if it is below 550, it is the former; otherwise, it is the latter.
text-decoration	underline | line-through | none	none	No	
text-align	left | center | right	left	No	
text-indent	<length> | <percentage>	-	No	Specifies the indentation of the first line of the text block.
line-height	<length>	-	No	Text line height.
text-overflow	clip | ellipsis	clip	No	Takes effect when the number of lines is set.
Examples

Single-line ellipsis

text {
  width: 150px;
  lines: 1;
  text-overflow: ellipsis;
}


Multi-line ellipsis, taking two lines as an example

text {
  width: 100px;
  lines: 2;
  text-overflow: ellipsis;
}


Events
General events are supported.

Sample Code
<template>
  <div>
    <text>This is a piece of text.</text>
  </div>
</template>



span
Overview
Formatted text, which can only be used as a subcomponent of <text>, <a>, and <span>.

Subcomponents
Only <span> is supported.

Attributes
Name	Type	Default Value	Required	Description
id	<string>	-	No	Unique identifier
style	<string>	-	No	Style declaration
class	<string>	-	No	Reference stylesheet
for	<array>	-	No	Loop through the current tag based on the data list
if	<boolean>	-	No	Add or remove the current tag based on the data boolean value
Styles
Name	Type	Default Value	Required	Description
color	<color>	rgba(0, 0, 0, 0.54)	No	Text color
font-size	<length>	30px	No	Text size
font-style	normal | italic	normal	No	-
font-weight	normal | bold | <number>	normal	No	The current platform only supports normal and bold effects. When the value is a number, values below 550 are considered as the former, otherwise as the latter.
text-decoration	underline | line-through | none	none	No	-
Events
Not supported.

Example Code
<template>
  <div>
    <text>
      <span>I am span,</span>
      <span style="color: #f76160">I am span,</span>
      <span style="color: #f76160;text-decoration: underline;">I am span,</span>
    </text>
  </div>
</template>


a
Overview
Hyperlink (no underline by default)

Child Components
Only <span> is supported.

Attributes
Supports universal attributes

Name	Type	Default Value	Required	Description
href	string	-	No	For supported formats, see the uri parameter in page routing.
Additional:
href can also add parameters in the format of "?param1=value1", and the parameters can be used in the page via this.param1. When using the this.param1 variable, you need to define a property with the same key name under public (passing parameters outside the app) or protected (passing parameters inside the app) in the target page.
Example:
<a href="/about?param1=value1">About</a>
Styles
Supports text styles

Supports universal styles

Events
Supports universal events

Example Code
<template>
  <div>
    <a class="link" href="/home">goHome</a>
    <a href="/home">
      <span class="link">Using span child component</span>
    </a>
  </div>
</template>



image
Overview
Render images.

Subcomponents
Not supported.

Attributes
Supports General Attributes.

Name	Type	Default Value	Required	Description
src	<uri>	-	No	URI of the image, supporting both local and cloud paths. Supported image formats include png and jpg.
alt	<uri> | 'blank'	-	No	Placeholder image displayed during loading; only supports local image resources.
Note: Details about the alt attribute are as follows:

If the alt value is not set for the Image component, the terminal will add a default gray placeholder image.

When src is a local image address, there will be no placeholder image.

When src is a remote image address, if the image has been successfully loaded before and cached locally, there will be no placeholder image.

When src is a remote image address and the alt value of the Image component is set to the string "blank", there will be no placeholder image (this can avoid the instant flickering of small icons from remote addresses during the first load).

When alt is set to a local image address, the placeholder image scaling mode is changed from center-no-scaling to center-keep-aspect-ratio scaling, reducing the resolution and size of the placeholder image resource file.

Note: The scaling mode can be configured through the style value object-fit, with a default value of cover (center-keep-aspect-ratio scaling). For details, see the Style section.

Style
Supports General Styles.

Name	Type	Default Value	Required	Description
object-fit	contain | cover | none | scale-down	cover	No	Scaling type of the image.
Note:

The object-fit parameter list is as follows:
Type	Description
contain	Maintains aspect ratio, scales down or up so that the image is fully displayed within the display boundary, centered.
cover	Maintains aspect ratio, scales down or up so that both sides are greater than or equal to the display boundary, centered.
none	Centers without scaling.
scale-down	Maintains aspect ratio, scales down or remains unchanged, takes the smaller display between contain and none, centered.
Events
Supports General Events.

Name	Parameters	Description
complete	{width: widthValue(px), height: heightValue(px)}	Triggered when the image is fully loaded.
error	-	Triggered when the image fails to load.
Sample Code
<template>
  <div>
    <image src="/common/logo.png" />
  </div>
</template>


image-animator2+
Overview
Image frame animation player.

Subcomponents
Not supported

Attributes
Common attributes are supported.

Name	Type	Default Value	Mandatory	Description
images	Array<ImageFrame>	-	Yes	Sets the collection of image frame information. The frame information of each frame includes the image path, image size, and image position information.
iteration	<number>|<string>	infinite	No	Sets the number of frame animation playbacks. number indicates a fixed number of times, and the infinite enumeration indicates infinite playbacks.
reverse	<boolean>	false	No	Sets the playback sequence. false indicates that the playback starts from the first image to the last image; true indicates that the playback starts from the last image to the first image.
fixedsize	<boolean>	true	No	Sets whether the image size is fixed to the component size. true indicates that the image size is the same as the component size. In this case, the width, height, top, and left attributes of the image are invalid. false indicates that the width, height, top, and left attributes of each image must be set separately.
duration	<string>	-	No	Sets the duration of a single playback. The unit supports [s(second)|ms(millisecond)], and the default unit is ms.
fillmode	<string>	forwards	No	Specifies the state of the frame animation after the execution is complete. The options are as follows:
none: restores to the initial state.
forwards: maintains the state of the frame animation at the end (defined in the last keyframe).
Description of ImageFrame

Name	Type	Default Value	Mandatory	Description
src	<uri>	-	Yes	Image path
width	<length>	0	No	Image width
height	<length>	0	No	Image height
top	<length>	0	No	Vertical coordinate of the image relative to the upper left corner of the component
left	<length>	0	No	Horizontal coordinate of the image relative to the upper left corner of the component
Styles
Common styles are supported.

Methods
Common methods are supported.

Name	Parameters	Description
start	-	Starts playing the image frame animation. If this method is called again, the playback starts from the first frame.
pause	-	Pauses the image frame animation.
stop	-	Stops the image frame animation.
resume	-	Continues to play the image frame.
getState	-	Obtains the playback status. The options are as follows:
- playing: being played
- paused: paused
- stopped: stopped
Example Code
<template>
  <div class="container">
  <image-animator class="animator" id="animator" images="{{frames}}" duration="1s" />
  <div class="btn-box">
    <input class="btn" type="button" value="start" @click="handleStart" />
    <input class="btn" type="button" value="stop" @click="handleStop" />
    <input class="btn" type="button" value="pause" @click="handlePause" />
    <input class="btn" type="button" value="resume" @click="handleResume" />
  </div>
</div>
</template>
.container {
  flex-direction: column;
  justify-content: center;
  align-items: center;
  left: 0px;
  top: 0px;
  width: 454px;
  height: 454px;
  background-color: black;
}
.animator {
  width: 70px;
  height: 70px;
}
.btn-box {
  width: 264px;
  height: 120px;
  flex-wrap: wrap;
  justify-content: space-around;
  align-items: center;
}
.btn {
  border-radius: 8px;
  width: 120px;
  margin-top: 8px;
}
export default {
  data: {
    frames: [
      {
        src: "/common/asserts/001.png",
      },
      {
        src: "/common/asserts/002.png",
      },
      {
        src: "/common/asserts/003.png",
      },
      {
        src: "/common/asserts/004.png",
      },
      {
        src: "/common/asserts/005.png",
      }
    ],
  },
  handleStart() {
    this.$element('animator').start();
  },
  handlePause() {
    this.$element('animator').pause();
  },
  handleResume() {
    this.$element('animator').resume();
  },
  handleStop() {
    this.$element('animator').stop();
  },
};


progress
Overview
Progress bar

Child Components
Not supported

Attributes
Supports general attributes

Name	Type	Default Value	Required	Description
percent	<number>	0	No	-
type	horizontal | arc	horizontal	No	Progress bar type. Dynamic modification is not supported.
Styles
Supports general styles

Note: The base color of the horizontal progress bar is #f0f0f0. The height attribute is invalid.

Name	Type	Default Value	Required	Description
color	<color>	#33b4ff or rgb(51, 180, 255)	No	Progress bar color
stroke-width	<length>	32px	No	Progress bar width
layer-color	<color>	#f0f0f0 or rgb(240, 240, 240)	No	Progress bar background color
Effective when type=arc:

Name	Type	Default Value	Required	Description
start-angle	<deg>	240	No	Starting angle of the arc progress bar, with the 0 point of the clock as the baseline. The range is 0 to 360 (clockwise)
total-angle	<deg>	240	No	Total length of the arc progress bar, ranging from -360 to 360. A negative number indicates a counterclockwise direction from the start point to the end point.
center-x	<length>	Half of the component width	No	Center position of the arc progress bar (the origin is the top-left vertex of the component). This style must be used together with center-y and radius.
center-y	<length>	Half of the component height	No	Center position of the arc progress bar (the origin is the top-left vertex of the component). This style must be used together with center-x and radius.
radius	<length>	Half of the smaller value of the component width and height	No	Radius of the arc progress bar. This style must be used together with center-x and center-y.
Events
Supports general events

Example Code
<template>
  <div style="flex-direction: column">
    <progress class="p1" percent="40"></progress> 
    <progress class="p2" percent="80" type="arc"></progress>
  </div>
</template>
<style>
  .p1 {
    margin-bottom: 10px;
    stroke-width: 12px;
  }

  .p2 {
    margin-bottom: 10px;
    stroke-width: 12px;
    start-angle: 0;
    total-angle: 360deg;
  }
</style>


marquee
Overview
Marquee is used to insert a segment of scrolling text. By default, it is a single line.

Child Components
Not supported

Attributes
Common attributes are supported.

Name	Type	Default Value	Mandatory	Description
scrollamount	<number>	6	No	Sets the length of each scroll, in px.
loop	<number>	-1	No	Sets the number of times that the marquee scrolls. If this parameter is not specified, the default value is −1, indicating that the marquee scrolls continuously.
direction	<string>	left	No	Direction of text scrolling. The value can be left or right.
text-offset	<number>	-	No	Sets the distance between the end of the previous text segment and the start of the next text segment when the marquee is looped. The attribute value is an integer greater than 0, in px.
Styles
Common styles are supported.

Name	Type	Default Value	Mandatory	Description
color	<color>	rgba(0, 0, 0, 0.54)	No	Text color.
font-size	<length>	30px	No	Text size.
Events
Common events are supported.

Name	Parameter	Description
bounce	-	Triggered when the marquee scrolls to the end.
finish	-	Triggered when the marquee completes the number of times set by loop. This event is valid only when loop is greater than 0.
start	-	Triggered when the marquee starts to scroll.
Methods
Name	Parameter	Description
start	-	Starts scrolling the marquee.
stop	-	Stops scrolling the marquee.
Example Code
<template>
  <div>
    <marquee id="marquee" scrollamount={{6}} loop={{-1}}>
      scrollamount controls the scrolling speed. The default value is 6 (6 px/s).
    </marquee>
  </div>
</template>

<script>
  export default {
    onReady() {
      this.$element('marquee').start()
    }
  }
</script>


chart
Overview
A chart component used to display line charts and bar charts.

Subcomponents
Not supported

Attributes
Supports Common Attributes

Name	Type	Default Value	Required	Description
type	<string>	line	No	Sets the chart type (dynamic modification not supported). Options: bar (bar chart) \ line (line chart)
options	ChartOptions	-	Yes	Chart parameter settings. Parameters must be set for bar charts and line charts. You can set the minimum and maximum values, the number of ticks, visibility, line width, and smoothness for the x-axis and y-axis. (Dynamic modification not supported)
datasets	Array<ChartDataset>	-	Yes	Data collection. Must be set for bar charts and line charts. Multiple datasets and their background colors can be set.
ChartOptions Description
Name	Type	Default Value	Required	Description
xAxis	ChartAxis	line	Yes	x-axis parameter settings. You can set the minimum and maximum values, the number of ticks, and visibility for the x-axis.
yAxis	ChartAxis	-	Yes	y-axis parameter settings. You can set the minimum and maximum values, the number of ticks, and visibility for the y-axis.
series	ChartSeries	-	No	Data sequence parameter settings. You can set: 1) line styles, such as line width and smoothness; 2) the style and size of the white dot at the end of the line (only supported for line charts).
ChartDataset Description
Name	Type	Default Value	Required	Description
strokeColor	<color>	#ff6384	No	Line color. (Only supported for line charts)
fillColor	<color>	#ff6384	No	Fill color. For line charts, it represents the gradient fill color.
data	Array<<number>	-	Yes	Sets the points for drawing lines or bars.
gradient	<boolean>	false	No	Sets whether to display a gradient fill color. (Only supported for line charts)
ChartAxis Description
Name	Type	Default Value	Required	Description
min	<number>	0	No	Minimum value of the axis. (Negative numbers not supported. Only supported for line charts)
max	<number>	dataset data count-1	No	Maximum value of the axis. (Negative numbers not supported. Only supported for line charts)
axisTick	<number>	10	No	Number of ticks displayed on the axis. (Only supports values from 1 to 20, and the actual display depends on the calculated value (width of the chart in pixels / (max-min)). Due to integer operations in lightweight smart wearables, errors may occur when the division is not exact, resulting in a blank space at the end of the x-axis. For bar charts, the number of bars displayed per group matches the number of ticks, and the bars are displayed at the tick positions.)
display	<boolean>	false	No	Whether to display the axis.
color	<color>	#c0c0c0	No	Axis color.
ChartSeries Description
Name	Type	Default Value	Required	Description
lineStyle	ChartLineStyle	-	No	Line style settings, such as line width and smoothness.
loop	ChartLoop	-	No	Sets whether to restart drawing when the screen is full.
ChartLineStyle Description
Name	Type	Default Value	Required	Description
width	<length>	2px	No	Line width setting.
ChartLoop Description
Name	Type	Default Value	Required	Description
margin	<length>	1px	No	Number of points to erase (horizontal distance between the most recently drawn point and the oldest point). Note: On lightweight devices, when margin is used simultaneously with topPoint/bottomPoint/headPoint, there is a chance that a point may fall exactly within the erased area, making it invisible. Therefore, simultaneous use is not recommended.
Styles
Supports Common Styles

Events
Supports Common Events

Sample Code
Line Chart
<template>
  <chart type="line" options="{{lineOpts}}" datasets="{{lineData}}"></chart>
</template>

<script>
  export default {
    data: {
      lineData: [
        {
          strokeColor: '#f07826',
          data: [763, 550, 551, 554, 731, 654, 525, 696, 595, 628],
        },
        {
          strokeColor: '#cce5ff',
          fillColor: '#cce5ff', 
          data: [535, 776, 615, 444, 694, 785, 677, 609, 562, 410],
        },
        {
          strokeColor: '#ff88bb',
          data: [673, 500, 574, 483, 702, 583, 437, 506, 693, 657]
        },
      ],
      lineOpts: {
        xAxis: {
          min: 0,
          max: 10,
          display: true,
          axisTick: 10
        },
        yAxis: {
          min: 400,
          max: 900,
          display: true,
        }
      }
    }
  }
</script>


Bar Chart
<template>
  <chart type="bar" options="{{barOpts}}" datasets="{{barData}}"></chart>
</template>

<script>
  export default {
    data: {
      barData: [
        {
          fillColor: '#f07826',
          data: [763, 550, 551, 554, 731, 654, 525]
        },
        {
          fillColor: '#cce5ff',
          data: [535, 776, 615, 444, 694, 785, 677]
        }
      ],
      barOpts: {
        xAxis: {
          min: 0,
          max: 7,
          display: false,
          axisTick: 7
        },
        yAxis: {
          min: 0,
          max: 800,
          display: false,
        }
      }
    }
  }
</script>


qrcode2+
Overview
Generates and displays a QR code.

Child Components
Not supported

Attributes
Supports common attributes

Name	Type	Default Value	Required	Description
value	string	-	Yes	The content used to generate the QR code
Styles
Supports common styles

Name	Type	Default Value	Required	Description
color	<color>	#000000	No	QR code color
background-color	<color>	#ffffff	No	QR code background color
Events
Supports common events

Example Code
<template>
  <div>
    <qrcode value="https://iot.mi.com" style="color: #008cff;"></qrcode>
  </div>
</template>


barcode2+
Overview
Barcode, which converts text content into a barcode for display.

Subcomponents
Not supported

Attributes
Supports universal attributes

Name	Type	Default Value	Required	Description
value	string	-	Yes	Barcode content, using Code128 encoding, with a length of up to 20 bytes
Styles
Supports universal styles

Name	Type	Default Value	Required	Description
color	<color>	#000000	No	Barcode color
background-color	<color>	#ffffff	No	Barcode background color
Note

When setting the rotate property of transform, this component can only be rotated to a vertical or horizontal state;
When setting the scale property of transform, this component only supports integer scaling.
Events
Supports universal events

Example Code
<template>
  <div>
    <barcode value="barcodetest" style="color: #008cff;"></barcode>
  </div>
</template>



Form Components
Components used for interaction, such as submitting data, etc.

input
picker
switch
slider



input
Overview
Provide an interactive interface to receive user input.

Child Components
Not supported.

Attributes
Common attributes are supported.

Name	Type	Default Value	Required	Description
type	button | checkbox | radio |	button	No	Dynamic modification is supported.
checked	<boolean>	false	No	The checked status of the current component, which takes effect when the type is checkbox. It can trigger the checked pseudo-class (checked pseudo-class style is not supported yet).
name	<string>	-	No	The name of the input component.
value	<string>	-	No	The value of the input component.
Styles
Common styles are supported.

Name	Type	Default Value	Required	Description
color	<color>	rgba(0, 0, 0, 0.87)	No	Text color
font-size	<length>	37.5px	No	Text size
width	<length> | <percentage>	-	No	When the type is button, the default value is 128px.
height	<length> | <percentage>	-	No	When the type is button, the default value is 70px.
Events
Common events are supported.

Name	Parameters	Description
change	Different types have different parameters. For details, see the parameters of the change event below.	Triggered when the value or status of the input component changes. When the type is button, there is no change event.
Parameters of the change Event
Parameter	checkbox	radio	Remarks
name	√	√	-
value	√	√	-
checked	√	-	-
Methods
Name	Parameters	Description
focus	{focus:true|false}, if focus is not passed, the default value is true	Enable or disable the focus of the component. It can trigger the focus pseudo-class (focus pseudo-class style is not supported yet).
Example Code
<template>
  <div class="page">
    <div class="section">
      <text class="title">input-button component</text>
      <input class="button" type="button" value="Button" @click="onButtonClick" />
      <text>{{ buttonText }}</text>
    </div>
    <div class="section">
      <text class="title">input-checkbox component</text>
      <input class="checkbox" type="checkbox" checked="{{ checkboxChecked }}" @change="onCheckboxChange" />
      <text>My checked status: {{ checkboxChecked }}</text>
    </div>
    <div class="section">
      <text class="title">input-radio component</text>
      <div>
        <input class="radio" type="radio" name="radio" value="1" checked="{{radioValue === '1'}}" @change="onRadioChange" />
        <input class="radio" type="radio" name="radio" value="2" checked="{{radioValue === '2'}}" @change="onRadioChange" />
        <input class="radio" type="radio" name="radio" value="3" checked="{{radioValue === '3'}}" @change="onRadioChange" />
      </div>
      <text>Currently, the {{ radioValue }}th one is selected.</text>
    </div>
  </div>
</template>

<script>
  export default {
    private: {
      buttonText: '',
      checkboxChecked: true,
      radioValue: '1'
    },
    onTextChange(e) {
      this.textValue = e.value
    },
    onButtonClick() {
      this.buttonText = 'The button is clicked.'
    },
    onCheckboxChange(e) {
      this.checkboxChecked = e.checked
    },
    onRadioChange(e) {
      this.radioValue = e.value
    }
  }
</script>

<style>
  .page {
    flex-direction: column;
    padding: 30px;
    background-color: #ffffff;
  }

  .section {
    flex-direction: column;
    margin-bottom: 30px;
  }

  .title {
    font-weight: bold;
  }

  .button {
    width: 140px;
    height: 50px;
    font-size: 25px;
    color: white;
  }

  .checkbox, .radio {
    width: 40px;
    height: 40px;
    margin-right: 10px;
  }
</style>


picker
Overview
A scroll picker that currently supports two types of pickers: a normal picker and a time picker. The normal picker is used by default.

Child Components
Not supported

Attributes
Supports universal attributes

Normal picker

Name	Type	Default Value	Required	Description
type	text	-	Yes	Dynamic modification is not supported.
range	Array<string>	-	No	Value range of the picker
selected	<number>	0	No	Default value of the picker. The value is the index of range.
Time picker

Name	Type	Default Value	Required	Description
type	time	-	Yes	Dynamic modification is not supported.
selected	<string>	Current time	No	Default value of the picker. The format is hh:mm.
Styles
Supports universal styles

Name	Type	Default Value	Required	Description
color	<color>	Theme color	No	Font color of the candidate options
font-size	<length>	30px	No	Font size of the candidate options, in px
selected-color	<length>	#ffffff	No	Font color of the selected option
selected-font-size	<length>	20px	No	Font size of the selected option, in px
selected-background-color	<color>	-	No	Background color of the selected option
Events
Normal picker

Name	Parameters	Description
change	{newValue:newValue, newSelected:newSelected}	Triggered when the scroll picker value is confirmed after selection. (newSelected is the index.)
Time picker

Name	Parameters	Description
change	{hour:hour, minute:minute}	Triggered when the scroll picker value is confirmed after selection.
Sample Code
<template>
  <div class="page">
    <text class="title">Normal picker</text>
    <picker 
      class="picker" 
      type="text" 
      range="{{pickerList}}" 
      selected="1" 
      onchange="onPickerChange">
    </picker>
    <text class="value">Selected value: {{v1}}</text>

    <text class="title">Time picker</text>
    <picker 
      class="picker" 
      type="time"
      selected="12:00" 
      onchange="onTimePickerChange">
    </picker>
    <text class="value">Selected value: {{v2}}</text>
  </div>
</template>

<script>
  export default {
    private: {
      pickerList: ['apple', 'peach', 'pear', 'banana'],
      v1: 'peach',
      v2: '12:00'
    },
    onPickerChange(e) {
      this.v1 = e.newValue;
    },
    onTimePickerChange(e) {
      this.v2 = e.hour + ':' + e.minute;
    }
  }
</script>

<style>
  .page {
    flex-direction: column;
    padding: 30px;
    background-color: #ffffff;
  }

  .title {
    font-weight: bold;
    color: #000;
  }

  .value {
    margin-top: 5px;
    margin-bottom: 30px;
    color: #090;
  }

  .picker {
    font-size: 25px;
    color: #000;
    selected-font-size: 30px;
    selected-color: #09f;
    selected-background-color: #ccc;
  }
</style>


switch
Overview
Switch selection

Subcomponents
Not supported

Attributes
Supports universal attributes

Name	Type	Default Value	Required	Description
checked	<boolean>	false	No	Can trigger the checked pseudo-class (checked pseudo-class style is not yet supported)
Styles
Supports universal styles

Name	Type	Default Value	Required	Description
thumb-color	<color>	#ffffff or rgb(255, 255, 255)	No	Slider color
track-color	<color>	#0d84ff or rgb(13, 132, 255)	No	Track color
Events
Supports universal events

Name	Parameters	Description
change	{checked:checkedValue}	Triggered when the checked state changes
Sample Code
<template>
  <div class="page">
    <text class="title">switch component</text>
    <switch checked="{{ switchValue }}" class="switch" @change="onSwitchChange"></switch>
    <text>Status: {{ switchValue }}</text>
  </div>
</template>

<script>
  export default {
    private: {
      switchValue: true
    },
    onSwitchChange(e) {
      this.switchValue = e.checked
    }
  }
</script>

<style>
  .page {
    flex-direction: column;
    padding: 30px;
    background-color: #ffffff;
  }

  .title {
    font-weight: bold;
  }

  .switch {
    width: 100px;
    margin-top: 10px;
  }
</style>



slider
Overview
Slider selector.

Child Components
Not supported.

Attributes
Supports general attributes.

Name	Type	Default Value	Required	Description
min	<number>	0	No	-
max	<number>	100	No	-
step	<number>	1	No	-
value	<number>	0	No	-
Styles
Supports general styles.

Name	Type	Default Value	Required	Description
color	<color>	#f0f0f0 or rgb(240, 240, 240)	No	Background bar color
selected-color	<color>	#009688 or rgb(0, 150, 136)	No	Selected color
block-color	<color>	-	No	Slider block color
padding-[left|right]	<length>	32px	No	Left and right padding
Events
Supports general events.

Name	Parameters	Description
change	{progress:progressValue, isFromUser:isFromUserValue}	Triggered after a drag is completed
isFromUser description:
Indicates whether the event was triggered by user dragging
Example Code
<template>
  <div class="page">
    <text class="title">Slider Component</text>
    <slider class="slider" min="0" max="100" step="10" value="{{ initialSliderValue }}" onchange="onSliderChange"></slider>
    <text>Slider value: {{ sliderValue }}</text>
  </div>
</template>

<script>
  export default {
    private: {
      initialSliderValue: 10,
      sliderValue: null
    },
    onSliderChange (e) {
      this.sliderValue = e.progress
    }
  }
</script>

<style>
  .page {
    flex-direction: column;
    padding: 30px;
    background-color: #ffffff;
  }

  .title {
    font-weight: bold;
  }

  .slider {
    margin-top: 20px;
    margin-bottom: 20px;
    padding-left: 0;
    padding-right: 0;
  }
</style>


Interface
The framework provides several interfaces for applications to call to achieve more functions, including the following types of interfaces:

Basic function interface: used to obtain application information, platform information, device information, etc.;
Data file interface: used to obtain remote data, upload and download files, local data storage, etc.;
System capability interface: used to call system capabilities, such as obtaining network status, adjusting screen brightness, etc.;
Media interface: used to play and operate media files, such as playing music files, etc.;
Each interface is called a feature, and each feature contains several APIs that implement specific functions.


General Syntax
The framework provides various interfaces to obtain basic application information or invoke system capabilities. Each interface includes several APIs to perform specific tasks. Before using an interface, you need to declare the interface and import the module. Only then can you call the several APIs defined under that interface.

Interface Declaration
The declaration is made under the features field in the manifest.json file, for example:

[{ "name": "system.network" }]

Importing Modules
Before using an interface, you need to import the interface module in your code, for example:

import network from '@system.network'
// or
const network = require('@system.network')

Interface API Calls
The APIs provided by interfaces can be called in the following ways:

Synchronous APIs
Asynchronous APIs
Subscription-based APIs
Synchronous API Calls
If an API does not return a value, it is generally defined as a synchronous API and can be called directly, for example:

audio.play()

Asynchronous API Calls
If an API returns a value, it is generally defined as an asynchronous API. In addition to regular parameters, such APIs have three universal parameters: "success", "fail", and "complete". These are callback methods triggered after the API execution is "successful", "failed", or "completed". When calling, you can pass these three parameters to obtain the return value upon successful API execution or to handle execution failure or completion. The descriptions of these three universal parameters are as follows:

Name	Method Parameter	Parameter Type	Parameter Value	Description
success	data	any	The return value of the API execution. For details, see the interface usage documentation.	Triggered upon successful API execution.
fail	data	any	The error information content of the API execution, generally a string, but may also be of other types. For details, see the interface usage documentation.	Triggered upon failed API execution.
code	number	The error code of the API execution. For details, see Universal Error Codes.	
complete	-	-	-	Triggered upon completion of the API execution.
Code example:

storage.get({
  key: 'A1',
  success: function(data) {
    console.log('handling success')
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})

Subscription/Unsubscription APIs
Subscription-based APIs do not return results immediately. Such APIs require developers to pass a callback function as a parameter. This callback function will be triggered when the API is completed or when an event changes, and can be executed multiple times. The descriptions of the parameters of this universal callback function are as follows:

Name	Method Parameter	Parameter Type	Parameter Value	Description
success	data	any	The return value of the API execution. For details, see the interface usage documentation.	Triggered when the API call is successful or when an event changes. May be triggered multiple times.
fail	data	any	The error information content, generally a string, but may also be of other types. For details, see the interface usage documentation.	Triggered upon failed API execution. Once this callback function is triggered, success will not be called again, and the interface call ends.
code	number	The error code of the API execution. For details, see Universal Error Codes.	
Code example:

geolocation.subscribe({
  success: function(data) {
    console.log(
      `handling success: longitude = ${data.longitude}, latitude = ${
        data.latitude
      }`
    )
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})

Universal Error Codes
When errors occur during the execution of APIs from all interfaces, they will return universally defined error codes or special error codes defined by the APIs themselves. The descriptions of the universal error codes are as follows:

code	Definition
200	System general error, thrown when all unknown system exceptions occur. For example, when the framework fails to apply for memory space.
201	User rejection
202	Parameter error, when the call does not pass parameters correctly according to the API definition.
203	This feature is not supported.
204	Request timeout
205	Duplicate submission
207	User rejection and choosing not to ask again
300	I/O error


Basic Functions
Obtain basic information about applications, platforms, frameworks, and systems, as well as navigate through in-app pages.

Application-Context
Device-Information
Page-Routing
Application-Configuration


Application Context
Interface Declaration
No declaration is required.

Import Module
import app from '@system.app' 
// or 
const app = require('@system.app')
Interface Definition
app.getInfo()
Get current application information.

Parameters:
None.

Return Value:
Parameter Name	Type	Description
packageName	String	Application package name
icon	String	Application icon path
name	String	Application name
versionName	String	Application version name
versionCode	Integer	Application version number
logLevel	String	Log level
source	Object	Application source
source
Parameter Name	Type	Description
packageName	String	Package name of the source app, primary source
type	String	Source type, secondary source, values include shortcut, push, url, barcode, nfc, bluetooth, other
Example:
console.log(JSON.stringify(app.getInfo()))
// console output
{
  // Application package name
  "packageName": "com.example.demo",
  // Application name
  "name": "demo",
  // Application version name
  "versionName": "1.0.0",
  // Application version number
  "versionCode": 1,
  // Application icon
  "icon": "/common/logo.png",
  // Log level
  "logLevel": "debug",
  // Application source
  "source": {
    // Package name of the source app
    "packageName": "",
    // Source type
    "type": "shortcut"
  }
}
app.terminate()
Exit the current application.

Parameters:
None.

Return Value:
None.

Example:
app.terminate()
app.canIUse()3+
Parameters:
Type	Description
String	The capability to query, format as below
Return Value:
Type	Description
Boolean	Whether the queried capability is supported
Input Parameter Format
Query Interface
// Query if a method under a feature is supported
'@${featureName}.${method}'
// Query if a feature is supported
'@${featureName}'
Example

import app from '@system.app';

if (app.canIUse('@system.router.push')) {
  // Can use method @system.router.push
}
if (app.canIUse('@system.router')) {
  // Can use @system.router interface
}
Query Component
The value of type can be 'attr', 'style', 'method', corresponding to component's attributes, styles, and methods respectively.

// Query if an attribute, style, or method under a component is supported
`${componentName}.${type}.${name}`
// Query if a component is supported
`${componentName}`
Example

import app from '@system.app';

if (app.canIUse('scroll')) {
  // Can use scroll component
}
if (app.canIUse('scroll.attr.scroll-x')) {
  // Can use scroll-x attribute of scroll component
}


Device Information
Interface Declaration
{ "name": "system.device" }
Importing the Module
import device from '@system.device' 
// or 
const device = require('@system.device')
Interface Definitions
device.getInfo(OBJECT)
Obtains device information.

Parameters:
Parameter	Type	Required	Description
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Callback invoked when the execution is complete
Return Value of success:
Parameter	Type	Description
brand	string	Device brand
manufacturer	string	Device manufacturer
model	string	Device model
product	string	Device code name
osType	string	Operating system name
osVersionName	string	Operating system version name
osVersionCode	number	Operating system version number
platformVersionName	string	Runtime platform version name
platformVersionCode	number	Runtime platform version number
language	string	System language
region	string	System region
APILevel2+	number	Framework API version
screenWidth	number	Screen width
screenHeight	number	Screen height
screenDensity3+	number	Screen density, that is, the device pixel ratio (DPR), which is the ratio of the device's physical pixels to logical pixels (DP). The calculation formula is: DPR = device PPI / 160, where PPI (pixels per inch) indicates the number of pixels per inch.
screenShape	string	Screen shape. The value can be: rect (rectangular screen), circle (circular screen), or pill-shaped3+ (capsule-shaped screen).
deviceType2+	string	Device type. The value can be: watch, band, or smartspeaker.
Example:
device.getInfo({
  success: function(ret) {
    console.log(`handling success， brand = ${ret.brand}`)
  }
})
device.getDeviceId(OBJECT)
Obtains the unique device identifier.

Permission Requirements
Obtaining device information

Developers need to configure the permission in manifest.json:

{
  "permissions": [
    { "name": "hapjs.permission.DEVICE_INFO" }
  ]
}
Parameters:
Parameter	Type	Required	Description
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Callback invoked when the execution is complete
Return Value of success:
Parameter	Type	Description
deviceId	String	Unique device identifier
Example:
device.getDeviceId({
  success: function (data) {
    console.log(`handling success: ${data.deviceId}`)
  },
  fail: function (data, code) {
    console.log(`handling fail, code = ${code}`)
  },
})
device.getSerial(OBJECT)
Obtains the device serial number.

Permission Requirements
Obtaining device information

Developers need to configure the permission in manifest.json:

{
  "permissions": [
    { "name": "hapjs.permission.DEVICE_INFO" }
  ]
}
Parameters:
Parameter	Type	Required	Description
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Callback invoked when the execution is complete
Return Value of success:
Parameter	Type	Description
serial	String	Device serial number
device.getSerial({
    success: (data) => {
        console.log(`handling success: ${data.serial}`)
    },
    fail: (data, code) => {
        console.log(`handling fail, code = ${code}`)
    }
})
device.getTotalStorage(OBJECT)
Obtains the total size of the storage space.

Parameters:
Parameter	Type	Required	Description
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Callback invoked when the execution is complete
Return Value of success:
Parameter	Type	Description
totalStorage	Number	Total size of the storage space, in bytes
device.getTotalStorage({
    success: (data) => {
        console.log(`handling success: ${data.totalStorage}`)
    },
    fail: (data, code) => {
        console.log(`handling fail, code = ${code}`)
    }
})
device.getAvailableStorage(OBJECT)
Obtains the available size of the storage space.

Parameters:
Parameter	Type	Required	Description
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Callback invoked when the execution is complete
Return Value of success:
Parameter	Type	Description
availableStorage	Number	Available size of the storage space, in bytes
device.getAvailableStorage({
    success: (data) => {
        console.log(`handling success: ${data.availableStorage}`)
    },
    fail: (data, code) => {
        console.log(`handling fail, code = ${code}`)
    }
})



Page Routing
Interface Declaration
No declaration is required.

Importing the Module
import router from '@system.router' 
// or 
const router = require('@system.router')
Interface Definitions
router.push(OBJECT)
Navigates to a page within the application.

Parameters:
Parameter	Type	Required	Description
uri	String	Yes	The URI to navigate to, which can be in the following formats:
1. A complete URI containing the schema;
2. A path to a page within the application starting with '/'; for example, /about
3. The name of a page within the application not starting with '/'; for example, About
4. If the URI value is "/", it navigates to the page with the path "/", or to the home page if no such page exists.

Complete URIs containing the schema are supported. For URIs with a schema, the processing flow is as follows:
If the schema is hap (refer to hap Links), it navigates to the type supported by the hap link.
params	Object	No	Data to be passed during navigation. Parameters can be used in the target page via this.param1, where param1 is the parameter name in the JSON. The value corresponding to param1 will be uniformly converted to the String type. When using the this.param1 variable, you need to define a property with the same key name under public (for parameters passed outside the application) or protected (for parameters passed within the application) in the target page.
params Parameters:
Parameter	Type	Required	Description
___PARAM_LAUNCH_FLAG___	String	No	JS application launch parameter. Currently only "clearTask" is supported. When launching the target page, it clears all other pages except this one. For details, see Page Launch Modes.
Examples:
Switching pages within the application

Switching by path
router.push({
  uri: '/about',
  params: {
    testId: '1'
  }
})
Switching by name
// Open page by name
router.push({
  uri: 'About',
  params: {
    testId: '1'
  }
})
Switching pages and clearing others
router.push({
  uri: '/about',
  params: {
    ___PARAM_LAUNCH_FLAG___: 'clearTask'
  }
})
router.replace(OBJECT)
Replaces the current page with a page within the application and destroys the replaced page.

Parameters:
Parameter	Type	Required	Description
uri	String	Yes	The URI to navigate to, which can be in the following formats:
A path to a page within the application starting with '/'; for example, /about
The name of a page within the application not starting with '/'; for example, About
If the URI value is "/", it navigates to the page with the path "/", or to the home page if no such page exists.
params	Object	No	Data to be passed during navigation. Parameters can be used in the target page via this.param1, where param1 is the parameter name in the JSON. The value corresponding to param1 will be uniformly converted to the String type. When using the this.param1 variable, you need to define a property with the same key name under public (for parameters passed outside the application) or protected (for parameters passed within the application) in the target page.
Example:
router.replace({
  uri: '/test',
  params: {
    testId: '1'
  }
})
router.back(OBJECT)
Returns to a specified page.

Parameters:
Parameter	Type	Required	Description
path	String	No	The path of the target page to return to, which can be one of the following:
If not provided, returns to the previous page
A path to an already opened page within the application starting with '/'; for example, /about
If the path value is "/", it navigates to the page with the name "/", or to the home page if no such page exists.
Notes:
The path must be a path to an already opened page within the current application starting with '/', otherwise it is considered an invalid parameter and returns to the previous page.
If no page matching the path is found, returns to the previous page.
If multiple pages match the path parameter, returns to the most recently opened page.
Example:
// Page A, open page by name
router.push({
  uri: 'B'
})
// Page B, open page by name
router.push({
  uri: 'C'
})
// Page C, open page by name
router.push({
  uri: 'D'
})
// Page D, open page by name
router.push({
  uri: 'E'
})
// Page E does not pass a page path, returns to Page D
router.back()
// Page D does not pass a page name, returns to Page C
router.back()
// Page C passes a page path, returns to Page A
router.back({
  path: '/A'
})
router.clear()
Clears all historical page records, keeping only the current page.

Parameters:
None

Example:
router.clear()
router.getLength()
Gets the number of pages in the current page stack.

Return Value:
Type	Description
Number	Number of pages
Example:
var length = router.getLength()
console.log(`page's length = ${length}`)
router.getState()
Gets the current page state.

Return Parameters:
Parameter	Type	Description
index	Number	Position of the current page in the page stack
name	String	Name of the current page
path	String	Path of the current page
Example:
var page = router.getState()
console.log(`page index = ${page.index}`)
console.log(`page name = ${page.name}`)
console.log(`page path = ${page.path}`)
router.getPages()
Gets the current page stack list.

Return Value:
Type	Description
Array	Page stack list. Each item in the array is of type Object.
Each item in the array consists of:

Field	Type	Description
name	String	Name of the page
path	String	Path of the page
Example:
var stacks = router.getPages()
console.log('Name of the bottom page in the stack:', stacks[0].name) // e.g., list, detail, etc.
console.log('Path of the bottom page in the stack:', stacks[0].path) // e.g., /list, /detail, /home/preview


Application Configuration
Interface Declaration
No declaration required

Import Module
import configuration from '@system.configuration' 
// or 
const configuration = require('@system.configuration')
Interface Definition
configuration.getLocale()
Retrieves the current locale of the application. By default, it uses the system's locale, which may change due to settings or system locale changes.

Parameters:
None

Return Value:
Parameter Name	Type	Description
language	String	Language
countryOrRegion	String	Country or region
Example:
const locale = configuration.getLocale()
console.log(locale.language)



Network Access
Provides the ability to communicate between remote data requests and locally Bluetooth-connected devices.

Data Request
Device Communication
Download
Upload



Data Request Fetch
Interface Declaration
{ "name": "system.fetch" }

Import Module
import fetch from '@system.fetch' 
// or 
const fetch = require('@system.fetch')

Interface Definition
fetch.fetch(OBJECT)
Fetch network data.

Parameters:
Parameter Name	Type	Required	Description
url	String	Yes	Resource URL
data	String/Object/ArrayBuffer	No	Request parameters, can be a string, a JS object, or an ArrayBuffer object. Refer to the data and Content-Type relationship section.
header	Object	No	Request headers, all properties will be set in the request header part. Example of User-Agent setting: {"Accept-Encoding": "gzip, deflate","Accept-Language": "zh-CN,en-US;q=0.8,en;q=0.6"}
method	String	No	Default is GET, can be: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT
responseType	String	No	Supported return types are text, json, file, arraybuffer. Default is determined by the Content-Type in the server's response header. Refer to the success return value section for details.
success	Function	No	Callback function for successful return.
fail	Function	No	Callback function for failure, may fail due to permission issues.
complete	Function	No	Callback function for completion (executed regardless of success or failure).
Relationship between data and Content-Type:
data	Content-Type	Description
String	Not set	Content-Type defaults to text/plain, data value is used as the request body.
String	Any Type	data value is used as the request body.
Object	Not set	Content-Type defaults to application/x-www-form-urlencoded, data is encoded and concatenated according to URL rules as the request body.
Object	application/x-www-form-urlencoded	data is encoded and concatenated according to URL rules as the request body.
Object	Any type other than application/x-www-form-urlencoded	-
ArrayBuffer	Not set	Content-Type defaults to application/octet-stream, data value is used as the request body.
ArrayBuffer	Any Type	data value is used as the request body.
success Return Value:
Parameter Name	Type	Description
code	Integer	Server status code.
data	String/Object/ArrayBuffer	Refer to the relationship between responseType and data in success section.
headers	Object	All headers from the server response.
Relationship between responseType and data in success:
responseType	data	Description
Not set	String	If the server's response header type is text/* or application/json, application/javascript, application/xml, the value is the text content; otherwise, it's the URI of a temporary file. For images or videos in the temporary file, they can be set to the image.
text	String	Returns plain text.
json	Object	Returns a JS object.
file	String	Returns the URI of a temporary file.
arraybuffer	ArrayBuffer	Returns an ArrayBuffer object.
Example:
fetch.fetch({
  url: 'http://www.example.com',
  responseType: 'text',
  success: function(response) {
    console.log(`the status code of the response: ${response.code}`)
    console.log(`the data of the response: ${response.data}`)
    console.log(
      `the headers of the response: ${JSON.stringify(response.headers)}`
    )
  },
  fail: function(data, code) {
    console.log(`handling fail, errMsg = ${data}`)
    console.log(`handling fail, errCode = ${code}`)
  }
})

// We can also handle callbacks using promises
fetch
  .fetch({
    url: 'http://www.example.com',
    responseType: 'text'
  })
  .then(res => {
    const result = res.data

    console.log(`the status code of the response: ${result.code}`)
    console.log(`the data of the response: ${result.data}`)
    console.log(
      `the headers of the response: ${JSON.stringify(result.headers)}`
    )
  })
  .catch(error => {
    console.log(`handling fail, errMsg = ${error.data}`)
    console.log(`handling fail, errCode = ${error.code}`)
  })

Support Details
Device Product	Description
Xiaomi S1 Pro Sports & Health Watch	Supported
Xiaomi Band 8 Pro	Not supported
Xiaomi Band 9 / 9 Pro	Not supported
Xiaomi Watch S3	Supported
Redmi Watch 4	Not supported
Xiaomi Wrist ECG Blood Pressure Recorder	Not supported
Xiaomi Band 10	Not supported
Xiaomi Watch S4	Supported
REDMI Watch 5	Supported


Device Communication Interconnect
Used for communication with the paired mobile app and for sending and receiving data from the mobile app. The communication connection will be automatically established. There is no need to manage the creation and destruction of connections within the app, but callback functions can be registered to receive notifications about connection status changes for appropriate handling, such as notifying the user.

Interface Declaration
{ "name": "system.interconnect" }
Import Module
import interconnect from '@system.interconnect'
// or
const interconnect = require('@system.interconnect')
Interface Definition
interconnect.instance()
Obtains a connection object that exists as a singleton in the app. Subsequent data sending and receiving are based on this connection object.

Parameters:
None

Return Value:
An interconnect connection instance, the connect object.

Example:
const connect = interconnect.instance()
connect.getReadyState(OBJECT)
Obtains the connection status of the app.

OBJECT Parameters:
Parameter	Type	Required	Description
success	Function	No	Success callback
fail	Function	No	Failure callback
success Return Value:
Property Value	Type	Description
status	Number	1: Connected successfully, 2: Connection disconnected
fail Return Value:
Parameter Value	Type	Description
data	String	Error message
code	Number	Error code
Error Code Descriptions:
Supports common error codes

Error Code	Description
1006	Connection disconnected
Example:
connect.getReadyState({
  success: (data) => {
    if (data.status === 1) {
      console.log('Connected successfully')
    } else if (data.status === 2) {
      console.log('Connection failed')
    }
  },
  fail: (data, code) => {
    console.log(`handling fail, code = ${code}`)
  }
})
connect.diagnosis(OBJECT)
Diagnoses the connection between the watch app and the counterpart app. Returns "ok" if the connection is successful, or the reason for failure if the connection fails. If a connection is in progress when called, it waits for the connection to end before returning the final status.

Object Parameters:
Property	Type	Required	Description
timeout	Number	No	Timeout duration for waiting for diagnosis, in milliseconds
Default value: 10000ms
success	Function	No	Success callback
fail	Function	No	Failure callback
success Return Value:
Property Value	Type	Description
status	Number	0: OK, connection successful
204: CONNECT_TIMEOUT, connection timeout
1001: APP_UNINSTALLED, counterpart app not installed
1000: OTHERS, other connection errors
fail Return Value:
Parameter Value	Type	Description
data	String	Error message
code	Number	Error code
Error Code Descriptions:
Supports common error codes

Example:
connect.diagnosis({
  success: function (data) {
    console.log(`handling success, version = ${data.status}`)
  },
  fail: function (data, code) {
    console.log(`handling fail, code = ${code}`)
  },
})
connect.send(OBJECT)
Sends data to the mobile app.

Object Parameters:
Parameter	Type	Required	Description
data	Object	Yes	Data to be sent
success	Function	No	Success callback
fail	Function	No	Failure callback
success Return Value:
None

fail Return Value:
Parameter Value	Type	Description
data	String	Error message
code	Number	Error code
Error Code Descriptions:
Supports common error codes

Error Code	Description
204	Connection timeout
1006	Connection disconnected
Example:
connect.send({
  data: {
    str: 'test',
    num: 123
  },
  success: ()=>{
    console.log(`handling success`)
  },
  fail: (data, code)=> {
    console.log(`handling fail, errMsg = ${data.data}, errCode = ${data.code}`)
  }
})
Events
connect.onmessage
Receives data from the mobile app.

Callback Parameters:
Parameter	Type	Description
data	String	Received data
Example:
connect.onmessage = (data) => {
  console.log(`received message: ${data.data}`)
}
connect.onopen
Callback function when the connection is opened.

Callback Parameters:
Parameter	Type	Description
isReconnected	Boolean	Whether it is a reconnection
Example:
connect.onopen = function (data) {
  console.log('connection opened isReconnected: ', data.isReconnected)
}
connect.onclose
Callback function when the connection is closed.

Callback Parameters:
Parameter	Type	Description
code	Number	Connection closure status code
data	String	Data returned upon connection closure
Example:
connect.onclose = (data) => {
  console.log(`connection closed, reason = ${data.data}, code = ${data.code}`)
}
connect.onerror
Callback function when a connection error occurs.

Callback Parameters:
Parameter	Type	Description
code	Number	Error code, see error code descriptions
data	String	Error message
Error Code Descriptions:
Supports common error codes

Error Code	Description
1000	Unknown error
1001	Mobile app not installed
1006	Connection disconnected
Example:
connect.onerror = (data)=> {
  console.log(`connection error, errMsg = ${data.data}, errCode = ${data.code}`)
}
Development Considerations
For interconnect communication, ensure that the package names and signatures of both the Quick App and the Android version of the third-party app are consistent.

Ensure that the package field in the Quick App's manifest.json matches the package name of the third-party Android app to be integrated.
The Quick App signature must use the signature of the third-party Android app. The certificate and private key can be extracted from the .jks file as follows:
Convert the jks to p12 by executing the following command. After entering the corresponding password, a p12 format file will be generated in the same directory.
keytool -importkeystore -srckeystore keystore.jks -destkeystore keystore.p12 -srcstoretype jks -deststoretype pkcs12
Convert the p12 to pem by executing the following command. After entering the password set for the p12 file in the previous step, a pem format file will be generated in the same directory.
openssl pkcs12 -nodes -in keystore.p12 -out keystore.pem
Copy the private key and certificate from the pem format file:
Copy the content from -----BEGIN PRIVATE KEY----- to -----END PRIVATE KEY----- into private.pem.
Copy the content from -----BEGIN CERTIFICATE----- to -----END CERTIFICATE----- into certificate.pem.
If OpenSSL is not installed locally or a simpler operation process is desired, we provide an online signature generation tool (opens new window). This tool is a web application written in WebAssembly that can directly generate pem format private keys and certificates in the browser environment without uploading signature files and passwords to a remote server, fully ensuring user privacy and security. The steps for using the online signature generation tool are as follows:

Upload the p12 file and enter the corresponding password;

Click the "Generate Signature" button and wait for the signature generation success popup to appear;

Click the "Download Signature" button to download the pem format private key and certificate;

The Quick App needs to place the generated private key private.pem and certificate certificate.pem in the root directory of the Quick App under /sign/debug and /sign/release for packaging and testing.

When testing on a real device, it is recommended to first enter the package name to uninstall the old package and then install the new package. Observing the desktop icon for uninstallation will ensure that the app icon is deleted, guaranteeing a complete replacement.

Reference Appendix

Xiaomi Wear Third-Party App Capability Open Interface Documentation:


小米穿戴第三方APP能力开放接口文档_v1.4
版本更新日志
兼容Android R
1.3版本更新日志
兼容未来小米穿戴和小米健康合并项目，api无变化，直接替换sdk即可
1.2版本更新日志：
兼容jdk1.7版本，api没有变化
1.1版本更新日志：
1.修改状态订阅和状态查询相关接口返回值，详情请查看文档3.2和3.3部分
2.增加消息通知api，详情请看文档第5部分
1.4

1.

查询已连接的可穿戴设备（不需要权限）
先获取NodeApi对象

//

NodeApi api = Wearable.getNodeApi(context);

调用getConnectedNodes方法获取已连接设备

//

api.getConnectedNodes().addOnSuccessListener(new OnSuccessListener<List<Node>>()
{
@Override
public void onSuccess(List<Node> nodes) {

获取当前已连接的设备,目前一次只能连接一个设备

//
}

}).addOnFailureListener(new OnFailureListener() {
@Override
public void onFailure(@NonNull Exception e) {

获取已连接设备失败

//
}
});

2.

权限查询与申请
查询授权状态

2.1

第一次调用授权会默认授予Permission.DEVICE_MANAGER和Permission.Notify权限
先获取AuthApi对象

//

AuthApi authApi = Wearable.getAuthApi(context);

调用checkPermission方法获取某个授权状态

//

authApi.checkPermission("nodeId",Permission.DEVICE_MANAGER)
.addOnSuccessListener(new OnSuccessListener<Boolean>() {
@Override
public void onSuccess(Boolean result) {

如果已授权，result为true，未授权result为false

//
}

}).addOnFailureListener(new OnFailureListener() {
@Override

public void onFailure(@NonNull Exception e ) {

获取授权失败

//
}
});

定义一组权限

//

Permission[] permissions = new Permission[]
{Permission.DEVICE_MANAGER,Permission.NOTIFY};

调用checkPermissions接口查询一组权限授权状态

//

authApi.checkPermissions("nodeId",permissions)
.addOnSuccessListener(new OnSuccessListener<Boolean[]>() {
@Override
public void onSuccess(Boolean[] results) {

如果已授权，result为true，未授权result为false,按照请求顺序返回结果

//
}

}).addOnFailureListener(new OnFailureListener() {
@Override
public void onFailure(@NonNull Exception e) {

获取授权状态失败

//
}
});

申请权限

2.2

先获取AuthApi对象

//

AuthApi authApi = Wearable.getAuthApi(context);

发起授权申请

//

authApi.requestPermission("nodeId",Permission.DEVICE_MANAGER,Permission.NOTIFY)
.addOnSuccessListener(new OnSuccessListener<Permission[]>() {
@Override
public void onSuccess(Permission[] permissions) {

申请权限成功，返回授权成功的权限

//
}

}).addOnFailureListener(new OnFailureListener() {
@Override
public void onFailure(@NonNull Exception e) {

申请权限失败

//
}
});

3.

设备管理与状态订阅

支持查询与订阅的设备状态

3.1

设备管理与状态订阅

查询结果

订阅事件触发条件

连接状态

1.

1.

电量状态

电量值（0~100，比如98）

N/A

充电状态

1.

佩戴状态

1.

连接
2.未连接

手机与设备连接成功
2.手机与设备断开连接

正在充电
2.非充电状态
佩戴中
2.未佩戴
1.睡眠中
2.清醒

睡眠状态

给设备充电
充满电
3.停止充电
1.手表戴在手腕上
2.摘下手表
1.佩戴手表入睡
2.从入睡状态清醒过来

订阅结果
1.连接成功
2.连接断开
3.连接失败
4.设备被删除
N/A

开始充电
充电完成
3.停止充电
1.佩戴
2.未佩戴
1.入睡
2.出睡

1.

1.

2.

2.

状态查询（需要申请Permission.DEVICE_MANAGER权限）

3.2

先获取NodeApi对象

//

NodeApi api = Wearable.getNodeApi(context);

调用query方法，查询不同状态，nodeId通过查询已连接设备得到的设备id
//目前支持查询（连接状态，电量状态，充电状态，佩戴状态，睡眠状态）
//

api.query("nodeId", DataItem.ITEM_CONNECTION)
.addOnSuccessListener(new OnSuccessListener<DataQueryResult>() {
@Override
public void onSuccess(DataQueryResult result) {

查询成功

//

定义了

boolean connectionStatus = result.isConnected;//DataQueryResult

各种状态的状态值，和DataItem一一对应
}

}).addOnFailureListener(new OnFailureListener() {
@Override
public void onFailure(@NonNull Exception e) {

查询失败

//
}
});

查询对应的穿戴设备端应用是否安装

//

api.isWearAppInstalled("nodeId")
.addOnSuccessListener(new OnSuccessListener<Boolean>() {
@Override
public void onSuccess(Boolean result) {

查询成功，应用已安装返回true，未安装返回false

//
}

}).addOnFailureListener(new OnFailureListener() {
@Override
public void onFailure(@NonNull

查询失败

Exception e) {

//
}
});

打开设备端应用
由各个应用自定义，用于打开手表端app的指定页面

//

//uri

api.launchWearApp("nodeId","uri")

.addOnSuccessListener(new OnSuccessListener<Void>() {
@Override
public void onSuccess(Void var1) {

打开穿戴设备端应用成功

//
}

}).addOnFailureListener(new OnFailureListener() {
@Override
public void onFailure(@NonNull @NotNull Exception var1) {

打开穿戴设备端应用失败

//
}
});

状态订阅（需要申请Permission.DEVICE_MANAGER权限）

3.3

先获取NodeApi对象

//

NodeApi api = Wearable.getNodeApi(context);

创建监听器

//

OnDataChangedListener onDataChangedListener = new OnDataChangedListener() {
@Override
public void onDataChanged(@NonNull String nodeId, @NonNull DataItem dataItem,
@NonNull DataSubscribeResult data) {

收到订阅状态变更通知
不同的DataItem对应DataSubscribeResult中不同的status，一一对应

//
//

if(dataItem.getType() == DataItem.ITEM_CONNECTION.getType()){
int connectionStatus = data.getConnectedStatus();
if(connectionStatus ==
DataSubscribeResult.RESULT_CONNECTION_CONNECTED){

设备连接状态变更为已连接状态

//
}
}
}
};

调用subscribe方法，订阅不同状态，nodeId是通过查询已连接设备得到的设备id
目前支持订阅（连接状态变化，充电状态变化，佩戴状态变化，睡眠状态变化）

//
//

api.subscribe("nodeId", DataItem.ITEM_CONNECTION, onDataChangedListener)
.addOnSuccessListener(new OnSuccessListener<Void>() {
@Override
public void onSuccess(Void var1) {

添加订阅成功

//
}

}).addOnFailureListener(new OnFailureListener() {
@Override
public void onFailure(@NonNull @NotNull Exception var1) {

添加订阅失败

//
}
});

调用unsubscribe方法取消监听

//

api.unsubscribe("nodeId", DataItem.ITEM_CONNECTION)
.addOnSuccessListener(new OnSuccessListener<Void>() {
@Override
public void onSuccess(Void var1) {

删除订阅成功

//
}

}).addOnFailureListener(new OnFailureListener() {
@Override
public void onFailure(@NonNull @NotNull Exception var1) {

删除订阅失败

//
}
});

应用间消息通信（需要申请Permission.DEVICE_MANAGER权
限）
4.

模拟数据，应用可以自定义发送数据

//

byte[] messageBytes = new byte[1024];

获取MessageApi对象

//

MessageApi messageApi = Wearable.getMessageApi(context);

调用sendMessage方法用来发送数据给穿戴设备端应用

//

messageApi.sendMessage("nodeId",messageBytes)
.addOnSuccessListener(new OnSuccessListener<Integer>() {
@Override
public void onSuccess(Integer result) {

发送数据成功

//
}
})

.addOnFailureListener(new OnFailureListener() {
@Override
public void onFailure(@NonNull Exception e) {

发送数据失败

//
}
});

传见监听器用于监听穿戴设备端发送来的消息

//

OnMessageReceivedListener onMessageReceivedListener = new
OnMessageReceivedListener() {
@Override
public void onMessageReceived(@NotNull String nodeId,

@NotNull byte[]

message) {

收到手表端应用发来的消息

//
}
};

监听穿戴设备端应用发来的消息

//

messageApi.addListener("nodeId", onMessageReceivedListener)
.addOnSuccessListener(new OnSuccessListener<Void>() {
@Override
public void onSuccess(Void var1) {

添加消息监听成功

//
}

}).addOnFailureListener(new OnFailureListener() {
@Override
public void onFailure(@NonNull @NotNull Exception var1) {

添加消息监听失败

//
}
});

取消监听

//

messageApi.removeListener("nodeId",onMessageReceivedListener).addOnSuccessListene
r(new OnSuccessListener<Void>() {
@Override
public void onSuccess(Void var1) {

取消消息监听成功

//
}

}).addOnFailureListener(new OnFailureListener() {
@Override
public void onFailure(@NonNull @NotNull Exception var1) {

取消消息监听失败

//
}
});

5.

消息通知（需要Permission.NOTIFY权限）
获取NotifyApi

//

NotifyApi notifyApi = Wearable.getNotifyApi(context);

发送消息通知，需要提前判断是否有Permission.NOTIFY权限

//

notifyApi.sendNotify("nodeId","title","message")
.addOnSuccessListener(new OnSuccessListener<Status>() {
@Override
public void onSuccess(Status status) {
if(status.isSuccess()){

发送通知成功,手表上会看到消息通知内容，表端应用无感知

//
}
}

}).addOnFailureListener(new OnFailureListener() {
@Override
public void onFailure(@NonNull @NotNull Exception var1) {

发送通知失败

//
}
});

6.

管理服务连接状态（不需要权限）
获取ServiceApi

//

ServiceApi serviceApi = Wearable.getServiceApi(context);

第三方应用与小米穿戴App连接状态可以通过这个监听器来监听

//

OnServiceConnectionListener onServiceConnectionListener = new
OnServiceConnectionListener() {
@Override
public void onServiceConnected() {

服务连接成功

//
}

@Override
public void onServiceDisconnected() {

服务断开

//
}
};

注册监听器

//

serviceApi.registerServiceConnectionListener(onServiceConnectionListener);

取消监听器

//

serviceApi.unregisterServiceConnectionListener(onServiceConnectionListener);




Interconnect Development and Testing Demo: Click to Download(opens new window)



Download request
Interface declaration
{ "name": "system.request" }
Import module
import request from '@system.request' 
// or 
const request = require('@system.request')
Interface definition
request.download(OBJECT)
Download files

Parameters:
Parameter	Type	Required	Description
url	String	Yes	Resource URL
header	String	No	Request header. All its properties will be set to the header part of the request.
filename	String	No	Download filename. Default is obtained from the network request or URL.
success	Function	No	Callback for success
fail	Function	No	Callback for failure
complete	Function	No	Callback for completion (invoked for both success and failure)
success return value:
Parameter	Type	Description
token	String	Download token, used to get the download status
Example:
request.download({
  url: 'http://www.example.com',
  success: function(data) {
    console.log(`handling success${data.token}`)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
request.onDownloadComplete(OBJECT)
Listen for download tasks

Parameters:
Parameter	Type	Required	Description
token	String	Yes	Token returned by the download interface
success	Function	No	Callback for success
fail	Function	No	Callback for failure
complete	Function	No	Callback for completion (invoked for both success and failure)
success return value:
Parameter	Type	Description
uri	String	URI of the downloaded file (by default, this file is in the app's cache directory. If the file type is an image or video and you want users to view it in apps like the gallery, you need to move it to a public directory. You can achieve this using methods from the media interface.)
fail error codes:
Error Code	Description
1000	Download failed
1001	Download task does not exist
Example:
request.onDownloadComplete({
  token: '123',
  success: function(data) {
    console.log(`handling success${data.uri}`)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
Support details
Device	Description
Xiaomi S1 Pro Fitness & Health Watch	Supported
Xiaomi Band 8 Pro	Not supported
Xiaomi Band 9 / 9 Pro	Not supported
Xiaomi Watch S3	Supported
Redmi Watch 4	Not supported
Xiaomi Wrist ECG & Blood Pressure Recorder	Not supported
Xiaomi Band 10	Not supported
Xiaomi Watch S4	Supported
REDMI Watch 5	Supported


Upload 3+
Interface Declaration
{ "name": "system.uploadtask" }

Import Module
import uploadtask from '@system.uploadtask' 
// or 
const uploadtask = require('@system.uploadtask')

Interface Definition
Methods
UploadTask uploadtask.uploadFile(OBJECT)
Creates an upload request. Each successful call to uploadtask.uploadFile returns an UploadTask instance for the current request.

Parameters:
Parameter Name	Type	Required	Description
url	String	Yes	Developer server URL
filePath	String	Yes	Path to the file resource to upload (local path)
name	String	Yes	Key corresponding to the file. The developer can use this key to retrieve the binary content of the file on the server side
header	Object	No	Request headers. All properties will be set in the request header section
formData	Object	No	Additional form data in the HTTP request
timeout	Number	No	Timeout duration in milliseconds
success	Function	No	Callback function for successful response
fail	Function	No	Callback function for failed response
complete	Function	No	Callback function for completion (called on both success and failure)
success Return Value:
Parameter Name	Type	Description
statusCode	Integer	Server status code
data	String	Data returned by the developer server
headers	Object	All headers from the server response
UploadTask
Methods
UploadTask.abort()
Aborts the upload task.

UploadTask.onProgressUpdate(callback)
Listens for upload progress change events.

Parameters:
Parameter Name	Type	Required	Description
callback	Function	Yes	Callback function for upload progress change events
callback Return Value:
Parameter Name	Type	Description
progress	Number	Upload progress percentage
totalBytesSent	Number	Length of data already uploaded, in Bytes
totalBytesExpectedToSend	Number	Expected total length of data to upload, in Bytes
UploadTask.offProgressUpdate(function callback)
Cancels listening for upload progress change events. The callback is optional; if not provided, all upload progress change events listened to via onProgressUpdate will be canceled.

Example:
const retUploadTask = uploadtask.uploadFile({
  url: 'http://www.example.com',
  filePath: "internal://mass/download/test.png",
  name: "testImg",
  success: function(res){
    console.log("Upload success.resp = " + JSON.stringify(res))
  },
  fail: function(data, code) {
    console.log(`handling fail, errMsg = ${data)}`)
    console.log(`handling fail, errCode = ${code}`)
  }
})
// Abort the request task
retUploadTask.abort()

// Listen for upload progress events
retUploadTask.onProgressUpdate(res => {
  console.log(
    `listening upload progress update event, progressUpdate data = ${JSON.stringify(res)}`
  )
})

// Cancel listening for upload progress events
retUploadTask.offProgressUpdate()

Cancel a specific upload progress event:

function cb(res) {
  console.log(
    `listening for upload progress update event 1, progressUpdate data = ${JSON.stringify(
      res
    )}`
  )
}

// This listener will be canceled
retUploadTask.onProgressUpdate(cb)

// event2 listener remains active and will not be canceled
retUploadTask.onProgressUpdate((res) => {
  console.log(
    `listening for upload progress update event 2, progressUpdate data = ${JSON.stringify(
      res
    )}`
  )
})

retUploadTask.offProgressUpdate(cb)

Support Details
Device Product	Description
Xiaomi S1 Pro Fitness Watch	Not supported
Xiaomi Smart Band 8 Pro	Not supported
Xiaomi Smart Band 9 / 9 Pro	Not supported
Xiaomi Watch S3	Supported
Redmi Watch 4	Not supported
Xiaomi Wearable ECG and Blood Pressure Recorder	Not supported
Xiaomi Smart Band 10	Not supported
Xiaomi Watch S4	Supported
REDMI Watch 5	Supported


Data Files
Provides capabilities related to local data storage and file operations.

Data Storage
File Storage


Data Storage
Interface Declaration
{ "name": "system.storage" }
Import Module
import storage from '@system.storage' 
// or 
const storage = require('@system.storage')
Methods
storage.get(OBJECT)
Reads stored content.

Parameters:
Parameter	Type	Required	Description
key	String	Yes	Index
default	String	No	If the key does not exist, returns default. If default is not specified, returns an empty string with a length of 0
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Callback after execution ends
success Return Value:
Stored content corresponding to the key

Example:
storage.get({
  key: 'A1',
  success: function(data) {
    console.log('handling success')
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
storage.set(OBJECT)
Modifies stored content.

Parameters:
Parameter	Type	Required	Description
key	String	Yes	Index
value	String	No	New value. If the new value is an empty string with a length of 0, deletes the data item indexed by key
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Callback after execution ends
Example:
storage.set({
  key: 'A1',
  value: 'V1',
  success: function(data) {
    console.log('handling success')
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
storage.clear(OBJECT)
Clears stored content.

Parameters:
Parameter	Type	Required	Description
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Callback after execution ends
Example:
storage.clear({
  success: function(data) {
    console.log('handling success')
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
storage.delete(OBJECT)
Deletes stored content.

Parameters:
Parameter	Type	Required	Description
key	String	Yes	Index
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Callback after execution ends
Example:
storage.delete({
  key: 'A1',
  success: function(data) {
    console.log('handling success')
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})


File Storage
Interface Declaration
{ "name": "system.file" }
Import Module
import file from '@system.file' 
// or 
const file = require('@system.file')
Interface Definition
file.move(OBJECT)
Moves a source file to a specified location. For URI descriptions used in the interface, refer to File Organization.

Parameters:
Parameter	Type	Required	Description
srcUri	String	Yes	URI of the source file. Cannot be an app resource path or a tmp-type URI.
dstUri	String	Yes	URI of the destination file. Cannot be an app resource path or a tmp-type URI.
success	Function	No	Success callback, returns the URI of the destination file.
fail	Function	No	Failure callback.
complete	Function	No	Callback after execution ends.
Error Codes Returned by fail:
Error Code	Description
202	Parameter error
300	I/O error
Example:
file.move({
  srcUri: 'internal://cache/path/to/file',
  dstUri: 'internal://files/path/to/file',
  success: function(uri) {
    console.log(`move success: ${uri}`)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
file.copy(OBJECT)
Copies a source file and stores it in a specified location. For URI descriptions used in the interface, refer to File Organization.

Parameters:
Parameter	Type	Required	Description
srcUri	String	Yes	URI of the source file.
dstUri	String	Yes	URI of the destination file. Cannot be an app resource path or a tmp-type URI.
success	Function	No	Success callback, returns the URI of the destination file.
fail	Function	No	Failure callback.
complete	Function	No	Callback after execution ends.
Error Codes Returned by fail:
Error Code	Description
202	Parameter error
300	I/O error
Example:
file.copy({
  srcUri: 'internal://cache/path/to/file',
  dstUri: 'internal://files/path/to/file',
  success: function(uri) {
    console.log(`copy success: ${uri}`)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
file.list(OBJECT)
Gets a list of files in a specified directory. For URI descriptions used in the interface, refer to File Organization.

Parameters:
Parameter	Type	Required	Description
uri	String	Yes	Directory URI.
success	Function	No	Success callback, returns {fileList:[{uri:'file1', lastModifiedTime:1234456, length:123456} ...]}
fail	Function	No	Failure callback.
complete	Function	No	Callback after execution ends.
Return Values of success:
Parameter	Type	Description
fileList	Array	List of files, each in the format {uri:'file1', lastModifiedTime:1234456, length:123456}
Metadata for Each File:
Parameter	Type	Description
uri	String	URI of the file, which can be accessed by other components or features.
length	Number	File size in bytes.
lastModifiedTime	Number	Timestamp of when the file was saved, in milliseconds from 1970/01/01 00:00:00 GMT.
Error Codes Returned by fail:
Error Code	Description
202	Parameter error
300	I/O error
Example:
file.list({
  uri: 'internal://files/movies/',
  success: function(data) {
    console.log(data.fileList)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
file.get(OBJECT)
Gets file information for a local file. For URI descriptions used in the interface, refer to File Organization.

Parameters:
Parameter	Type	Required	Description
uri	String	Yes	URI of the file. Cannot be an app resource path or a tmp-type URI.
recursive	Boolean	No	Whether to recursively get the file list in subdirectories. Default is false.
success	Function	No	Success callback, returns {uri:'file1', length:123456, lastModifiedTime:1233456}
fail	Function	No	Failure callback.
complete	Function	No	Callback after execution ends.
Return Values of success:
Parameter	Type	Description
uri	String	URI of the file, which can be accessed by other components or features.
length	Number	File size in bytes. Returns 0 when type = dir.
lastModifiedTime	Number	Timestamp of when the file was saved, in milliseconds from 1970/01/01 08:00:00.
type	String	File type: dir for directory, file for file.
subFiles	Array	When type = dir, returns the list of files in the directory. When recursive is true, also returns file information in subdirectories.
Error Codes Returned by fail:
Error Code	Description
202	Parameter error
300	I/O error
Example:
file.get({
  uri: 'internal://files/path/to/file',
  success: function(data) {
    console.log(data.uri)
    console.log(data.length)
    console.log(data.lastModifiedTime)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
file.delete(OBJECT)
Deletes a locally stored file. For URI descriptions used in the interface, refer to File Organization.

Parameters:
Parameter	Type	Required	Description
uri	String	Yes	URI of the file to be deleted. Cannot be an app resource path or a tmp-type URI.
success	Function	No	Success callback.
fail	Function	No	Failure callback.
complete	Function	No	Callback after execution ends.
Error Codes Returned by fail:
Error Code	Description
202	Parameter error
300	I/O error
Example:
file.delete({
  uri: 'internal://files/path/to/file',
  success: function(data) {
    console.log('handling success')
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
file.writeText(OBJECT)
Writes text to a file.

WARNING

When using file write interfaces, ensure to clean up unused files promptly, especially on IoT devices with limited memory, to avoid memory overload and application crashes.

Parameters:
Parameter	Type	Required	Description
uri	String	Yes	Local file path. Does not support resource file paths or tmp partitions. Creates the file if it does not exist.
text	String	Yes	String to be written.
encoding	String	No	Encoding format, default is UTF-8.
append	Boolean	No	Whether to append, default is false.
success	Function	No	Success callback.
fail	Function	No	Failure callback.
complete	Function	No	Callback after execution ends.
Error Codes Returned by fail:
Error Code	Description
202	Parameter error
300	I/O error
Example:
file.writeText({
  uri: 'internal://files/work/demo.txt',
  text: 'test',
  success: function() {
    console.log('handling success')
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
file.writeArrayBuffer(OBJECT)
Writes a Buffer to a file.

WARNING

When using file write interfaces, ensure to clean up unused files promptly, especially on IoT devices with limited memory, to avoid memory overload and application crashes.

Parameters:
Parameter	Type	Required	Description
uri	String	Yes	Local file path. Does not support resource file paths or tmp partitions. Creates the file if it does not exist.
buffer	Uint8Array	Yes	Buffer to be written.
position	Number	No	Offset from the start of the file where data begins to be written. Default is 0.
append	Boolean	No	Whether to append, default is false. When true, the position parameter is invalid.
success	Function	No	Success callback.
fail	Function	No	Failure callback.
complete	Function	No	Callback after execution ends.
Error Codes Returned by fail:
Error Code	Description
202	Parameter error
300	I/O error
Example:
file.writeArrayBuffer({
  uri: 'internal://files/work/demo',
  buffer: buffer,
  success: function() {
    console.log('handling success')
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
file.readText(OBJECT)
Reads text from a file.

Parameters:
Parameter	Type	Required	Description
uri	String	Yes	Local file path. Supports app resource paths, e.g., '/Common/demo.txt'.
encoding	String	No	Encoding format, default is UTF-8.
success	Function	No	Success callback.
fail	Function	No	Failure callback.
complete	Function	No	Callback after execution ends.
Return Values of success:
Parameter	Type	Description
text	String	The read text.
Error Codes Returned by fail:
Error Code	Description
202	Parameter error
300	I/O error
301	File does not exist
Example:
file.readText({
  uri: 'internal://files/work/demo.txt',
  success: function(data) {
    console.log('text: ' + data.text)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
file.readArrayBuffer(OBJECT)
Reads a Buffer from a file.

Parameters:
Parameter	Type	Required	Description
uri	String	Yes	Local file path. Supports app resource paths, e.g., '/Common/demo.txt'.
position	Number	No	Starting position for reading. Default is the start of the file.
length	Number	No	Length to read. If not specified, reads to the end of the file.
success	Function	No	Success callback.
fail	Function	No	Failure callback.
complete	Function	No	Callback after execution ends.
Return Values of success:
Parameter	Type	Description
buffer	Uint8Array	The read file content.
Error Codes Returned by fail:
Error Code	Description
202	Parameter error
300	I/O error
301	File does not exist
Example:
file.readArrayBuffer({
  uri: 'internal://files/work/demo',
  position: 100,
  length: 100,
  success: function(data) {
    console.log('buffer.length: ' + data.buffer.length)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
file.access(OBJECT)
Checks if a file or directory exists.

Parameters:
Parameter	Type	Required	Description
uri	String	Yes	URI of the directory or file.
success	Function	No	Success callback.
fail	Function	No	Failure callback.
complete	Function	No	Callback after execution ends.
Error Codes Returned by fail:
Error Code	Description
202	Parameter error
300	I/O error
Example:
file.access({
  uri: 'internal://files/test',
  success: function(data) {
    console.log(`handling success`)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
file.mkdir(OBJECT)
Creates a directory.

Parameters:
Parameter	Type	Required	Description
uri	String	Yes	URI of the directory. Cannot be an app resource path or a tmp-type URI.
recursive	Boolean	No	Whether to recursively create parent directories before creating this directory. Default is false.
success	Function	No	Success callback.
fail	Function	No	Failure callback.
complete	Function	No	Callback after execution ends.
Error Codes Returned by fail:
Error Code	Description
202	Parameter error
300	I/O error
Example:
file.mkdir({
  uri: 'internal://files/dir/',
  success: function(data) {
    console.log(`handling success`)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
file.rmdir(OBJECT)
Deletes a directory.

Parameters:
Parameter	Type	Required	Description
uri	String	Yes	URI of the directory. Cannot be an app resource path or a tmp-type URI.
recursive	Boolean	No	Whether to recursively delete subfiles and subdirectories. Default is false.
success	Function	No	Success callback.
fail	Function	No	Failure callback.
complete	Function	No	Callback after execution ends.
Error Codes Returned by fail:
Error Code	Description
202	Parameter error
300	I/O error
Example:
file.rmdir({
  uri: 'internal://files/dir/',
  success: function(data) {
    console.log(`handling success`)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})


System Capabilities
Provide some system capabilities.

Network Information
Vibration
Screen Brightness
Audio Recording
Geolocation
Sensors
Events
Battery Information
System Volume
Decompression


Network Information network
Interface Declaration
{ "name": "system.network" }
Import Module
import network from '@system.network' 
// or 
const network = require('@system.network')
Interface Definition
network.getType(OBJECT)
Obtain the network type.

Parameters:
Parameter Name	Type	Required	Description
success	Function	No	Callback for success
fail	Function	No	Callback for failure, possibly due to lack of permissions
complete	Function	No	Callback after execution ends
Return Value for success:
Parameter Name	Type	Description
type	String	Network type, possible values are 2g, 3g, 4g, wifi, none, 5g, bluetooth, others
Example:
network.getType({
  success: function(data) {
    console.log(`handling success: ${data.type}`)
  }
})
network.subscribe(OBJECT)
Listen for changes in network type. If called multiple times, only the last call will take effect.

Parameters:
Parameter Name	Type	Required	Description
callback	Function	No	Callback each time the network changes
fail	Function	No	Callback for failure, possibly due to lack of permissions
Return Value for callback:
Parameter Name	Type	Description
type	String	Network type, possible values are 2g, 3g, 4g, wifi, none, 5g, bluetooth, others. Note: A network type other than none does not guarantee that the device can access the target server; a request interface must be used to make this determination.
Example:
network.subscribe({
  callback: function(data) {
    console.log('handling callback')
  }
})
network.unsubscribe()
Cancel listening for changes in network type.

Parameters:
None

Example:
network.unsubscribe()
Support Details
Device Product	Description
Xiaomi S1 Pro Sports and Health Watch	Supported
Xiaomi Band 8 Pro	Not Supported
Xiaomi Band 9 / 9 Pro	Not Supported
Xiaomi Watch S3	Supported
Redmi Watch 4	Not Supported
Xiaomi Wrist ECG Blood Pressure Monitor	Not Supported
Xiaomi Band 10	Not Supported
Xiaomi Watch S4	Supported
REDMI Watch 5	Supported


Vibrator
Interface Declaration
{ "name": "system.vibrator" }
Import Module
import vibrator from '@system.vibrator' 
// or 
const vibrator = require('@system.vibrator')
Interface Definition
vibrator.vibrate(OBJECT)
Trigger vibration.

Parameters:
Parameter	Type	Required	Description
mode	String	No	Vibration mode. "long" indicates long vibration, and "short" indicates short vibration. Defaults to long.
Example:
vibrator.vibrate({
  mode: 'long'
})
vibrator.start(OBJECT)
Start vibration.

Parameters:
Parameter	Type	Required	Description
duration	Number	Yes	Vibration duration (in ms). Must be a positive integer.
interval	Number	Yes	Vibration interval (in ms). Must be a positive integer.
count	Number	Yes	Number of vibrations. Must be a positive integer.
success	Function	No	Callback function for success.
fail	Function	No	Callback function for failure.
complete	Function	No	Callback function after execution is complete.
Return Values for success:
Parameter Name	Type	Description
id	Number	Unique ID identifying the vibration task.
Return Values for fail:
Error Code	Description
205	Task already exists.
202	Parameter error.
Example:
vibrator.start({
  duration: 1000,
  interval: 1000,
  count: 10,
  success: function (data) {
    console.log(`handling success, id = ${data.id}`)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}, errorMsg=${data}`)
  },
  complete: function () {
    console.log(`handling complete`)
  }
})
vibrator.stop(Number)
Stop vibration.

Parameters:
Type	Required	Description
Number	Yes	ID of the vibration task.
Return Values:
Type	Description
Boolean	true: Success; false: Failure.
Example:
vibrator.stop(1)
vibrator.getSystemDefaultMode()
Get the system's default vibration mode.

Parameters:
None

Return Values:
Type	Description
Number	0: Vibration off; 1: Standard vibration; 2: Enhanced vibration.
Example:
vibrator.getSystemDefaultMode()
Support Details
Interface	Supported Device Products	Unsupported Device Products
vibrate	Xiaomi S1 Pro Sports & Health Watch, Xiaomi Band 8 Pro, Xiaomi Band 9 / 9 Pro, Redmi Watch 4, Xiaomi Watch H1, Xiaomi Watch S3, Xiaomi Band 10, Xiaomi Watch S4, REDMI Watch 5	-
start	-	Xiaomi Watch S3, Xiaomi Watch S4, REDMI Watch 5, Xiaomi S1 Pro Sports & Health Watch, Xiaomi Band 8 Pro, Xiaomi Band 9 / 9 Pro, Xiaomi Band 10, Redmi Watch 4, Xiaomi Watch H1
stop	-	Xiaomi Watch S3, Xiaomi Watch S4, REDMI Watch 5, Xiaomi S1 Pro Sports & Health Watch, Xiaomi Band 8 Pro, Xiaomi Band 9 / 9 Pro, Xiaomi Band 10, Redmi Watch 4, Xiaomi Watch H1
getSystemDefaultMode	-	Xiaomi Watch S3, Xiaomi Watch S4, REDMI Watch 5, Xiaomi S1 Pro Sports & Health Watch, Xiaomi Band 8 Pro, Xiaomi Band 9 / 9 Pro, Xiaomi Band 10, Redmi Watch 4, Xiaomi Watch H1



Screen Brightness
Interface Declaration
{ "name": "system.brightness" }
Import Module
import brightness from '@system.brightness' 
// or 
const brightness = require('@system.brightness')
Interface Definition
brightness.getValue(OBJECT)
Gets the current screen brightness value.

Parameters:
Parameter	Type	Required	Description
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Completion callback
Success Return Value:
Parameter	Type	Description
value	Integer	Screen brightness (range: 0-255)
Example:
brightness.getValue({
  success: function(data) {
    console.log(`handling success, value = ${data.value}`)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
brightness.setValue(OBJECT)
Sets the current screen brightness value.

Parameters:
Parameter	Type	Required	Description
value	Integer	Yes	Screen brightness (range: 0-255)
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Completion callback
Example:
brightness.setValue({
  value: 100,
  success: function() {
    console.log('handling success')
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
brightness.getMode(OBJECT)
Gets the current screen brightness mode.

Parameters:
Parameter	Type	Required	Description
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Completion callback
Success Return Value:
Parameter	Type	Description
mode	Integer	0: manual brightness adjustment, 1: auto brightness adjustment
Example:
brightness.getMode({
  success: function(data) {
    console.log(`handling success, mode = ${data.mode}`)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
brightness.setMode(OBJECT)
Sets the current screen brightness mode.

Parameters:
Parameter	Type	Required	Description
mode	Integer	Yes	0: manual brightness adjustment, 1: auto brightness adjustment
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Completion callback
Example:
brightness.setMode({
  mode: 1,
  success: function() {
    console.log('handling success')
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
brightness.setKeepScreenOn(OBJECT)
Sets whether to keep the screen on.

Parameters:
Parameter	Type	Required	Description
keepScreenOn	Boolean	Yes	Whether to keep the screen on
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Completion callback
Example:
brightness.setKeepScreenOn({
  keepScreenOn: true,
  success: function() {
    console.log('handling success')
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})



Record
Interface Declaration
{ "name": "system.record" }
Importing the Module
import record from '@system.record' 
// or 
const record = require('@system.record')
Interface Definition
record.start(OBJECT)
Starts recording

Parameters:
Parameter Name	Type	Required	Description
duration	Number	No	Recording duration in ms. If duration is a valid value, recording will stop when the specified value is reached
sampleRate	Number	No	Sampling rate. The supported sampling rate ranges vary for different audio formats. The default is 8000, and it is recommended to use 8000/16000/32000/44100/48000
numberOfChannels	Number	No	Number of recording channels, valid values are 1/2
encodeBitRate	Number	No	Encoding bitrate. The encoding bitrate value depends on the sampling rate and audio format
format	String	No	Audio format, valid values are pcm/opus/wav. Defaults to pcm
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Callback after execution is completed
success Return Value:
Parameter Name	Type	Description
uri	String	Storage path of the recording file, located in the application's cache directory
fail Return Error Codes:
Error Code	Description
205	Recording is already in progress
202	Parameter error
Example:
record.start({
  duration: 10000,
  sampleRate: 8000,
  numberOfChannels: 1,
  encodeBitRate: 128000,
  format: 'pcm',
  success: function(data) {
    console.log(`handling success: ${data.uri}`)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}, errorMsg=${data}`)
  },
  complete: function () {
    console.log(`handling complete`)
  }
})
record.stop()
Stops recording

Parameters:
None

Example:
record.stop()


Geolocation
Interface Declaration
{ "name": "system.geolocation" }
Import Module
import geolocation from '@system.geolocation' 
// or 
const geolocation = require('@system.geolocation')
Interface Definition
geolocation.getLocation(OBJECT)
Obtain geolocation

Permission Requirements
Precise device positioning

Developers need to configure permissions in manifest.json:

{
  "permissions": [
    { "name": "hapjs.permission.LOCATION" }
  ]
}
Parameters:
Parameter Name	Type	Required	Description
timeout	Number	No	Set timeout in milliseconds. The default value is 30000
success	Function	Yes	Callback for success
fail	Function	No	Callback for failure, possibly due to lack of permissions
complete	Function	No	Callback after execution is complete
Return Values for success:
Parameter Name	Type	Description
longitude	Number	Longitude, floating-point number
latitude	Number	Latitude, floating-point number
altitude	Number	Altitude/height in meters, floating-point number
speed	Number	Speed in meters per second, floating-point number
accuracy	Number	Accuracy, positive integer value
accuracyInfo	{ horizontal: Number, vertical: Number }	Accuracy information, including horizontal and vertical accuracy
Error Codes Returned by fail:
Error Code	Description
203	Function not supported
204	Timeout occurred
Example:
geolocation.getLocation({
  success: function(data) {
    console.log(
      `handling success: longitude = ${data.longitude}, latitude = ${
        data.latitude
      }, speed = ${data.speed}, altitude = ${data.altitude}`
    )
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}, errorMsg=${data}`)
  }
})
geolocation.subscribe(OBJECT)
Listen for geolocation changes. If called multiple times, only the last call will take effect.

Permission Requirements
Precise device positioning

Developers need to configure permissions in manifest.json:

{
  "permissions": [
    { "name": "hapjs.permission.LOCATION" }
  ]
}
Parameters:
Parameter Name	Type	Required	Description
callback	Function	Yes	Callback triggered each time the location information changes
fail	Function	No	Callback for failure
Return Values for callback:
Parameter Name	Type	Description
longitude	Number	Longitude, floating-point number
latitude	Number	Latitude, floating-point number
altitude	Number	Altitude/height in meters, floating-point number
speed	Number	Speed in meters per second, floating-point number
accuracy	Number	Accuracy, positive integer value
Error Codes Returned by fail:
Error Code	Description
203	Function not supported
Example:
geolocation.subscribe({
  callback: function(data) {
    console.log(
      `handling success: longitude = ${data.longitude}, latitude = ${
        data.latitude
      }, speed = ${data.speed}, altitude = ${data.altitude}`
    )
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}, errorMsg=${data}`)
  }
})
geolocation.unsubscribe()
Cancel listening for geolocation changes

Permission Requirements
Precise device positioning

Developers need to configure permissions in manifest.json:

{
  "permissions": [
    { "name": "hapjs.permission.LOCATION" }
  ]
}
Parameters:
None

Example:
geolocation.unsubscribe()
Support Details
Device Product	Description
Xiaomi S1 Pro Sports & Health Watch	Not supported
Xiaomi Smart Band 8 Pro	Not supported
Xiaomi Smart Band 9 / 9 Pro	Not supported
Xiaomi Watch S3	Supported
Redmi Watch 4	Not supported
Xiaomi Wrist ECG Blood Pressure Monitor	Not supported
Xiaomi Smart Band 10	Not supported
Xiaomi Watch S4	Supported
REDMI Watch 5	Supported



Sensor
Interface Declaration
{ "name": "system.sensor" }
Import Module
import sensor from '@system.sensor' 
// or 
const sensor = require('@system.sensor')
Interface Definition
Methods
sensor.subscribePressure(OBJECT)
Listens for pressure sensor data. If called multiple times, only the last call takes effect.

Parameters:
Parameter	Type	Required	Description
callback	Function	Yes	Callback triggered each time the pressure information changes.
Callback Return Value:
Parameter	Type	Description
pressure	Number	Pressure, in hPa (hectopascals), floating-point number.
Example:
sensor.subscribePressure({
  callback: function(ret) {
    console.log(`handling callback, pressure = ${ret.pressure}`)
  }
})
sensor.unsubscribePressure()
Cancels listening for pressure sensor data.

Parameters:
None

Example:
sensor.unsubscribePressure()
sensor.subscribeAccelerometer(OBJECT)
Listens for accelerometer sensor data.

Parameters:
Parameter	Type	Required	Description
interval	String	No	Frequency of callback execution for accelerometer data listening. Default is 'normal'.
callback	Function	Yes	Callback triggered when gravity sensor data changes.
fail	Function	No	Callback for subscription errors.
Valid Values for interval:
Value	Description
game	Suitable for game update callback frequency, around 20ms per call.
ui	Suitable for UI update callback frequency, around 60ms per call.
normal	Normal callback frequency, around 200ms per call.
Callback Return Value:
Parameter	Type	Description
x	Number	X-axis coordinate.
y	Number	Y-axis coordinate.
z	Number	Z-axis coordinate.
Example:
sensor.subscribeAccelerometer({
  callback: function(ret) {
    console.log(`handling callback, x = ${ret.x}, y = ${ret.y}, z = ${ret.z}`)
  },
  fail: function(msg, code) {
    console.log(`handling callback, fail:`, msg, code)
  }
})
sensor.unsubscribeAccelerometer()
Cancels listening for accelerometer sensor data.

Parameters:
None

Example:
sensor.unsubscribeAccelerometer()
sensor.subscribeCompass(OBJECT)
Listens for compass data. If called multiple times, only the last call takes effect.

Parameters:
Parameter	Type	Required	Description
callback	Function	Yes	Callback triggered when compass data changes.
fail	Function	No	Callback for subscription failure.
Callback Return Value:
Parameter	Type	Description
direction	Number	Represents the angle between the device's y-axis and the Earth's magnetic north pole. When facing north, the angle is 0; facing south, it is π; facing east, it is π/2; facing west, it is -π/2.
accuracy	Number	Accuracy, see compass accuracy description for details.
Error Codes for fail:
Error Code	Description
1000	The current device does not support the compass sensor.
Example:
sensor.subscribeCompass({
  callback: function (res) {
    console.log(`handling subscribeCompass callback, direction = ${res.direction}, accuracy = ${res.accuracy}`)
  },
  fail: function (data, code) {
    console.log(`handling subscribeCompass fail, code = ${code}`)
  }
})
sensor.unsubscribeCompass()
Cancels listening for compass data.

Parameters:
None

Example:
sensor.unsubscribeCompass()
Compass Accuracy Description:
Value	Description
3	High accuracy.
2	Medium accuracy.
1	Low accuracy.
-1	Unreliable, sensor disconnected.
0	Unreliable, reason unknown.
Support Details
Interface	Supported Device Products	Unsupported Device Products
subscribePressure	Xiaomi Watch S3, Xiaomi Band 9 Pro, Xiaomi Band 10, Xiaomi Watch S4	Xiaomi S1 Pro Sports Health Watch, Xiaomi Band 8 Pro, Xiaomi Band 9, Redmi Watch 4, Xiaomi Watch H1, REDMI Watch 5
unsubscribePressure	Xiaomi Watch S3, Xiaomi Band 9 Pro, Xiaomi Band 10, Xiaomi Watch S4	Xiaomi S1 Pro Sports Health Watch, Xiaomi Band 8 Pro, Xiaomi Band 9, Redmi Watch 4, Xiaomi Watch H1, REDMI Watch 5
subscribeAccelerometer	Xiaomi Band 9 / 9 Pro, Xiaomi Band 10	Xiaomi Watch S3, Xiaomi S1 Pro Sports Health Watch, Xiaomi Band 8 Pro, Redmi Watch 4, Xiaomi Watch H1, Xiaomi Watch S4, REDMI Watch 5
unsubscribeAccelerometer	Xiaomi Band 9 / 9 Pro, Xiaomi Band 10	Xiaomi Watch S3, Xiaomi S1 Pro Sports Health Watch, Xiaomi Band 8 Pro, Redmi Watch 4, Xiaomi Watch H1, Xiaomi Watch S4, REDMI Watch 5
subscribeCompass / unsubscribeCompass	Xiaomi Watch S4, REDMI Watch 5	Other Xiaomi band and watch devices


Event event4+
Interface Declaration
{ "name": "system.event" }

Import Module
import event from '@system.event' 
// or 
const event = require('@system.event')

Interface Definition
event.publish (OBJECT)
Publish a public event.

Parameters:
Parameter Name	Type	Required	Description
eventName	String	Yes	Event name. Reserved names for public events are occupied by the system and should not be used.
options	Object	No	Event parameters
options Parameters:
Parameter Name	Type	Required	Description
params	Object	No	Event parameters
permissions	Array<String>	No	Permissions for subscribers. Only packages with permissions can receive the sent event.
Public Events Supported by the System:
System Internal Event Name	Permissions Required for Subscribers	Description
usual.event.BATTERY_CHANGED	None	Battery level change. Parameter: level: between 0.0 and 1.0
usual.event.DISCHARGING	None	Stop charging
usual.event.CHARGING	None	Start charging
Return Value:
None

Example:
event.publish({
  eventName: 'myEventName',
  options: {
    params: { age: 10, name: 'peter' },
    permissions: ['com.example.demo']
  }
})

event.subscribe(OBJECT)
Subscribe to a public event.

Parameters:
Parameter Name	Type	Required	Description
eventName	String	Yes	Event name
callback	Function	Yes	Callback function
Callback Parameters:
Parameter Name	Type	Required	Description
params	Object	No	Event parameters
package	String	No	Package name of the event sender
Return Value:
Type	Required	Description
Number	Yes	Event ID. Returns undefined if subscription fails.
Example:
const evtId = event.subscribe({
  eventName: 'myEventName',
  callback: function(res) {
    if (res.package === 'com.example.demo') {
      console.log(res.params)
    }
  }
})
console.log(evtId)

event.unsubscribe(OBJECT)
Cancel subscription to a public event.

Parameters:
Parameter Name	Type	Required	Description
id	Number	Yes	Subscription ID
Example:
const evtId = event.subscribe({
  eventName: 'myEventName',
  callback: function(res) {
    if (res.package === 'com.example.demo') {
      console.log(res.params)
    }
  }
})

event.unsubscribe({ id: evtId })

Support Details
Device Product	Description
Xiaomi S1 Pro Sports and Health Watch	Not supported
Xiaomi Band 8 Pro	Not supported
Xiaomi Band 9 / 9 Pro	Not supported
Xiaomi Watch S3	Not supported
Redmi Watch 4	Not supported
Xiaomi Wrist ECG Blood Pressure Monitor	Not supported
Xiaomi Band 10	Supported
Xiaomi Watch S4	Supported
REDMI Watch 5	Supported



Battery Information battery
Interface Declaration
{ "name": "system.battery" }

Import Module
import battery from '@system.battery' 
// or 
const battery = require('@system.battery')

Interface Definition
battery.getStatus(OBJECT)
Obtain the battery information of the current device.

Parameters:
Parameter Name	Type	Required	Description
success	Function	No	Callback for success
fail	Function	No	Callback for failure
complete	Function	No	Callback after execution completion
Return Values for success:
Parameter Name	Type	Description
charging	Boolean	Whether charging is in progress
level	Number	Current battery level, ranging from 0.0 to 1.0
Example
battery.getStatus({
  success: function(data) {
      console.log(`handling success: ${data.level}`)
  },
  fail: function(data, code) {
      console.log(`handling fail, code = ${code}`)
  }
})

Support Details
Device Product	Description
Xiaomi S1 Pro Sports and Health Watch	Not supported
Xiaomi Band 8 Pro	Not supported
Xiaomi Band 9 / 9 Pro	Not supported
Xiaomi Watch S3	Not supported
Redmi Watch 4	Not supported
Xiaomi Wrist ECG Blood Pressure Monitor	Not supported
Xiaomi Band 10	Supported
Xiaomi Watch S4	Supported
REDMI Watch 5	Supported



System Volume
Interface Declaration
{ "name": "system.volume" }
Import Module
import volume from '@system.volume' 
// or 
const volume = require('@system.volume')
Interface Definition
volume.getMediaValue (OBJECT)
Gets the current media volume.

Parameters
Parameter	Type	Required	Description
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Callback after execution ends
success Return Value:
Parameter	Type	Description
value	Number	Current system media volume, between 0.0 and 1.0
Example
volume.getMediaValue({
  success: function(data) {
    console.log(`handling success: ${data.value}`)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
volume.setMediaValue (OBJECT)
Sets the current media volume.

Parameters
Parameter	Type	Required	Description
value	Number	Yes	Volume to set, between 0.0 and 1.0
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Callback after execution ends
fail Return Value:
Supports common error codes

Example
volume.setMediaValue({
  value: 0.5,
  success: function() {
    console.log('handling success')
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})
Events
volume.onMediaValueChanged
Triggered when the media volume changes.

Callback Object Parameters:
Parameter	Type	Required	Description
value	Number	Yes	Current system media volume, range: between 0.0 and 1.0
Example
volume.onMediaValueChanged = function(res) {
  console.log('volume media value changed:', res.value)
}



Unzip
Interface Declaration
{ "name": "system.zip" }
Import Module
import zip from '@system.zip'
// or
const zip = require('@system.zip')
Interface Definition
zip.decompress(OBJECT)
Unzip file

Parameters:
Parameter Name	Type	Required	Description
srcUri	String	Yes	URI of the source file, cannot be a tmp type URI
dstUri	String	Yes	URI of the target directory, cannot be an application resource path or a tmp type URI
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Callback after execution ends
success Return Value:
None

fail Return Value:
Error Code	Description
202	Parameter error
300	I/O error
Example:
zip.decompress({
  srcUri: 'internal://cache/test.zip',
  dstUri: 'internal://files/unzip/',
  success: function() {
    console.log(`handling success`)
  },
  fail: function(data, code) {
    console.log(`handling fail, code = ${code}`)
  }
})


Others
Other abilities.

Audio
Prompt

Audio
Interface Declaration
{ "name": "system.audio" }

Importing the Module
import audio from '@system.audio' 
// or 
const audio = require('@system.audio')

Methods
audio.play()
Starts audio playback.

Parameters
None

Example:
audio.play()

audio.pause()
Pauses audio playback.

Parameters
None

Example:
audio.pause()

audio.stop()
Stops audio playback. Playback can be restarted with play.

Parameters
None

Example:
audio.stop()

audio.getPlayState(OBJECT)
Retrieves the current playback state data.

Parameters
Parameter	Type	Required	Description
success	Function	No	Success callback
fail	Function	No	Failure callback
complete	Function	No	Completion callback
success Return Value:
Parameter Value	Type	Description
state	String	Playback state: 'play', 'pause', 'stop'
src	String	URI of the currently playing audio media; empty string when stopped
currentTime	Number	Current progress of the audio in seconds; -1 when stopped
percent	Number	Current playback progress percentage (0-100)
autoplay	Boolen	Whether the audio is autoplaying
loop	Boolen	Whether the audio is looping
volume	Number	Audio volume (default: system media volume; range: [0.0,1.0])
muted	Boolen	Whether the audio is muted
duration	Number	Duration of the audio in seconds; NaN if unknown
Example:
audio.getPlayState({
  success: function(data) {
    console.log(`handling success: state: ${data.state},src:${data.src},currentTime:${data.currentTime},autoplay:${data.autoplay},loop:${data.loop},volume: ${data.volume},muted:${data.muted},notificationVisible:${data.notificationVisible}`)
  },
  fail: function(data, code) {
    console.log('handling fail, code=' + code)
  }
})

Properties
Name	Type	Readable	Writable	Required	Description
src	String	Yes	Yes	Yes	URI of the audio media to play
currentTime	Number	Yes	Yes	No	Current progress of the audio in seconds; setting this adjusts playback position
duration	Number	Yes	No	No	Duration of the audio in seconds; NaN if unknown
autoplay	Boolean	Yes	Yes	No	Whether the audio autoplays (default: false)
loop	Boolean	Yes	Yes	No	Whether the audio loops (default: false)
volume	Number	Yes	Yes	No	Audio volume (default: system media volume; range: [0.0,1.0])
muted	Boolean	Yes	Yes	No	Whether the audio is muted (default: false)
streamType	String	Yes	No	No	Audio stream type: 'music' (speaker) or 'voicecall' (earpiece; not supported on watches/bands); default: 'music'
meta	Object<{title: string, artist: string, album: string}>	No	Yes	No	Audio metadata including title, artist, and album
Example:
// let currentTime = audio.currentTime
audio.currentTime = 5

Events
Name	Description
play	Triggered after play() is called or when autoplay is true. Passive trigger examples: 1. Bluetooth headset control to play audio
pause	Triggered after pause() is called. Passive trigger examples: 1. Audio focus lost (e.g., incoming call); 2. Bluetooth headset control to pause audio
stop	Triggered after stop() is called. Passive trigger example: 1. Playing audio during a call
loadeddata	Triggered when audio data is first loaded
ended	Triggered when playback ends
durationchange	Triggered when the duration changes
error	Triggered when a playback error occurs
Example:
audio.onplay = function() {
  console.log(`audio starts to play`)
}
audio.onplay = null



Popup
Interface declaration
{ "name": "system.prompt" }

Import module
import prompt from '@system.prompt' 
// or 
const prompt = require('@system.prompt')

Interface definition
prompt.showToast(OBJECT)
Displays Toast prompt information

Parameters
Parameter name	Type	Required	Description
message	String	Yes	The text information to be displayed
duration	Number	No	The display duration in milliseconds. The default value is 1500. The recommended range is 1500-10000.
Example:
prompt.showToast({
  message: 'Message Info',
  duration: 2000
})


Device Communication Interconnect
open source projects：
https://github.com/Searchstars/HyperbiliInterconnect
About
Interconnect Android Client for Hyperbilibili

https://github.com/Searchstars/HyperbiliInterconnectUI
About
WebUI for HyperbiliInterconnect
hyperbili-interconnect-ui
This template should help get you started developing with Vue 3 in Vite.

Recommended IDE Setup
VSCode + Volar (and disable Vetur).

Customize configuration
See Vite Configuration Reference.

Project Setup
npm install
Compile and Hot-Reload for Development
npm run dev
Compile and Minify for Production
npm run build


现有的开源工具
https://github.com/SarmonFish/vela-interconnfetch-android
About
vela-interconnfetch-android
InterconnFetch
通过手机app让小米手环9/10支持fetch协议

📋 项目结构
InterconnFetch/
├── app/
│   ├── src/main/
│   │   ├── java/com/sarmon/interconnfetch/
│   │   │   ├── MainActivity.kt          # 主活动
│   │   │   ├── service/
│   │   │   │   └── FetchNotificationService.kt  # 同步服务
│   │   │   └── ui/
│   │   │       └── message/             # UI组件
│   │   ├── res/                       # 资源文件
│   │   │   ├── layout/               # 布局文件
│   │   │   ├── drawable/             # 图标和背景
│   │   │   ├── values/                # 字符串和样式
│   │   │   └── mipmap/               # 应用图标
│   │   └── AndroidManifest.xml        # 应用清单
│   ├── build.gradle                   # 应用模块构建配置
│   └── proguard-rules.pro             # ProGuard规则
├── build.gradle                       # 项目构建配置
├── gradle.properties                  # Gradle配置
├── settings.gradle                    # 项目设置
└── README.md                          # 项目文档
🚦快速开始
安装步骤
克隆项目

git clone https://github.com/yourusername/InterconnFetch.git
cd InterconnFetch
配置开发环境

Android Studio
选择“打开现有的 Android Studio 项目”
选择项目根目录
配置本地设置

创建local.properties文件（如果不存在）
添加Android SDK路径：
sdk.dir=/path/to/your/Android/Sdk
建设项目

点击“将项目与 Gradle 文件同步”
等待同步完成
点击“构建”→“制作项目”
🔧 配置说明
签名配置
项目使用签名配置来保证应用的安全性。在发布版本时，请配置您自己的签名信息：

创建keystore.properties文件
配置签名信息：
release.store.file=/path/to/your/keystore.jks
release.store.password=your_keystore_password
release.key.alias=your_key_alias
release.key.password=your_key_password
权限配置
申请在AndroidManifest.xml中声明了以下权限：

READ_EXTERNAL_STORAGE: 读取外部存储
INTERNET: 网络访问
ACCESS_NETWORK_STATE: 网络状态检测
POST_NOTIFICATIONS: 发送通知
FOREGROUND_SERVICE: 前台服务
📄 许可证
本项目采用AGPL-3.0许可证 - 查看LICENSE文件了解详情。